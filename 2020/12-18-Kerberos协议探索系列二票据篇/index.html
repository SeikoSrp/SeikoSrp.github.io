<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="SeikoSrp">






<title>Kerberos协议探索系列二票据篇 | a blog</title>



    <link rel="icon" href="/haidao.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/js/jquery.min.js"></script>
    



    
    
        
    




    <script>
    function searchToggle() {
        const width = $(document.body).width()
        if(width > 479) {
            return;
        }
        const search = $('.search');
        const searchForm = $('.form-search');
        const menuToggle = $('.menu-toggle');
        const title = $('.navbar-header-title');

        if(!search.hasClass("mobile-search")) {
            search.addClass("mobile-search");
            menuToggle.addClass("open-search")
            title.addClass("mobile-title-hidden")
        } else {
            search.removeClass("mobile-search");
            menuToggle.removeClass("open-search")
            // title.css({visibility: 'visible'})
            title.removeClass("mobile-title-hidden")
        } 
    }

    function search(searchInputEl, formEl, flag) {
        const path = "/" + "search.json"; // 可以在public 下查看这个search.json
        $(formEl).submit(function(e){
            e.preventDefault();
            let target = null
            if(searchInputEl == null) {
                const screenWidth = $(document.body).width();
                target = screenWidth > 479 ? $('#pc-search-input') : $('#mobile-search-input');
                console.log(target);
            } else {
                target = $(searchInputEl)
            }

            if(!flag && target.val() === '') {
                return ;
            }

            $("#u-search").fadeIn(500, function() {
                $("body > .wrapper").addClass("modal-active");

                $.ajax({
                    url: path,
                    dataType: "json",
                    beforeSend: function (xhr) {
                        $input = target.val();
                        $(".form-input").val($input);
                        const loadingBar = $('.search-loading-bar') 
                        loadingBar.css({
                            width:'100%',
                            display: 'block'
                        });
                    },
                    success: function( datas ) {
                        // console.log(datas);
                        const $resultPanel = $(".modal-body")[0];
                        let str = `<ul class="modal-results">`;
                        var keywords = $(".form-input").val().trim().toLowerCase().split(/[\s\-]+/);
                        $resultPanel.innerHTML = "";
                        let hasResult = false
                        let text = `<div class="no-result">找不到与关键词相关的内容....</div>`;

                        if ($(".form-input").val().trim().length <= 0) {
                            // 没有结果
                            $resultPanel.innerHTML = text;
                            return;
                        }
                        datas.forEach(function (data) {
                            var isMatch = true;
                            if (!data.title || data.title.trim() === '') {
                                data.title = "Untitled";
                            }
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty contents
                            if (data_content !== '') {
                                keywords.forEach(function (keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);

                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        hasResult = true
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            } else {
                                isMatch = false;
                            }
                            // show search results
                            if (isMatch) {
                                str += `<li class='result-item'><a href='${data_url}' class='result-item-detail'> <span class="title">${data_title}</span>`;
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 200 characters
                                    var start = first_occur - 40;
                                    var end = first_occur + 160;

                                    if (start < 0) {
                                        start = 0;
                                    }

                                    if (start == 0) {
                                        end = 200;
                                    }

                                    if (end > content.length) {
                                        end = content.length;
                                    }

                                    var match_content = content.substring(start, end);

                                    // highlight all keywords
                                    keywords.forEach(function (keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, `<em class="search-keyword">${keyword}</em>`);
                                    });

                                    str += `<span class="content"> ${match_content} ...</span></a>`;
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        if(hasResult) {
                            $resultPanel.innerHTML = str;
                        } else {
                            $resultPanel.innerHTML = text;
                        }

                    },
                    complete: function() {
                        setTimeout(() => {
                                const loadingBar = $('.search-loading-bar') 
                                loadingBar.css({
                                    width:'0%',
                                    display: 'none'
                                });
                        }, 300)
                    }
                });
            })

        });
    }

    $(document).ready(function() {
        $('.modal-close').click(function () { 
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })

        $('.modal-overlay').click(function() {
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })
        search(null, ".form-search", false)
        search("#u-search-modal-form .form-input", ".u-search-modal-form", true)
    })
</script>

<meta name="generator" content="Hexo 4.2.1"></head>
<body>
<!-- Chic/layout.ejs -->
 <div id="u-search">
        <div class="modal">
            <div class="modal-header">
                <div class="container">
                    <form id="u-search-modal-form" class="u-search-modal-form">
                        <button type="submit" class="form-submit-btn">
                            <img src="/image/search.png" class="search-btn-img" />
                        </button>
                        <input placeholder="搜索文章。。。" class="form-input" id="modal-form-input">
                    </form>
                    <a class="modal-close">x</a>
                </div>
                <div class="search-loading">
                    <div class="search-loading-bar"></div>
                </div>
            </div>
            <div class="modal-body">
                <!-- ul 格式如下 -->
                <!-- <ul class="modal-results">
                    <li class="result-item">
                        <a class="result-item-detail">
                            <span class="title">页面配置</span>
                            <span class="content">
                                content
                            </span>
                        </a>
                    </li>
                </ul> -->
            </div>
        </div>
        <div class="modal-overlay"></div>
    </div>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">SeikoSrp&#39;s Blog</a></div>
            <div class="menu navbar-right">
                <!-- 这里表示的是pc端搜索框 -->
                
                
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/search.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="搜索文章" autocomplete="off" id="pc-search-input"/>
        </form>
    </div>

                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">SeikoSrp&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="navbar-mobile-right">
                    
                    
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/search.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="搜索文章" autocomplete="off" id="mobile-search-input"/>
        </form>
    </div>

                    <div class="menu-toggle" onclick="mobileBtn()">&#9776; 目录</div>
                </div>
                
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/about">关于</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">全部展开</a>
        <a onclick="go_top()">回到顶部</a>
        <a onclick="go_bottom()">前往底部</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "全部折叠"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "全部展开"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Kerberos协议探索系列二票据篇</h1>
            
                <div class="post-meta">
                    
                        作者: <a itemprop="author" rel="author" href="/">SeikoSrp</a>
                    

                    
                        <span class="post-time">
                        发布于: <a href="#">十二月 18, 2020&nbsp;&nbsp;18:47:41</a>
                        </span>
                    
                    
                        <span class="post-category">
                    分类:
                            
                                <a href="/categories/RedTeam-%E5%9F%9F%E5%AE%89%E5%85%A8/">RedTeam&域安全</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>Freebuf链接：<a href="https://www.freebuf.com/articles/system/197160.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/197160.html</a></p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在上一篇中说明了Kerberos的原理以及SPN的扫描和Kerberoasting的攻击方式，本章具体说一下Kerberos曾经爆出的一个经典的漏洞MS14068和金银票据的原理和利用方式。MS14068是一个比较经典的漏洞，曾经也有同学在平台上说明过，本文炒一次冷饭并且对增强型的金票据做一个说明。</p>
<h1 id="0x01-MS14068"><a href="#0x01-MS14068" class="headerlink" title="0x01 MS14068"></a>0x01 MS14068</h1><p>MS14068是一个能够使普通用户提权到域控权限的权限提升漏洞。攻击者可以通过构造特定的请求包来达到提升权限的目的。首先我们来说一下利用方式。</p>
<h2 id="1-利用方式"><a href="#1-利用方式" class="headerlink" title="1 利用方式"></a>1 利用方式</h2><p>实验环境：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">域：YUNYING.LAB</span><br><span class="line">域控：Windows Server 2008 R2 x64(DC)</span><br><span class="line">域内主机：Windows 7 x64(s1):域帐户ts1</span><br><span class="line">所需工具：</span><br><span class="line">Pykek</span><br><span class="line">mimikatz</span><br></pre></td></tr></table></figure>

<p>攻击流程：</p>
<p>实验之前需要在域控主机查看是否安装了KB3011780补丁，可通过systeminfo来查看。</p>
<p>一、首先在域内主机s1上通过dir来访问域控的共享文件夹，示拒绝访问。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790834232.png" alt="1575790834232"></p>
<p>二、通过Pykek工具利用漏洞，我这里使用的是将python脚本编译之后的exe文件。</p>
<p>参数说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-u 域账号+@+域名称，这里是ts1+@+yunying.lab</span><br><span class="line">-p 为当前用户的密码，即ts1的密码</span><br><span class="line">-s为ts1的SID值，可以通过whoami &#x2F;all来获取用户的SID值</span><br><span class="line">-d为当前域的域控</span><br></pre></td></tr></table></figure>

<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790850579.png" alt="1575790850579"></p>
<p>脚本执行成功会在当前目录下生成一个ccache文件。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790859781.png" alt="1575790859781"></p>
<p>三、使用mimikatz导入生成的ccache文件，导入之前cmd下使用命令klist purge或者在mimikatz中使用kerberos::purge删除当前缓存的kerberos票据。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790892397.png" alt="1575790892397"></p>
<p>再次dir访问域控共享已经可以成功访问。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790902960.png" alt="1575790902960"></p>
<h2 id="2-漏洞原理"><a href="#2-漏洞原理" class="headerlink" title="2 漏洞原理"></a>2 漏洞原理</h2><p>MS14068工具在使用过程中抓包可以看到s1和域控192.168.254.130（实质上是与安装在域控上的KDC）有KRB_AS_REQ、KRB_AS_REP、KRB_TGS_REQ、KRB_TGS_REP四次交互。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790909506.png" alt="1575790909506"></p>
<p>下面根据流程和工具源码来看漏洞是如何利用的：</p>
<h3 id="KRB-AS-REQ"><a href="#KRB-AS-REQ" class="headerlink" title="KRB_AS_REQ"></a>KRB_AS_REQ</h3><p>首先程序通过build_as_req函数构建AS_REQ，在这里可以看到，参数pac_request设置为false。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790919863.png" alt="1575790919863"></p>
<p>也就是说设置了这个参数之后会向KDC申请一张不包含PAC的TGT票据，这是微软默认的设计，在下列链接中有详细说明。</p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#security-considerations" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#security-considerations</a></p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790930929.png" alt="1575790930929"></p>
<p>通过PCAP包可以更直观的看到在AS-REQ请求中的include-pac:False字段。这是造成这个漏洞的第一个因素。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790938342.png" alt="1575790938342"></p>
<h3 id="KRB-AS-REP"><a href="#KRB-AS-REP" class="headerlink" title="KRB_AS_REP"></a>KRB_AS_REP</h3><p>在AS发起请求之后，KDC（AS）将返回一张不包含有PAC的TGT票据给Client。在这里是tgt_a。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790943196.png" alt="1575790943196"></p>
<p>抓包可以看到这个以268fdb开头的TGT票据。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790949830.png" alt="1575790949830"></p>
<h3 id="KRB-TGS-REQ"><a href="#KRB-TGS-REQ" class="headerlink" title="KRB_TGS_REQ"></a>KRB_TGS_REQ</h3><p>攻击脚本使用了两个关键函数来实现这个过程，首先通过build构造PAC，然后通过build_tgs_req函数构造TGS-REQ的内容。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790956188.png" alt="1575790956188"></p>
<h4 id="build-pac"><a href="#build-pac" class="headerlink" title="build_pac"></a>build_pac</h4><p>当Client接收到AS返回的不带有PAC的TGT之后通过脚本中的build_pac函数开始构造PAC。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790962750.png" alt="1575790962750"></p>
<p>这里我们重点关注一下PAC中的chksum1和chksum2，也就是“PAC的引入”中提到的PAC的两个数字签名PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM。</p>
<p>注意一下其中第一个参数server_key[0]和kdc_key[0]的值其实是程序指定的RSA_MD5，而Key的值为None，但原则上来说这个加密方式是应该由KDC来确定的。也就是说加密PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM这两个数字签名的Key应该分别是Server密码HASH和KDC密码HASH，在这里却直接使Key为None，然后直接使用RSA_MD5方式加密。</p>
<p>这是漏洞形成的第二个因素，查看checksum函数即可验证这一点。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790971624.png" alt="1575790971624"></p>
<p>同时在这个过程中我们也需要关注一下user_sid这个参数，build_pac函数会将其分割，然后重新构造高权限的sid的值。在这里user_sid的值为S-1-5-21-4249968736-1423802980-663233003-1104，分割之后domain_sid为S-1-5-21-4249968736-1423802980-663233003，user_id为1104。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790979824.png" alt="1575790979824"></p>
<p>其中512、520、518、519分别为不同的组的sid号。513为DOMAIN USERS组。通过这种方式构造了包含高权限组SID的PAC。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790986788.png" alt="1575790986788"></p>
<h4 id="build-tgs-req"><a href="#build-tgs-req" class="headerlink" title="build_tgs_req"></a>build_tgs_req</h4><p>在build_tgs_req函数的参数中，authorization_data对应的为build_pac生成的pac。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790992562.png" alt="1575790992562"></p>
<p>这里将PAC传入build_tgs_req之后使用subkey将其加密。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575790998246.png" alt="1575790998246"></p>
<p>而通过下图可以看到subkey其实是函数generate_subkey生成的一串16位的随机数。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791006188.png" alt="1575791006188"></p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791015789.png" alt="1575791015789"></p>
<p>那现在为止出现的问题有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A、在域中默认允许设置Include-pac的值为False（不能算漏洞，应该是微软对于某些特定场景的特殊考虑设计出的机制）。</span><br><span class="line">B、PAC中的数字签名可以由Client端指定，并且Key的值可以为空。</span><br><span class="line">C、PAC的加密方式也可以由Client指定，并且Key的值为generate_subkey函数生成的16位随机数。</span><br><span class="line">D、构造的PAC中包含高权限组的SID内容。</span><br></pre></td></tr></table></figure>

<p>也就是说通过这几点Client完全伪造了一个PAC发送给KDC，并且KDC通过Client端在请求中指定的加密算法来解密伪造的PAC以及校验数字签名，并验证通过。通过抓包可以看到在这个过程中将接收的TGT（268fdb开头）和加密方式为ARCFOUR-HMAC-MD5的PAC内容。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791041899.png" alt="1575791041899"></p>
<h3 id="KRB-TGS-REP"><a href="#KRB-TGS-REP" class="headerlink" title="KRB_TGS_REP"></a>KRB_TGS_REP</h3><p>KDC在根据对伪造的PAC验证成功之后，返回给Client端一有新的TGT，并且这个TGT会将Pykek生成的PAC包含在其中，这里正常情况下返回的其实是一张用于发送给Server端做认证的ST票据。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791048480.png" alt="1575791048480"></p>
<p>当Pykek工具接收到新的TGT之后就将其保存生成ccache文件。也就是说这时Client已经获得了一张包含有高权限PAC内容的正常的TGT票据（564eab开头）。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791056012.png" alt="1575791056012"></p>
<h3 id="使用Mimikatz利用TGT访问DC共享文件夹"><a href="#使用Mimikatz利用TGT访问DC共享文件夹" class="headerlink" title="使用Mimikatz利用TGT访问DC共享文件夹"></a>使用Mimikatz利用TGT访问DC共享文件夹</h3><p>这时我们通过mimikatz来导入票证，并且用dir \dc.yunying.lab\c$来访问域控的共享文件夹。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791061476.png" alt="1575791061476"></p>
<p>抓包可以看到这时Client端发起了两次TGS-REQ请求，重点关注一下第一次，此时用的票据就是使用mimikatz导入的TGT，也就是上面KRB_TGS_REP过程中返回的那个tgt_b（564eab开头）。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791067132.png" alt="1575791067132"></p>
<p>请求之后返回了一张针对dc.yunying.lab（域控）的CIFS票据也就是正常流程中的ST（Service Ticket）票据（234062开头）：</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791071336.png" alt="1575791071336"></p>
<p>这时在抓的包中发现并没有AP_REQ这个流程，是因为在Kerberos中AP_REQ这个过程放在了服务的第一次请求中，这里是放在SMB的Session Setup Request中（其他协议同理，比如HTTP协议是放在GET请求中）。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791077089.png" alt="1575791077089"></p>
<p>然后在SMB的Session Setup Response中做出响应，也就是AP-REP这个流程。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791081317.png" alt="1575791081317"></p>
<p>到此为止Client能够越权访问域控的共享文件夹。</p>
<h2 id="3-防御与检测"><a href="#3-防御与检测" class="headerlink" title="3 防御与检测"></a>3 防御与检测</h2><p>此漏洞是一个14年的漏洞，多数产生在windows server 2008和windows server 2003的域环境中，所以安全补丁早已可以下载安装，用户可以通过在域控上安装KB3011780补丁来规避风险。</p>
<p>同时可以根据上文中提到的标记include-pac为False的特征来初步的筛选。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791086872.png" alt="1575791086872"></p>
<p>也可以通过windows日志来发现，如ID为4624登录到目标服务器、ID为5140表示网络共享对象被访问等等。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791091307.png" alt="1575791091307"></p>
<p>在这个漏洞中主要的问题是存在于KDC会根据客户端指定PAC中数字签名的加密算法，以及PAC的加密算法，来校验PAC的合法性。这使得攻击者可通过伪造PAC，修改PAC中的SID，导致KDC判断攻击者为高权限用户，从而导致权限提升漏洞的产生。</p>
<h1 id="0x02-Golden-Ticket"><a href="#0x02-Golden-Ticket" class="headerlink" title="0x02 Golden Ticket"></a>0x02 Golden Ticket</h1><p><strong>简介</strong></p>
<p>Golden Ticket（下面称为金票）是通过伪造的TGT（Ticket Granting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。可以说有了金票就有了域内的最高权限。</p>
<p><strong>制作金票的条件：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、域名称 </span><br><span class="line">2、域的SID值 </span><br><span class="line">3、域的KRBTGT账户密码HASH</span><br><span class="line">4、伪造用户名，可以是任意的</span><br></pre></td></tr></table></figure>

<p><strong>实验环境</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">域：YUNYING.LAB</span><br><span class="line">域控：Windows Server 2008 R2 x64(DC)</span><br><span class="line">域内主机：Windows 7 x64(s1):用户ts1</span><br></pre></td></tr></table></figure>

<p><strong>所需工具</strong></p>
<p>​         Mimikatz</p>
<p><strong>实验流程</strong></p>
<p>金票的生成需要用到krbtgt的密码HASH值，可以通过mimikatz中的</p>
<p>lsadump::dcsync /domain:yunying.lab /user:krbtgt命令获取krbtgt的值。如果已经通过其他方式获取到了KRBTGT HASH也可以直接进行下一步。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791118360.png" alt="1575791118360"></p>
<p>得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。</p>
<p>参数说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;admin：伪造的用户名</span><br><span class="line">&#x2F;domain：域名称</span><br><span class="line">&#x2F;sid：SID值，注意是去掉最后一个-后面的值</span><br><span class="line">&#x2F;krbtgt：krbtgt的HASH值</span><br><span class="line">&#x2F;ticket：生成的票据名称</span><br></pre></td></tr></table></figure>

<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791140670.png" alt="1575791140670"></p>
<p>金票的使用</p>
<p>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791145823.png" alt="1575791145823"></p>
<p>已经可以通过dir成功访问域控的共享文件夹。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791151638.png" alt="1575791151638"></p>
<p>这样的方式导入的票据20分钟之内生效，如果过期再次导入就可以，并且可以伪造任意用户。</p>
<h1 id="0x03-Silver-Tickets"><a href="#0x03-Silver-Tickets" class="headerlink" title="0x03 Silver Tickets"></a>0x03 Silver Tickets</h1><p><strong>简介</strong></p>
<p>Silver Tickets（下面称银票）就是伪造的ST（Service Ticket），因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务。</p>
<p><strong>制作银票的条件：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.域名称 </span><br><span class="line">2.域的SID值 </span><br><span class="line">3.域的服务账户的密码HASH（不是krbtgt，是域控）</span><br><span class="line">4.伪造的用户名，可以是任意用户名，这里是silver</span><br></pre></td></tr></table></figure>

<p><strong>实验环境</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">域：YUNYING.LAB</span><br><span class="line">域控：Windows Server 2008 R2 x64(DC)</span><br><span class="line">域内主机：Windows 7 x64(s1):用户ts1</span><br></pre></td></tr></table></figure>

<p><strong>所需工具</strong></p>
<p>​         Mimikatz</p>
<p><strong>实验流程</strong></p>
<p>首先我们需要知道服务账户的密码HASH，这里同样拿域控来举例，通过mimikatz查看当前域账号administrator的HASH值。注意，这里使用的不是Administrator账号的HASH，而是DC$的HASH。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791253797.png" alt="1575791253797"></p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791257722.png" alt="1575791257722"></p>
<p>这时得到了DC的HASH值，通过mimikatz生成银票。</p>
<p>参数说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;domain：当前域名称</span><br><span class="line">&#x2F;sid：SID值，和金票一样取前面一部分</span><br><span class="line">&#x2F;target：目标主机，这里是dc.yunying.lab</span><br><span class="line">&#x2F;service：服务名称，这里需要访问共享文件，所以是cifs</span><br><span class="line">&#x2F;rc4：目标主机的HASH值</span><br><span class="line">&#x2F;user：伪造的用户名</span><br><span class="line">&#x2F;ptt：表示的是Pass The Ticket攻击，是把生成的票据导入内存，也可以使用&#x2F;ticket导出之后再使用kerberos::ptt来导入</span><br></pre></td></tr></table></figure>

<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791283382.png" alt="1575791283382"></p>
<p>这时通过klist查看本机的kerberos票据可以看到生成的票据。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791288724.png" alt="1575791288724"></p>
<p>使用dir \dc.yunying.lab\c$访问DC的共享文件夹。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791292461.png" alt="1575791292461"></p>
<p>银票生成时没有KRBTGT的密码，所以不能伪造TGT票据，只能伪造由Server端密码加密的ST票据，只能访问指定的服务。</p>
<h1 id="0x04-Enhanced-Golden-Tickets"><a href="#0x04-Enhanced-Golden-Tickets" class="headerlink" title="0x04 Enhanced Golden Tickets"></a>0x04 Enhanced Golden Tickets</h1><p>在Golden Ticket部分说明可利用krbtgt的密码HASH值生成金票，从而能够获取域控权限同时能够访问域内其他主机的任何服务。但是普通的金票不能够跨域使用，也就是说金票的权限被限制在当前域内。</p>
<h2 id="1普通金票的局限性"><a href="#1普通金票的局限性" class="headerlink" title="1普通金票的局限性"></a>1普通金票的局限性</h2><p>为什么普通金票会被限制只能在当前域内使用？</p>
<p>在上一篇文章中说到了域树和域林的概念，同时说到YUNYING.LAB为其他两个域（NEWS.YUNYING.LAB和DEV.YUNYING.LAB）的根域，根域和其他域的最大的区别就是根域对整个域林都有控制权。而域正是根据Enterprise Admins组（下文会说明）来实现这样的权限划分。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791300987.png" alt="1575791300987"></p>
<h2 id="2-实验演示"><a href="#2-实验演示" class="headerlink" title="2 实验演示"></a>2 实验演示</h2><p><strong>实验环境</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">根域：YUNYING.LAB</span><br><span class="line">域控：DC.YUNYING.LAB</span><br><span class="line"></span><br><span class="line">子域：NEWS.YUNYING.LAB</span><br><span class="line">域控：NEWSDC.NEWS.YUNYING.LAB</span><br><span class="line"></span><br><span class="line">子域：DEV.YUNYING.LAB</span><br><span class="line">域控：DEVDC.DEV.YUNYING.LAB</span><br><span class="line"></span><br><span class="line">操作系统均为Windows Server 2008 R2 x64</span><br></pre></td></tr></table></figure>

<p><strong>使用工具：</strong></p>
<p>​         Mimikatz</p>
<p><strong>实验流程：</strong></p>
<p>首先使用mimikatz在NEWSDC（NEWS.YUNYING.LAB的域控）上生成普通的金票，真实环境会是在域内的主机中，这里方便演示所以在域控中，原理和结果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kerberos::golden &#x2F;admin:administrator &#x2F;domain:news.yunying.lab &#x2F;sid:SID &#x2F;krbtgt:XXXXX &#x2F;ptt</span><br></pre></td></tr></table></figure>

<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791353792.png" alt="1575791353792"></p>
<p>这里使用的是NEWS.YUNYING.LAB域的SID号，访问根域的DC共享文件夹被拒绝。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791363212.png" alt="1575791363212"></p>
<p>下面说明下具体原因。</p>
<h3 id="Enterprise-Admins组"><a href="#Enterprise-Admins组" class="headerlink" title="Enterprise Admins组"></a>Enterprise Admins组</h3><p>Enterprise Admins组是域中用户的一个组，只存在于一个林中的根域中，这个组的成员，这里也就是YUNYING.LAB中的Administrator用户（不是本地的Administrator，是域中的Administrator）对域有完全管理控制权。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791369462.png" alt="1575791369462"></p>
<p>通过whoami命令在yunying.lab的域控上可以看到Enterprise Admins组的RID为519（最后三位）</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791375830.png" alt="1575791375830"></p>
<h3 id="Domain-Admins组"><a href="#Domain-Admins组" class="headerlink" title="Domain Admins组"></a>Domain Admins组</h3><p>可以看到在子域中是不存在Enterprise Admins组的，在一个子域中权限最高的组就是Domain Admins组。截图是news.yunying.lab这个子域中的Administrator用户，这个Administrator有当前域的最高权限。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791426283.png" alt="1575791426283"></p>
<p>通过whoami命令也可以看到在news.yunying.lab这个子域中没有Enterprise Admins组的SID号。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791450706.png" alt="1575791450706"></p>
<p>在子域中使用mimikatz创建的黄金票据不能跨域使用的原因也就在这里，通过whoami可以看到YUNYING.LAB中Enterprise Admins组的SID号是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-1-5-21-4249968736-1423802980-663233003-519</span><br></pre></td></tr></table></figure>

<p>而NEWS.YUNYING.LAB域中的SID号是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-1-5-21-3641416521-285861825-2863956705-XXX</span><br></pre></td></tr></table></figure>

<p>mimikatz通过/sid选项接收SID号然后在尾部拼接RID号（512,519等），拼接之后生成的Enterprise Admins组的完整SID是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S-1-5-21-3641416521-285861825-2863956705-519</span><br></pre></td></tr></table></figure>

<p>而这个SID在整个域林中都是不存在的，所以在子域中通过mimikatz生成的金票无法跨域或者是访问其他域的资源。在一个域林中，域控权限不是终点，根域的域控权限才是域渗透的终点。</p>
<h2 id="3-突破限制"><a href="#3-突破限制" class="headerlink" title="3 突破限制"></a>3 突破限制</h2><p>普通的黄金票据被限制在当前域内，在2015年Black Hat USA中国外的研究者提出了突破域限制的增强版的黄金票据。通过域内主机在迁移时LDAP库中的SIDHistory属性中保存的上一个域的SID值制作可以跨域的金票。这里没有迁移，直接拿根域的SID号做演示。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791470523.png" alt="1575791470523"></p>
<p>如果知道根域的SID那么就可以通过子域的KRBTGT的HASH值，使用mimikatz创建具有 Enterprise Admins组权限（域林中的最高权限）的票据。环境与上文普通金票的生成相同。</p>
<p>首先我们通过klist purge删除当前会话的Kerberos票据，也可以在mimikatz里通过kerberos::purge来删除。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791477562.png" alt="1575791477562"></p>
<p>然后通过mimikatz重新生成包含根域SID的新的金票</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kerberos::golden &#x2F;admin:administrator &#x2F;domain:news.yunying.lab &#x2F;sid:XXX &#x2F;sids:XXX &#x2F;krbtgt:XXX &#x2F;startoffset:0 &#x2F;endin:600 &#x2F;renewmax:10080 &#x2F;ptt</span><br></pre></td></tr></table></figure>

<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791488437.png" alt="1575791488437"></p>
<p>Startoffset和endin分别代表偏移量和长度，renewmax表示生成的票据的最长时间</p>
<p>注意这里是不知道根域YUNYING.LAB的krbtgt的密码HASH的，使用的是子域NEWS.YUNYING.LAB中的KRBTGT的密码HASH。</p>
<p>然后再通过dir访问DC. YUNYING.LAB的共享文件夹，发现已经可以成功访问。</p>
<p><img src="Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%BA%8C%E7%A5%A8%E6%8D%AE%E7%AF%87.assets/1575791498146.png" alt="1575791498146"></p>
<p>此时的这个票据票是拥有整个域林的控制权的。我们知道制作增强金票的条件是通过SIDHistory那防御方法就是在域内主机迁移时进行SIDHistory过滤，它会擦除SIDHistory属性中的内容。</p>
<h1 id="0x05小结"><a href="#0x05小结" class="headerlink" title="0x05小结"></a>0x05小结</h1><p>​         本文主要说明了MS14068的利用方式和金银票据，主要用来提升和维持域内权限，通常情况下需要结合其他的域内攻击方式进行使用，比如获取了域控制器的NTLM HASH等内容时。下一文将介绍关于Kerberos委派相关的攻击手法和实现原理。</p>
<h1 id="实验工具"><a href="#实验工具" class="headerlink" title="实验工具"></a>实验工具</h1><p><a href="https://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181209" target="_blank" rel="noopener">https://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181209</a></p>
<p><a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068" target="_blank" rel="noopener">https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</a></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://adsecurity.org/?p=1640" target="_blank" rel="noopener">https://adsecurity.org/?p=1640</a></p>
<p><a href="https://adsecurity.org/?p=2011" target="_blank" rel="noopener">https://adsecurity.org/?p=2011</a></p>
<p><a href="https://www.cnblogs.com/backlion/p/8127868.html" target="_blank" rel="noopener">https://www.cnblogs.com/backlion/p/8127868.html</a></p>
<p><a href="https://blogs.msdn.microsoft.com/openspecification/2009/04/24/understanding-microsoft-kerberos-pac-validation/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/openspecification/2009/04/24/understanding-microsoft-kerberos-pac-validation/</a></p>

        </div>

        
            <section class="post-copyright">
                
                
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/12-18-PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93%E5%8F%8A%E8%87%AA%E9%97%AE%E8%87%AA%E7%AD%94/">PE文件结构总结及自问自答</a>
            
            
            <a class="next" rel="next" href="/2020/12-18-Kerberos%E5%8D%8F%E8%AE%AE%E6%8E%A2%E7%B4%A2%E7%B3%BB%E5%88%97%E4%B8%89%E5%A7%94%E6%B4%BE%E7%AF%87/">Kerberos协议探索系列三委派篇</a>
            
        </section>
	
		<section id="comments" class="comments">
		  <style>
			.comments{margin:30px;padding:10px;background:#fff}
			@media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#fff}}
		  </style>
		  <div class="valine_comment"></div>
<!--载入js，在</body>之前插入即可-->
<!--Leancloud 操作库:-->
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!--Valine 的核心代码库-->
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  new Valine({
      el: '.valine_comment',
      app_id: 'ehQ0k7G3fcpwmkyxhG8U6DzL-gzGzoHsz',
      app_key: 'AwwXGgbdqswiimAY0qJYhtRa',
      placeholder: '这里留言。。',
      notify: 'true',
      verify: 'true',
    });
</script>
		</section>
	

    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© SeikoSrp | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
